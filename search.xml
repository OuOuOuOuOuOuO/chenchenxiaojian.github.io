<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux中swap分区]]></title>
    <url>%2Flinux%E4%B8%ADswap%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[swap交换分区 Swap分区在系统的物理内存(这里应该是运行内存)不够用的时候，把物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中 ​ ——百度百科 创建swap分区 分区：fdisk命令，而parted命令（2T硬盘） 将分区格式化为swap分区 使用swap分区 free命令 查看系统内存使用情况和swap分区的使用情况 123456[root@chenxiaojian Desktop]# free -h total used free shared buffers cachedMem: 979M 911M 68M 14M 408K 316M-/+ buffers/cache: 594M 385MSwap: 0B 0B 0B[root@chenxiaojian Desktop]# buffers:表示缓冲区，例如我们用键盘打字时，就是先写入缓冲区，也就是说这个用于向文件中写数据时进行缓存的 cached：表示缓存区，当我们取数据时，我们可以不需要读取磁盘上的数据（磁盘读取太慢了），使用cached缓存更快的获得数据 创建swap分区的命令 分区：fdisk /dev/sdb 格式化分区：mkswap /dev/sdb1 启动分区：swapon /dev/sdb1 取消加入的分区：swapoff /dev/sdb1 设置开机自启：/dev/sdb1 swap swap defaults 0 0]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux中swap分区</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7_linux防火墙详解]]></title>
    <url>%2Fcentos7-linux%E9%98%B2%E7%81%AB%E5%A2%99%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[使用firewall-config进行配置 使用命令行进行配置（firewall-cmd） 常用命令：firewall-cmd –list-all / firewall-cmd –reload (重载） 使用firewall-cmd – + “tab键”进行查看命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[root@chenxiaojian ~]# firewall-cmd --add-service=http --permanent success[root@chenxiaojian ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 sources: services: ssh dhcpv6-client nfs ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@chenxiaojian ~]# firewall-cmd --list-all --permanent public target: default icmp-block-inversion: no interfaces: sources: services: ssh dhcpv6-client nfs http ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@chenxiaojian ~]# firewall-cmd --reload success[root@chenxiaojian ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 sources: services: ssh dhcpv6-client nfs http ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@chenxiaojian ~]# ^C[root@chenxiaojian ~]# 修改配置文件 /etc/firewalld (修改) /usr/lib/firewalld（默认配置文件） 123456789101112131415161718192021[root@chenxiaojian zones]# cd /etc/firewalld/[root@chenxiaojian firewalld]# ll总用量 8-rw-r--r--. 1 root root 2006 10月 31 2018 firewalld.confdrwxr-x---. 2 root root 6 10月 31 2018 helpersdrwxr-x---. 2 root root 6 10月 31 2018 icmptypesdrwxr-x---. 2 root root 6 10月 31 2018 ipsets-rw-r--r--. 1 root root 271 10月 31 2018 lockdown-whitelist.xmldrwxr-x---. 2 root root 6 10月 31 2018 servicesdrwxr-x---. 2 root root 46 9月 15 21:59 zones[root@chenxiaojian firewalld]# cat zones/public.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;zone&gt; &lt;short&gt;Public&lt;/short&gt; &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt; &lt;service name="ssh"/&gt; &lt;service name="dhcpv6-client"/&gt; &lt;service name="nfs"/&gt; &lt;service name="http"/&gt;&lt;/zone&gt;[root@chenxiaojian firewalld]# 1234567891011121314151617181920212223[root@chenxiaojian zones]# cd /usr/lib/alsa/ firmware/ java-1.6.0/ jvm-private/ modules-load.d/ sysctl.d/binfmt.d/ fontconfig/ java-1.7.0/ kbd/ mozilla/ systemd/crda/ games/ java-1.8.0/ kdump/ NetworkManager/ tmpfiles.d/cups/ gcc/ java-ext/ kernel/ polkit-1/ tuned/debug/ grub/ jvm/ locale/ python2.7/ udev/dracut/ java/ jvm-commmon/ modprobe.d/ rpm/ yum-plugins/firewalld/ java-1.5.0/ jvm-exports/ modules/ sse2/ [root@chenxiaojian zones]# cd /usr/lib/firewalld/[root@chenxiaojian firewalld]# lshelpers icmptypes ipsets services xmlschema zones[root@chenxiaojian firewalld]# ll zones/总用量 36-rw-r--r--. 1 root root 299 10月 31 2018 block.xml-rw-r--r--. 1 root root 293 10月 31 2018 dmz.xml-rw-r--r--. 1 root root 291 10月 31 2018 drop.xml-rw-r--r--. 1 root root 304 10月 31 2018 external.xml-rw-r--r--. 1 root root 369 10月 31 2018 home.xml-rw-r--r--. 1 root root 384 10月 31 2018 internal.xml-rw-r--r--. 1 root root 315 10月 31 2018 public.xml-rw-r--r--. 1 root root 162 10月 31 2018 trusted.xml-rw-r--r--. 1 root root 311 10月 31 2018 work.xml[root@chenxiaojian firewalld]# firewall的区域 123456789101112131415161718192021222324252627[root@chenxiaojian firewalld]# firewall-cmd --get-default-zone public# 网卡激活选择的区域是public[root@chenxiaojian firewalld]# firewall-cmd --get-active-zones public interfaces: ens33#查看特定区域的情况[root@chenxiaojian firewalld]# firewall-cmd --list-all --zone=public public (active) target: default icmp-block-inversion: no interfaces: ens33 sources: services: ssh dhcpv6-client nfs http ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: #查看区域[root@chenxiaojian firewalld]# firewall-cmd --get-zonesblock dmz drop external home internal public trusted work 检查排序(暂时不太能理解) 源地址关联区域 接口关联区域 默认区域 区域规则排序 端口转发和伪装 记录规则 允许规则 拒绝规则 默认规则 编写富规则建议还是用图形化界面进行配置吧！！ 富规则可以用在例如我们允许主机2登录主机1，但是不允许主机3登录主机1，这时我们可以先开发所有的主机访问主机1，然后设置富规则，拒绝主机3访问主机1 1234567891011121314151617181920#man手册查看富规则[chenxiaojian@chenxiaojian ~]$ man -k firewalldfirewall-cmd (1) - firewalld command line clientfirewall-config (1) - firewalld GUI configuration toolfirewall-offline-cmd (1) - firewalld offline command line clientfirewalld (1) - Dynamic Firewall Managerfirewalld.conf (5) - firewalld configuration filefirewalld.dbus (5) - firewalld D-Bus interface descriptionfirewalld.direct (5) - firewalld direct configuration filefirewalld.helper (5) - firewalld helper configuration filesfirewalld.icmptype (5) - firewalld icmptype configuration filesfirewalld.ipset (5) - firewalld ipset configuration filesfirewalld.lockdown-whitelist (5) - firewalld lockdown whitelist configuration filefirewalld.richlanguage (5) - Rich Language Documentationfirewalld.service (5) - firewalld service configuration filesfirewalld.zone (5) - firewalld zone configuration filesfirewalld.zones (5) - firewalld zones[chenxiaojian@chenxiaojian ~]$ man firewalld.richlanguage[chenxiaojian@chenxiaojian ~]$ 富规则语法 [source] [destination] 表示可选，如果省略，则代表所有主机 伪装 也就是说一个网卡跟外网连接，然后通过这个网卡传递数据到外网的ip地址都会转换为这个网卡的ip地址 直接开启网卡的伪装选项 进行富规则的编写实现伪装 端口转发forward-port 端口转发（Port forwarding），有时被叫做隧道，是安全壳(SSH) 为网络安全通信使用的一种方法。端口转发是转发一个网络端口从一个网络节点到另一个网络节点的行为，使得一个外部用户从外部经过一个被激活的NAT路由器到达一个在私有内部IP地址（局域网内部）上的一个端口。 也就是我们设置端口映射例如为80–》》8080，那么我们访问80，就自动访问到端口8080]]></content>
      <categories>
        <category>Linux</category>
        <category>firewall</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python——numpy基础]]></title>
    <url>%2Fpython%E2%80%94%E2%80%94numpy%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数组对象常用属性 属性 说明 dtype 返回数组中元素的类型 shape 返回由整数组成的元组，元组中的每个整数依次对应数组的每个轴的元素个数 size 返回数组中元素的个数 ndim 返回数组的维度 函数创建数组array()1234567data = np.array([1,2,3,4],dtype=float)data#array([1., 2., 3., 4.])data=np.array([1,2,3,4],ndmin=2)data#array([[1, 2, 3, 4]]) 注意这里是代表二维 zeros()123456np.zeros((2,10))#(2,10)2表示0维度元素个数为2，1维度元素个数为10"""array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]])""" 123data = np.array([1,2,3,4])np.zeros_like(data) # 参数是一个数组，这个函数就能根据这个数组的维度创建数组，只不过元素的值变成0#array([0, 0, 0, 0]) 创建同一种元素的数组ones,ones_like/ zeors,zeros_like /empty,empty_like12345678910np.ones((2,5), dtype=int)"""array([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]])"""np.ones((2,5))"""array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]])""" 1234567891011121314151617data = np.array([[1,2,3,4],[2,2,3,4]])np.ones_like(data)"""array([[1, 1, 1, 1], [1, 1, 1, 1]]) """# 注意新建的数组会默认继承ones_like参数的类型data = np.array([[1,2.2,3,4],[2,2,3,4]])np.ones_like(data)"""array([[1., 1., 1., 1.], [1., 1., 1., 1.]])"""# 设置参数data = np.array([[1,2,3,4],[2,2,3,4]])np.ones_like(data,dtype=float) 创建其他数值的数组1234567891011121314da = np.array([[1,2,3,4],[5,5,5,5],[6,6,6,6]])df = 2 * np.ones_like(da)df"""array([[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]) """ np.full(da.shape, 3)"""array([[3, 3, 3, 3], [3, 3, 3, 3], [3, 3, 3, 3]]) """ 创建对角线数组 eys() identity() diag() 12345678910111213141516171819202122232425# eys()创建一个方阵，并且这个方阵的对角线可以调整np.eye(4,dtype=int)"""array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) """np.eye(4,dtype=int,k=1)"""array([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]]) """np.eye(4,dtype=int,k=-2)"""array([[0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0], [0, 1, 0, 0]]) """ 123456789101112131415#identity()不能移动对角线np.identity(4)"""array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) """np.identity(4,dtype=int)"""array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])""" 12345678910111213141516171819202122232425262728#对角线的元素的值可以有这个函数决定，也可以调整对角线的位置np.diag([1,2,3,4])"""array([[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]])"""np.diag((1,2,3,4))"""array([[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]) """#注意这里创建了一个5行5列的方阵np.diag([1,2,3,5],k=1)"""array([[0, 1, 0, 0, 0], [0, 0, 2, 0, 0], [0, 0, 0, 3, 0], [0, 0, 0, 0, 5], [0, 0, 0, 0, 0]]) """ 创建元素是等差等比数列12345678910111213# np.arange()创建一个类似于range()函数的数组np.arange(1,10,2)"""array([1, 3, 5, 7, 9])"""# np.linspace()函数，也就是说这个函数的第三个参数是这个数组的元素的个数#这个函数默认是包含右区间的，可以设置endpoint=false#Signature: np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)np.linspace(1,10,7)#array([ 1. , 2.5, 4. , 5.5, 7. , 8.5, 10. ]) 1234567# 创建的等比数列的函数# np.logspace()默认是以10为底的，start,end为指数#Signature: np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)np.logspace(2,5,4)#array([ 100., 1000., 10000., 100000.]) 数组的索引和切片数组的轴 123456789101112131415161718192021# 创建一个数组的结构为（2,3,4）a = np.arange(24).reshape((2,3,4))a"""array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]])""" a[1]"""array([[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]])"""a[1][1][2] #表示的是数组a的0轴方向索引为1的元素，1轴方向索引为1的元素，2轴方向索引为2的元素#18 根据索引取得数组的元素 跟列表的操作基本一致，可以根据数组的下标进行查看，修改 查看数组的元素的下标形式 array[1] / array[1,2] / array[(1,2)] / array[1][2] 1234567891011121314151617181920import numpy as npdata = np.arange(0,10,1).reshape(2,5)print(data)# [[0 1 2 3 4]# [5 6 7 8 9]]print(data[1])print(data[1][2])print(data[1,2])print(data[(1,2)])# 7# 7# 7# modify arraydata[1][2] = 9999print(data)# [[ 0 1 2 3 4]# [ 5 6 9999 8 9]] 通过下标是列表访问数组元素 1234567891011121314151617181920212223242526272829303132333435# 下标是列表获取数组元素import numpy as np data = np.arange(0,12,1).reshape(3,4)print(data)# [[ 0 1 2 3]# [ 4 5 6 7]# [ 8 9 10 11]]data1 = data[[0,1]]yuansuprint(data1)# [[0 1 2 3]# [4 5 6 7]]data2 = data[[0,1],[1,2]]print(data2)# [1 6]data3 = data[[1,2],[1,3]] print(data3)# [ 5 11]#一维数组a = np.arange(0,5,1)print(a)print(a[4])# [0 1 2 3 4]# 4# 总结：可以这么理解，#对于一个一维数组，访问元素就是根据c[a,b,v]列表中的元素进行索引，跟list一样#对于一个二维数组而言，若给出c[[a,b],[c,d]]那么就是去c[a,c]和c[b,d] 通过下标是数组访问数组元素12345678910111213data = np.arange(1,11)print(data)index = np.array([1,2,3,5])print("数组作为下标的：", data[index])# [1 2 3 4 5 6 7 8 9]# 数组作为下标的： [2 3 4 6]data1 = data.reshape(2,5)print(data1)print(data1[[1,1], [0,2]])data1 = data1[np.array([1,1]), np.array([0,2])] #等价于data1[[1,1],[0,2]]print(data1) 12345678910111213141516171819202122232425data1 = data.reshape(2,5)print(data1)print(data1[[1,1], [0,2]])data1 = data1[np.array([1,1]), np.array([0,2])] #等价于data1[[1,1],[0,2]]print(data1)t = data1 == 2p = data == 2print("t数组为：", t)print("p数组为：", p)# t数组为： [False False]# p数组为： [False True False False False False False False False False]data2 = data.reshape(2,5)print(data2)index1 = np.array([False, True])print("data2的数组：",data2[index1])# data2的数组： [[ 6 7 8 9 10]],# True取了0轴为真的一行print("数组中大于5的数字", data2[data2&gt;5])# 数组中大于5的数字 [ 6 7 8 9 10] 数组的切片需注意的是通过切片得到的数组与原数组共享一个内存空间 对于一维数组123456789101112131415161718192021222324252627import numpy as np# 数组真的切片# 一位数组a = np.arange(10, 20)print(a)b = a[2:8] #左开右闭print("b数组：", b)# [10 11 12 13 14 15 16 17 18 19]y# b数组： [12 13 14 15 16 17]b[0] = 9999print("b数组为：", b)print("a数组为：", a)# b数组为： [9999 13 14 15 16 17]# a数组为： [ 10 11 9999 13 14 15 16 17 18 19]print(a[::2])print(a[::-1])print(a[3:])# [ 10 9999 14 16 18]# [ 19 18 17 16 15 14 13 9999 11 10]# [13 14 15 16 17 18 19] 对于二维数组12345678910111213141516171819202122232425262728293031# 二维数组c = np.arange(0, 60, 10).reshape(-1, 1) + np.arange(0, 6)print(c)print(c[1:4])print(c[1:4, 2:5])print(c[:, 2])print(c[::2, ::2])print(c[:3, [0, 3]])"""[[10 11 12 13 14 15] [20 21 22 23 24 25] [30 31 32 33 34 35]][[12 13 14] [22 23 24] [32 33 34]][ 2 12 22 32 42 52][[ 0 2 4] [20 22 24] [40 42 44]] [[ 0 3] [10 13] [20 23]]""" 数组变形 np.narray.reshape()和np.reshape(array,(1,2))是返回一份拷贝，也就是说对其的操作不会影响到原来的数组本身 也可以用数组的属性array.shape = （1,10）进行变形 变为一维数组的函数： np.array.flatten() 返回的是一个拷贝 np.array.reval()与np.reval(array)返回的一份视图，对其操作会影响到原来的数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import numpy as npdata = np.arange(10)data1 = data.reshape(2, 5)print(data, data1)print(id(data), "hahahh", id(data1))# 139928707398352 hahahh 139928707398432#data2 = np.reshape(data, (2, 5)) print(data2)print(id(data2))# 140256722626560##一个是一维数组，一个是二维数组，只不过是0轴只有一个元素print(np.reshape(data, (10, )))print(np.reshape(data, (1, 10)))# [0 1 2 3 4 5 6 7 8 9]# [[0 1 2 3 4 5 6 7 8 9]]##numpy知道1轴上只有一个元素，然后就会自动推断0轴上有多少个元素data3 = np.reshape(data, (-1, 1))print(data3)# [[0]# [1]# [2]# [3]# [4]# [5]# [6]# [7]# [8]# [9]]# =============================data3.shape = (2, 5) #操作的是这个数组本身print(data3)# [[0 1 2 3 4]# [5 6 7 8 9]]# =============================#将数组设置为一维数组data4 = data1print(data4)p = data4.flatten() #生成一个新数组，并且相对原来数组不在同一个视图print(p)print(id(data4))print(id(p))"""[[0 1 2 3 4] [5 6 7 8 9]][0 1 2 3 4 5 6 7 8 9]140612501121984140612211456480"""data5 = np.ravel(data1) #与原数共享同一个视图print(data5)# [0 1 2 3 4 5 6 7 8 9]#data5[2] = 88888print("data5:", data5)print("data1:", data1)print(id(data5),id(data1))print(data5 is data1)# False# # data5: [ 0 1 88888 3 4 5 6 7 8 9]# data1: [[ 0 1 88888 3 4]# [ 5 6 7 8 9]] 常用方法astype() 能够根据指定的类型新生成一个数组 12345678910111213import numpy as npdata = np.array([[1,2,3],[2,3,4],[3,4,5]])new_data = data.astype(float)new_data, data"""(array([[1., 2., 3.], [2., 3., 4.], [3., 4., 5.]]), array([[1, 2, 3], [2, 3, 4], [3, 4, 5]]))""" np.expand_dims(array,axis) 增加数组的轴数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# =========================# # 对于这个函数，我们我们现在可以粗略地理解，就是增加一个轴，前提参数axis是合法的。然后数组的shape就是axis所在的轴变成为1，# 原先数组的轴往右移，例如：（1,2,3,4） axis=2 ==&gt;结果为：（1,2,1,3,4）# data6 = np.arange(0,9)print(data6)print(data6.shape)# [0 1 2 3 4 5 6 7 8]# (9,)data8 = np.expand_dims(data6,axis=0)print(data8)print(data8.shape)# [[0 1 2 3 4 5 6 7 8]]# (1, 9)data6 = np.expand_dims(data6, axis=1)print(data6)print(data6.shape)# [[0]# [1]# [2]# [3]# [4]# [5]# [6]# [7]# [8]]# (9, 1)# =========================data7 = np.array([[1,2,3],[4,5,6]])print(data7.shape)# (2,3)data7 = np.expand_dims(data7,axis=2)print(data7)print(data7.shape)# (2,3,1)# =========================data8 = np.array([[[1,2,3,4]]])print(data8.shape)print(data8)# (1, 1, 4)# [[[1 2 3 4]]]data8 = np.expand_dims(data8,axis=2)print(data8.shape)print(data8)# (1, 1, 1, 4)# [[[[1 2 3 4]]]]# =========================data9 = np.array([[[1,2,5],[3,4,6]]])print(data9.shape)print(data9)data9 = np.expand_dims(data9,axis=2)print(data9.shape)# [[[1 2 5]# [3 4 6]]]# (1, 2, 1, 3) np.concatenate((a,b),axis=0/1) 将数组a,b进行组合，当axis=0时表示垂直组合，当axis=1时表示水平组合 数组的组合与分割水平组合–0轴方向形状一样 np.hstack(tuple)，参数为元组，包含被组合在一起的数组 1234567891011121314import numpy as np a = np.arange(9).reshape(3,3)b = np.arange(12).reshape(3,4)c = np.arange(15).reshape(3,5)# 水平组合:需要保证0轴上元素个数是相同的a_b = np.hstack((a,b))print(a_b)"""[[ 0 1 2 0 1 2 3] [ 3 4 5 4 5 6 7] [ 6 7 8 8 9 10 11]]""" 垂直组合–1轴方向形状一样 np.vstack(tuple) 1234567891011121314151617181920# 垂直组合：需要保证1轴上元素个数是相同的b1 = b.Tprint(b1)"""[[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] """ab1 = np.vstack((a,b1))print(ab1)# [[ 0 1 2]# [ 3 4 5]# [ 6 7 8]# [ 0 4 8]# [ 1 5 9]# [ 2 6 10]# [ 3 7 11]]]]></content>
      <categories>
        <category>Python数据分析</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下jupyter_notebook的使用出现的问题]]></title>
    <url>%2Flinux%E4%B8%8Bjupyter-notebook%E7%9A%84%E4%BD%BF%E7%94%A8%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[针对鱼linux,首先这个jupyter ntebook新建一个python3的文件出现error,可能是由于防火墙的原因，关闭防火墙，或者开放8888端口 1systemctl stop firewall.service 啊啊啊啊啊啊啊啊]]></content>
      <categories>
        <category>Python数据分析</category>
        <category>配置问题</category>
      </categories>
      <tags>
        <tag>python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度算法]]></title>
    <url>%2F%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[高精度乘法（无符号） 算法的过程就是模拟我们手算乘法的过程 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//高精度乘法int main()&#123; string a, b; int arr[200]; int brr[200]; int crr[400]; cin &gt;&gt; a &gt;&gt; b; memset(arr, 0, sizeof(arr)); //赋值0 for (int i = 1; i &lt;= a.size(); i++) arr[i] = a[a.size() - i] - '0'; //将字符串a的高位(其实是数字的低位)存在数组arr的地位 for (int j = 1; j &lt;= b.size(); j++) brr[j] = b[b.size() - j] - '0'; memset(crr, 0, sizeof(crr)); for (int i = 1;i &lt;= a.size();i++) for (int j = 1; j &lt;= b.size(); j++) &#123; crr[i + j - 1] += arr[i] * brr[j]; //例如1234 X 23456 则存放类似 6*4=30 crr[i + j] += crr[i + j - 1] /10; //30大于10进位，--》》3 crr[i + j - 1] %= 10; //进完位，剩下的余数 &#125; //控制输出，清除高位的0，也就是确定这个积有多少位数 int result_length = a.size() + b.size(); while (crr[result_length] == 0) result_length--; for (int i = result_length; i &gt;0; i--) cout &lt;&lt; crr[i]; cout &lt;&lt; endl;&#125; 高精度加法（无符号） 模拟加法的过程 123456789101112131415161718192021222324252627282930313233343536int main()&#123; string a, b; cin &gt;&gt; a &gt;&gt; b; int arr[500]; int brr[500]; int crr[500]; memset(arr, 0, sizeof(arr)); memset(brr, 0, sizeof(brr)); memset(crr, 0, sizeof(crr)); for (int i = 1; i &lt;= a.size(); i++) arr[i] = a[a.size() - i] - '0'; for (int i = 1; i &lt;= b.size(); i++) brr[i] = b[b.size() - i] - '0'; int max_length = a.size() &gt; b.size() ? a.size() : b.size(); for (int i = 1; i &lt;= max_length; i++) &#123; crr[i] = arr[i] + brr[i]; crr[i + 1] += crr[i] / 10; crr[i] %= 10; &#125; max_length++; while (crr[max_length] == 0) &#123; max_length--; &#125; for (int i = max_length; i &gt; 0; i--) cout &lt;&lt; crr[i]; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>高精度</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux的http服务]]></title>
    <url>%2Flinux%E7%9A%84http%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[http服务 配置文件：/etc/httpd/conf/httpd.conf 配置文件内容： ServerRoot “/etc/httpd” 表示主要配置文件 DocumentRoot “/var/www/html” 表示访问主目录的路径 Listen 80 监听端口 &lt;Directory “/var/www/html”&gt; AllowOverride None # Allow open access: Require all granted&lt;/Directory&gt; 表示对这个/var/www文件的访问权限 Require all granted / denied &lt;RequireAll&gt; 设置特定主机名、ip地址不能访问 注意要加标签&lt;RequireAll&gt; require all granted require not ip/host &lt;内容&gt; &lt;/RequireAll&gt; 设置完成后记得重启服务，如果出现error systemctl status httpd -l，查看错误原因 ls -Z 查看文件的上下文]]></content>
      <categories>
        <category>Linux</category>
        <category>http</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程管理]]></title>
    <url>%2F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[进程管理进程是运行中的可执行程序，一个程序有一个或多个进程进程：内存地址空间，安全属性，一个或多个线程，状态父进程可以创建子进程 红帽7的第一个进程是systemd，所有进程都是第一个进程的后代，PID（进程id）,systemd的PID是1，PPID（父进程id） ps aux 查看所有终端，所有 用户，所有进程(静态的，查看某一个瞬间的信息) pstree查看进程树 进程有三种状态 R 运行状态 S 睡眠状态 T 暂时状态 ps aux 命令 查看所有终端，所有用户，所有用户的进程 tty表示终端，而pts是所谓的虚拟终端，具体表现为当你打开一个终端，这个终端就叫做pts/0，当你在打开另一个终端，这个终端就叫做pts/1 123456789101112# 查看当前终端的进程# tty1 表示当前终端# pts/0表示虚拟终端[root@chenxiaojian chenxiaojian]# ps a PID TTY STAT TIME COMMAND 8138 tty1 Ssl+ 0:13 /usr/bin/X :0 -background none -noreset -audit 4 -verbose -auth /run/gdm/aut 10434 pts/0 Ss 0:00 bash 11331 pts/0 S 0:00 su 11362 pts/0 S 0:00 bash 11922 pts/0 R+ 0:00 ps a[root@chenxiaojian chenxiaojian]# 12345678910111213# head默认是输出10行结果[root@chenxiaojian chenxiaojian]# ps aux | headUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.3 0.3 128560 7208 ? Ss 20:59 0:13 /usr/lib/systemd/systemd --switched-root --system --deserialize 22root 2 0.0 0.0 0 0 ? S 20:59 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? S 20:59 0:00 [ksoftirqd/0]root 5 0.0 0.0 0 0 ? S&lt; 20:59 0:00 [kworker/0:0H]root 7 0.0 0.0 0 0 ? S 20:59 0:00 [migration/0]root 8 0.0 0.0 0 0 ? S 20:59 0:00 [rcu_bh]root 9 0.0 0.0 0 0 ? R 20:59 0:02 [rcu_sched]root 10 0.0 0.0 0 0 ? S&lt; 20:59 0:00 [lru-add-drain]root 11 0.0 0.0 0 0 ? S 20:59 0:00 [watchdog/0] USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 1：代表这个进程是以什么用户进行执行 2：代表进程唯一标识ID 3：表示进程占用的CPU 4：表示进程占用的内存 5：VSZ表示虚拟内存 （虚拟内存，就是当物理内存不足时，将硬盘空间作为内存进行使用，Windows家族的“虚拟内存”；Linux的“交换空间“） 6：表示占用的物理内存 7：TTY表示进程用户登录的终端，如果是？，则表示是系统内部进程 8：表示进程的状态 （进程的状态参见https://blog.csdn.net/weixin_43116910/article/details/88544155） 9：进程开始的时间 10：进程执行了多少时间 11：表示进程的名称 top命令动态查看进程的状态 作业管理jobs查看 -l 可以查看进程的PID （ps j 可以查看） ctrl + c结束作业 ctrl + z暂停作业 fg % 进程号 —将进程调到前台进行运行 bg %进程号 —将进程调到后台进行运行 如果一个进程后面加个&amp; 表示在后台进行 [chenxiaojian@chenxiaojian ~]$ sleep 100&amp;[6] 19004[chenxiaojian@chenxiaojian ~]$ jobs[1]+ 已停止 sleep 1000[2] 已停止 sleep 1000[3] 已停止 sleep 1000[4] 已停止 sleep 1000[5]- 已停止 sleep 1000[6] 运行中 sleep 100 &amp;[chenxiaojian@chenxiaojian ~]$ kill命令 向进程发送信号，kill + PID 结束进程 （这个进程需是正在运行的） kill -l 查看所有的信号 15) SIGTERM（结束进程） 18) SIGCONT 19) SIGSTOP （暂时停止） 用法：kill -s 信号 进程ID 123456789101112131415161718192021[chenxiaojian@chenxiaojian ~]$ sleep 10000^Z[1]+ 已停止 sleep 10000[chenxiaojian@chenxiaojian ~]$ [chenxiaojian@chenxiaojian ~]$ [chenxiaojian@chenxiaojian ~]$ ps j PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 10412 10434 10434 10434 pts/0 20677 Ss 1000 0:00 bash 15446 15485 15485 15485 tty2 15485 Ss+ 1000 0:00 -bash 17494 17495 17495 10434 pts/0 20677 S 1000 0:00 bash 17495 20651 20651 10434 pts/0 20677 T 1000 0:00 sleep 10000 17495 20677 20677 10434 pts/0 20677 R+ 1000 0:00 ps j[chenxiaojian@chenxiaojian ~]$ kill -s 18 20651[chenxiaojian@chenxiaojian ~]$ ps j PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 10412 10434 10434 10434 pts/0 20703 Ss 1000 0:00 bash 15446 15485 15485 15485 tty2 15485 Ss+ 1000 0:00 -bash 17494 17495 17495 10434 pts/0 20703 S 1000 0:00 bash 17495 20651 20651 10434 pts/0 20703 S 1000 0:00 sleep 10000 17495 20703 20703 10434 pts/0 20703 R+ 1000 0:00 ps j[chenxiaojian@chenxiaojian ~]$ pkill命令 pkill + 进程名 pkill httpd killall命令 杀死一个进程所有的相关进程 nice 优先级 使用cpu，优先级越大（数值越小），使用CPU越优先 NI -20~19 nice -n &lt;优先级&gt; &lt;命令&gt; 指定命令运行的优先级 1234567891011121314151617[root@chenxiaojian chenxiaojian]# toptop - 22:11:20 up 18 min, 2 users, load average: 0.40, 0.29, 0.41Tasks: 290 total, 4 running, 286 sleeping, 0 stopped, 0 zombie%Cpu(s): 20.5 us, 10.4 sy, 0.0 ni, 68.7 id, 0.0 wa, 0.0 hi, 0.4 si, KiB Mem : 1863224 total, 166364 free, 775772 used, 921088 buff/caKiB Swap: 0 total, 0 free, 0 used. 836644 avail M PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ 9687 chenxia+ 20 0 3047484 194884 57180 S 14.1 10.5 0:12.69 8080 root 20 0 330764 56620 31216 R 9.5 3.0 0:04.84 11070 chenxia+ 20 0 840580 27216 15696 S 4.6 1.5 0:02.38 12472 root 20 0 162144 2440 1596 R 1.3 0.1 0:00.39 7054 root 20 0 320216 4504 3000 S 1.0 0.2 0:01.55 12331 root 20 0 0 0 0 S 1.0 0.0 0:00.03 1 root 20 0 128436 6664 3740 S 0.7 0.4 0:03.30 7846 root 20 0 1016748 10724 3624 S 0.3 0.6 0:01.01 renice 调整运行的程序的优先级 renice -n &lt;优先级&gt; -p SSH （安全外壳协议） 用来实现两台机器的远程登录和安全的数据传输，其保证数据安全的原理是非对称加密 传统的对称加密使用的是一个套秘匙，数据的加密以及解密用的都是这一套密匙，风险性较大 非对称加密就是为了解决这个问题，它包含两套密匙，公匙和私匙。公匙用来加密，私匙用来解密，公匙不能计算去私匙，所以公匙保存在客户端，也不会产生风险。 运行原理https://www.cnblogs.com/xz816111/p/9479139.html 实现免密登录 ssh-keygen命令 在客户端生成密钥对，输入ssh-keygen命令 ssh-copy-id &lt;服务器的ip地址&gt; （为第一次登录做准备） 下次直接登录就行啦！！！ 控制ssh /etc/ssh/sshd_config 配置文件 PasswordAuthentication yes 是否支持密码等录 PermitRootLogin yes 是否支持root用户登录 PubkeyAuthentication yes 是否支持公钥免密登 （记得重启ssd服务） scp 跨系统复制 文件 scp -r 192.168.18.132:/root/dir2 /root/ 从远端服务器拷贝到本机 -r表示拷贝目录 scp -r /root/dir1/ 192.168.18.132:/root/ 从本机拷贝文件/目录到远端服务器 SFTP &lt;服务器的ip&gt; 同步文件、rsync &lt;选项&gt; &lt;源文件&gt; &lt;目标文件&gt; -a 归档模式 -v 查看过程 -n表示空运行（就是执行这个选项后，会输出那些文件会同步，确认无误后就可以用-av进行同步了） 在两个系统间同步文件，只会同步不同的文件 123456789101112131415161718192021222324252627282930313233343536[root@chenxiaojian ~]# mkdir dir1 dir2[root@chenxiaojian ~]# ll总用量 8-rw-------. 1 root root 1694 9月 15 22:00 anaconda-ks.cfgdrwxr-xr-x. 2 root root 6 9月 27 11:27 dir1drwxr-xr-x. 2 root root 6 9月 27 11:27 dir2-rw-r--r--. 1 root root 1742 9月 15 22:03 initial-setup-ks.cfgdrwxr-xr-x. 2 root root 6 9月 20 21:37 公共drwxr-xr-x. 2 root root 6 9月 20 21:37 模板drwxr-xr-x. 2 root root 6 9月 20 21:37 视频drwxr-xr-x. 2 root root 6 9月 20 21:37 图片drwxr-xr-x. 2 root root 6 9月 20 21:37 文档drwxr-xr-x. 2 root root 6 9月 20 21:37 下载drwxr-xr-x. 2 root root 6 9月 20 21:37 音乐drwxr-xr-x. 2 root root 6 9月 20 21:37 桌面[root@chenxiaojian ~]# touch dir1/1.txt[root@chenxiaojian ~]# [root@chenxiaojian ~]# ls dir1 dir2dir1:1.txt[root@chenxiaojian ~]# rsync -av dir1 dir2sending incremental file listdir1/dir1/1.txtsent 119 bytes received 39 bytes 316.00 bytes/sectotal size is 0 speedup is 0.00[root@chenxiaojian ~]# ls dir1 dir2dir1:1.txtdir2:dir1[root@chenxiaojian ~]# 日志目录结构 systemctl status rsyslog 系统日志服务 systemctl status systemd-journal 收集日志服务 /var/log 日志目录 message 大部分日志 secure 安全 boot.log 系统启动的日志 配置文件/etc/rsyslog.conf 系统启动 graphical.target (图形化界面) muti-user.target 命令行 emergency.target 紧急模式 rescue.target 救援模式 systemctl set-default &lt;目标&gt; 永久 systemd.unit=&lt;目标&gt;，按ctrl + x 加载]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux红帽比赛需要注意的问题]]></title>
    <url>%2FLinux%E7%BA%A2%E5%B8%BD%E6%AF%94%E8%B5%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[查看本机的语言 echo $LANG，locale （查看本机安装的语言包）也可以设置ssh工具的语言编码第0道题 需要注意touch /.autorelabel的拼写 修改网卡的网络连接的配置信息，如果网卡的名字是system eth0,那么nmcli con modify时 要加双引号” connection的配置信息的文件为：/etc/sysconfig/network-scripts/ifcfg-ens33 （路径最后一个为网卡的名） 注意：修改配置文件时，添加ip为IPADDR1= 添加掩码为：PREFIX1= （需要注意的是IPADDR的1表示一个connection可以有多个Ip，那么PREFIX1后面的数字要对应），网关：GATEWAY1= DNS1= 记得重启网络 systemctl restart network 第一道题：设置selinux 永久生效 vim /etc/selinux/config 设置为enforcing 第二道题：yum源 /etc/yum.repo/*.repo yum-config-manager –add &lt;加源的地址&gt; 然后在往新生成的.repo文件中增加gpgcheck=0，执行yum clean all ,查看包数量–yum repolist 第三道题：扩容LVM 查看命令：lsblk df -Th pvs 、vgs lvs 首先查看vg是否有剩余空间，如果有，直接执行lvextend -L 700M /dev/vg1/lvm1 （这个路径可以查看） 创建好分区后，使用pvcreate /dev/sdb2，如果未找到设备，可以使用partprobe 可以使用fdisk -l /dev/sdb查看磁盘的信息，也可以进入fdisk /dev/sdb进入操作界面，p打印信息查看， fdisk -l查看所有磁盘的信息 问题：需要将分区的类型从默认的linux改为8e linux lvm 就能创建lvm吗 答案是不能：如果不修改分区的系统类型，重启就会进入紧急模式，可能是因为不能正确挂载然后出现错误 注意：lv + -L指定大小，-n指定名字 lvcreate -L 500M vg2 -n lvm2 lvextend -L 600M /dev/vg2/lvm2 重新识别文件大小resizeof 第四道题：用户与组 echo 123 | passwd –stdin user1 跟用户相关的三个文件 /etc/passwd /etc/group /etc/shadow 第五道题：文件权限 修改文件的所有者和所有组 chown : &lt;文件&gt; ACL特殊权限 第六道题：周期任务（分时日月周） crontab -e -u natasha -e表示编辑，u表示用户 第七到题：目录权限 记住UGOA 注意特殊权限 chomd g+s &lt;目录&gt; 该目录下的文件自动继承group名 第八道题：更新内核 注意wget命令，下载文件是下载到当前目录，如果没有指定-O，那么这个文件的默认命名就是网络链接的最后一个 / 后面的字符 然后安装，rpm -ivh &lt;包名&gt; uname -r 查看 rpm -ivh –force表示强制安装 第九题：LDAP第十题：autofs自动挂载第十一题：可能需要安装软件包yum -y install chrony 待完成任务：配置ssh https://wenku.baidu.com/view/6486caa384868762cbaed52e.html?sxts=1569289654410]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux需要注意的问题</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux网络配置]]></title>
    <url>%2FLinux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[网络配置device 设备：有物理设备（ens33） 虚拟设备 （virbr0）一个设备可以有多个connect（连接），但是同一个时间只能激活一个连接，相当于一个网卡可以切换不同的网络配置 网络管理 NetworkManager工具有nmcli , nmtui, nm-connection-editor使用这些工具的前提是NetworkManager这个服务有开着systemctl status NetworkManager 方便记忆：nm ==&gt; NetworkManager cli ==&gt; command line （命令行） tui ==&gt;text user interface （文本用户接口） nmcli命令行方式管理网络 nmcli connection 查看网络连接 nmcli device 查看网络设备 1234567891011[chenxiaojian@chenxiaojian ~]$ nmcli connection NAME UUID TYPE DEVICE ens33 fdb135ea-6548-47ca-9de3-f2d2fb390962 ethernet ens33 virbr0 7db188c9-a5ef-4000-ae38-925de7a46397 bridge virbr0 [chenxiaojian@chenxiaojian ~]$ nmcli deviceDEVICE TYPE STATE CONNECTION ens33 ethernet 连接的 ens33 virbr0 bridge 连接的 virbr0 lo loopback 未托管 -- virbr0-nic tun 未托管 -- [chenxiaojian@chenxiaojian ~]$ nmcli device show ens33 查看ens33这个网卡的网络配置 1234567891011121314151617181920[chenxiaojian@chenxiaojian ~]$ nmcli device show ens33GENERAL.DEVICE: ens33GENERAL.TYPE: ethernetGENERAL.HWADDR: 00:0C:29:21:50:C3GENERAL.MTU: 1500GENERAL.STATE: 100 (连接的)GENERAL.CONNECTION: ens33GENERAL.CON-PATH: /org/freedesktop/NetworkManager/ActiveConnection/1WIRED-PROPERTIES.CARRIER: 开IP4.ADDRESS[1]: 192.168.18.131/24IP4.GATEWAY: 192.168.18.2IP4.ROUTE[1]: dst = 0.0.0.0/0, nh = 192.168.18.2, mt = 100IP4.ROUTE[2]: dst = 192.168.18.0/24, nh = 0.0.0.0, mt = 100IP4.DNS[1]: 192.168.18.2IP4.DOMAIN[1]: localdomainIP6.ADDRESS[1]: fe80::f12e:225c:75ea:d0e4/64IP6.GATEWAY: --IP6.ROUTE[1]: dst = fe80::/64, nh = ::, mt = 100IP6.ROUTE[2]: dst = ff00::/8, nh = ::, mt = 256, table=255[chenxiaojian@chenxiaojian ~]$ \ add连接 （若忘记相关命令，按tab进行查看）con-name 表示连接名（自己设置） autoconnect 表示自动连接 ifname 表示接口名 （写网卡的名字） type ethernet （表示以太网） 123456789[chenxiaojian@chenxiaojian ~]$ nmcli connection add con-name ens33-con1 autoconnect yes ifname ens33 type ethernet ipv4.addresses 10.10.10.10/24 ipv4.gateway 10.10.10.254连接“ens33-con1”(fbd49c40-2e33-4fc7-87f5-1b06bc6a304d) 已成功添加。[chenxiaojian@chenxiaojian ~]$ nmcli connection NAME UUID TYPE DEVICE ens33 fdb135ea-6548-47ca-9de3-f2d2fb390962 ethernet ens33 virbr0 7db188c9-a5ef-4000-ae38-925de7a46397 bridge virbr0 ens33-con1 fbd49c40-2e33-4fc7-87f5-1b06bc6a304d ethernet -- [chenxiaojian@chenxiaojian ~]$ 123456789[chenxiaojian@chenxiaojian ~]$ ls /etc/sysconfig/network-scripts/ifcfg-ens33 ifdown-ippp ifdown-Team ifup-ib ifup-ppp init.ipv6-globalifcfg-ens33-con1 ifdown-ipv6 ifdown-TeamPort ifup-ippp ifup-routes network-functionsifcfg-lo ifdown-isdn ifdown-tunnel ifup-ipv6 ifup-sit network-functions-ipv6ifdown ifdown-post ifup ifup-isdn ifup-Team ifdown-bnep ifdown-ppp ifup-aliases ifup-plip ifup-TeamPort ifdown-eth ifdown-routes ifup-bnep ifup-plusb ifup-tunnel ifdown-ib ifdown-sit ifup-eth ifup-post ifup-wireless [chenxiaojian@chenxiaojian ~]$ ls /etc/sysconfig/network-scripts/ 可以发现，在/etc/sysconfig/network-scripts这个目录下创建了ifcfg-ens33-con1这个文件，这样如果我们想修改这个连接的配置，对这个文件进行修改就可以了 up 激活连接nmcli connection up &lt;连接名&gt; 12345678[chenxiaojian@chenxiaojian ~]$ nmcli connection up ens33-con1连接已成功激活（D-Bus 活动路径：/org/freedesktop/NetworkManager/ActiveConnection/4）[chenxiaojian@chenxiaojian ~]$ nmcli connection NAME UUID TYPE DEVICE ens33-con1 fbd49c40-2e33-4fc7-87f5-1b06bc6a304d ethernet ens33 virbr0 7db188c9-a5ef-4000-ae38-925de7a46397 bridge virbr0 ens33 fdb135ea-6548-47ca-9de3-f2d2fb390962 ethernet -- [chenxiaojian@chenxiaojian ~]$ 12345678910111213141516171819202122[chenxiaojian@chenxiaojian ~]$ ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:21:50:c3 brd ff:ff:ff:ff:ff:ff inet 192.168.18.131/24 brd 192.168.18.255 scope global noprefixroute dynamic ens33 valid_lft 1796sec preferred_lft 1796sec inet 10.10.10.10/24 brd 10.10.10.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::8e5a:83f1:7c40:6578/64 scope link noprefixroute valid_lft forever preferred_lft forever3: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000 link/ether 52:54:00:e1:6b:19 brd ff:ff:ff:ff:ff:ff inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0 valid_lft forever preferred_lft forever4: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN group default qlen 1000 link/ether 52:54:00:e1:6b:19 brd ff:ff:ff:ff:ff:ff[chenxiaojian@chenxiaojian ~]$ 可以看见ens33这个网卡多了个ip地址10.10.10.10/24 delete 删除连接nmcli connection delete &lt;连接名&gt; 1234567[chenxiaojian@chenxiaojian ~]$ nmcli connection delete ens33-con1成功删除连接 'ens33-con1'（fbd49c40-2e33-4fc7-87f5-1b06bc6a304d）。[chenxiaojian@chenxiaojian ~]$ nmcli connection NAME UUID TYPE DEVICE ens33 fdb135ea-6548-47ca-9de3-f2d2fb390962 ethernet ens33 virbr0 7db188c9-a5ef-4000-ae38-925de7a46397 bridge virbr0 [chenxiaojian@chenxiaojian ~]$ 相关技巧nmcli connection show ens33 | grep ipv4 查看ipv4的相关信息 ipv4.method – auto表示自动获取 –manual 表示人为设置 1234567891011121314151617181920212223[chenxiaojian@chenxiaojian ~]$ nmcli connection show ens33 | grep ipv4ipv4.method: autoipv4.dns: --ipv4.dns-search: --ipv4.dns-options: ""ipv4.dns-priority: 0ipv4.addresses: --ipv4.gateway: --ipv4.routes: --ipv4.route-metric: -1ipv4.route-table: 0 (unspec)ipv4.ignore-auto-routes: 否ipv4.ignore-auto-dns: 否ipv4.dhcp-client-id: --ipv4.dhcp-timeout: 0 (default)ipv4.dhcp-send-hostname: 是ipv4.dhcp-hostname: --ipv4.dhcp-fqdn: --ipv4.never-default: 否ipv4.may-fail: 是ipv4.dad-timeout: -1 (default)[chenxiaojian@chenxiaojian ~]$ 有关问题设置完静态ip后ip addr查看ip地址出现两个ip的原因cat /etc/sysconfig/network-scripts/ifcfg-ens33-con1中BOOTPROTO=HDCP，（引导协议）表示自动获取ip，所以当我们设置完成静态ip后，加上自动获取ip就会出现两个ip，这个也是允许的，也就是说一个connection可以设置多个ip 解决方法 如果有root用户权限，那么修改该连接的配置信息 vim /etc/sysconfig/network-scripts/ifcfg-ens33-con1 然后找到BOOTPROTO=HDCP将其改为none，表示手动设置，接着重载配置文件（修改完配置文件都要重载），三个步骤：nmcli connection reload ，nmcli connection down ens33-con1;nmcli connection up ens33-con1，至于最后一条命令为何要加分号，主要是当我们远程连接时，你down完后，网络也就断了 如果没有root权限，可以使用nmcli工具进行修改 nmcli connection modify ens33-con1 ipv4.method a 表示修改获取ipv4地址的方式为auto，如果设置为手动就设置为manual/m,然后进行同样的三个步骤 这个三个步骤，可以直接使用systemctl restart network （当NetworkManager不能使用的时候) 设置hostname （主机名的配置文件 /etc/hostname）12345678[chenxiaojian@chenxiaojian ~]$ hostnamectl set-hostname chen[chenxiaojian@chenxiaojian ~]$ [chenxiaojian@chenxiaojian ~]$ hostnamechen[chenxiaojian@chenxiaojian ~]$ cat /etc/hostnamechen[chenxiaojian@chenxiaojian ~]$ hostnamectl set-hostname chenxiaojian[chenxiaojian@chenxiaojian ~]$ 设置名字解析(校园网自家的DNS服务器的地址：192.168.18.2)hosts文件 /etc/hosts 这个文件其实没有多大的作用，但是如果你想Ping 主机名，一般来说，通常是不会Ping到的，因为DNS服务器没有你这个主机名对应的ip地址，如果想要实现这个ping chenxiaojian这个要求，可以在/etc/hosts进行编辑12345678910111213[root@chenxiaojian chenxiaojian]# cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 chenxiaojian::1 localhost localhost.localdomain localhost6 localhost6.localdomain6[root@chenxiaojian chenxiaojian]# ping chenxiaojianPING localhost (127.0.0.1) 56(84) bytes of data.64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.062 ms64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.149 ms64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.111 ms^C--- localhost ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2000msrtt min/avg/max/mdev = 0.062/0.107/0.149/0.036 ms[root@chenxiaojian chenxiaojian]# 通过DNS解析域名 cat /etc/resolv.conf DNS的配置文件不需要修改这个文件，对之前配置网路文件的修改会自动更新到这个文件 vim /etc/sysconfig/network-scripts/ifcfg-ens33 常用的网络测试工具 ip addr –ip地址 ip rout –路由表 ping ww.baidu,com ping -c2 www.baidu.com 接受两个包后结束 ip -s link show ens33 显示网卡接受包的详细信息 查看网卡是否连接 ethtool + &lt;网卡名&gt; 1234567[root@chenxiaojian chenxiaojian]# ip -s link show ens332: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether 00:0c:29:21:50:c3 brd ff:ff:ff:ff:ff:ff RX: bytes packets errors dropped overrun mcast 5696008 6763 0 0 0 0 TX: bytes packets errors dropped carrier collsns 459731 2879 0 0 0 0 123456789101112131415161718192021222324252627282930313233343536[root@chenxiaojian chenxiaojian]# ethtool ens33Settings for ens33: Supported ports: [ TP ] Supported link modes: 10baseT/Half 10baseT/Full 100baseT/Half 100baseT/Full 1000baseT/Full Supported pause frame use: No Supports auto-negotiation: Yes Supported FEC modes: Not reported Advertised link modes: 10baseT/Half 10baseT/Full 100baseT/Half 100baseT/Full 1000baseT/Full Advertised pause frame use: No Advertised auto-negotiation: Yes Advertised FEC modes: Not reported Speed: 1000Mb/s Duplex: Full Port: Twisted Pair PHYAD: 0 Transceiver: internal Auto-negotiation: on MDI-X: off (auto) Supports Wake-on: d Wake-on: d Current message level: 0x00000007 (7) drv probe link Link detected: yes[root@chenxiaojian chenxiaojian]# nmcli conNAME UUID TYPE DEVICE ens33 fdb135ea-6548-47ca-9de3-f2d2fb390962 ethernet ens33 virbr0 ba0275b4-23a5-4131-a3dc-412e0276bf5a bridge virbr0 有线连接 1 f496b294-a26f-3b0b-a738-6735c9b47f89 ethernet -- [root@chenxiaojian chenxiaojian]# ethtool virbr0Settings for virbr0: Link detected: no[root@chenxiaojian chenxiaojian]#]]></content>
      <categories>
        <category>Linux</category>
        <category>网络配置</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时钟同步和定时任务]]></title>
    <url>%2F%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[时钟同步日志，多系统协作，分布式 NTP（网络时钟协议）使用图形化连接到时钟服务器 安装软件包 yum -y install system-config-date 运行system-config-date system-config-date 使用命令行连接到时钟服务器 vim /etc/chrony.conf consider joining the pool (http://www.pool.ntp.org/join.html).server 0.centos.pool.ntp.org iburstserver 1.centos.pool.ntp.org iburstserver 2.centos.pool.ntp.org iburstserver 3.centos.pool.ntp.org iburst （centos7默认连接的时钟服务器，server + 服务器地址 + iburst） 重启服务 systemctl restart chrony timedatectl命令设置系统时间与日期 设置时区，可以先查看时区表是否有所设定的时区 12[chenxiaojian@chenxiaojian ~]$ timedatectl list-timezones | grep -i shangAsia/Shanghai 查看信息 123456789[chenxiaojian@chenxiaojian ~]$ timedatectl status Local time: 五 2019-09-20 17:28:43 CST Universal time: 五 2019-09-20 09:28:43 UTC RTC time: 五 2019-09-20 09:28:44 Time zone: Asia/Shanghai (CST, +0800) NTP enabled: noNTP synchronized: no RTC in local TZ: no DST active: n/a 设置 nfp timedatectl set-ntp true 计划任务计划一次性任务at &lt;时间&gt; at&gt; 命令 按ctrl + D结束 atq查看任务 atrm 删除任务 123456789[chenxiaojian@chenxiaojian ~]$ at 17.36at&gt; echo helloat&gt; &lt;EOT&gt;job 1 at Fri Sep 20 17:36:00 2019[chenxiaojian@chenxiaojian ~]$ atq1 Fri Sep 20 17:36:00 2019 a chenxiaojian[chenxiaojian@chenxiaojian ~]$ 您在 /var/spool/mail/chenxiaojian 中有新邮件[chenxiaojian@chenxiaojian ~]$ 计划周期任务crontab -e 编辑 -l 查看 -r 删除 -u root用户为其他用户设置任务 例子： crontab -e crontab -e -u chenxiaojian 格式： 分 时 日 月 星期 命令 * * * * * 代表每一分钟 N 设置数字 （0和7代表星期一和星期天） */N 表示每N的意思 n-N 表示从n到N这段时间 n, N 表示两个时间]]></content>
      <categories>
        <category>Linux</category>
        <category>时钟同步和定时任务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷】P1498南蛮图腾与杨辉三角的应用]]></title>
    <url>%2F%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P1498%E5%8D%97%E8%9B%AE%E5%9B%BE%E8%85%BE%E4%B8%8E%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[打印杨辉三角12345678910111213141516171819202122232425262728293031323334353637// P1498 南蛮图腾.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include "pch.h"#include &lt;iostream&gt;using namespace std;int yhsj[15][15];int main()&#123; int n; cin &gt;&gt; n; yhsj[1][1] = 1; for (int i = 2; i &lt;= pow(2, n); i++) &#123; for (int j = 1; j &lt;= pow(2, n); j++) &#123; yhsj[i][j] = yhsj[i-1][j-1] + yhsj[i-1][j]; &#125; &#125; int nums = 1; //代表每行要输出的个数 for (int i = 1; i &lt;= pow(2,n); i++) &#123; int space_times = pow(2,n) - nums; for (int k = 0; k &lt; space_times; k++) //输出空格 cout &lt;&lt; " "; for (int j = 1; j &lt;= nums; j++) &#123; cout &lt;&lt; yhsj[i][j] &lt;&lt; " "; &#125; nums++; cout &lt;&lt; endl; &#125; return 0;&#125; 题目描述自从到了南蛮之地，孔明不仅把孟获收拾的服服帖帖，而且还发现了不少少数民族的智慧，他发现少数民族的图腾往往有着一种分形的效果，在得到了酋长的传授后，孔明掌握了不少绘图技术，但唯独不会画他们的图腾，于是他找上了你的爷爷的爷爷的爷爷的爷爷……帮忙，作为一个好孙子的孙子的孙子的孙子……你能做到吗？ 输入格式每个数据一个数字，表示图腾的大小（此大小非彼大小） n&lt;=10 输出格式这个大小的图腾 输入输出样例输入 #1 12 输出 #1 1234 /\ /__\ /\ /\/__\/__\ 输入 #2 13 输出 #2 12345678 /\ /__\ /\ /\ /__\/__\ /\ /\ /__\ /__\ /\ /\ /\ /\/__\/__\/__\/__\ 第一种思路：可以用一个二维数组存放1024行的杨辉三角的值，然后让他们对2取模，然后输出杨辉三角的时如果碰到一个1，就是输出/\，如果碰到两个1，就是输出/__,如果碰到0就输出两个空格； 但是这种思路有个严重的bug,就是用long long存放不下杨辉三角1024行的数的值 Long long能够存放的十进制大概是19位 有bug的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// P1498 南蛮图腾.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include "pch.h"#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;long long yhsj[1050][1050]; //注意长度要大于2的10次方 需要注意的问题就是可能存不下=v=int main()&#123; int n; cin &gt;&gt; n; yhsj[1][1] = 1; for (int i = 2; i &lt;= pow(2, n); i++) &#123; for (int j = 1; j &lt;= pow(2, n); j++) &#123; yhsj[i][j] = yhsj[i-1][j-1] + yhsj[i-1][j]; &#125; &#125; //cout &lt;&lt; yhsj[1024][505] &lt;&lt; endl; //system("pause"); int nums = 1; for (int i = 1; i &lt;= pow(2,n); i++) &#123; int space_times = pow(2,n) - nums; for (int k = 0; k &lt; space_times; k++) cout &lt;&lt; " "; for (int j = 1; j &lt;= nums; j++) &#123; yhsj[i][j] %= 2; &#125; for (int j = 1; j &lt;= nums; j++) &#123; if (yhsj[i][j] == 1) &#123; if (yhsj[i][j + 1] == 1) &#123; cout &lt;&lt; "/__\\"; j++; &#125; else &#123; cout &lt;&lt; "/\\"; &#125; &#125; else if (yhsj[i][j] == 0) cout &lt;&lt; " "; &#125; nums++; cout &lt;&lt; endl; &#125; return 0;&#125; bug修改因为杨辉三角在递推的过程中值不断增大，但是我们只是对他们的值进行取模，如果一开始生成第一行数就进行取模，那么后面的数也就是不会能大了 123456789for (int i = 2; i &lt;= pow(2, n); i++) &#123; for (int j = 1; j &lt;= pow(2, n); j++) &#123; yhsj[i][j] = yhsj[i-1][j-1] + yhsj[i-1][j]; //因为这样递加下去，难免超过Long long,但是可以发现在这里进行取模，对后面生成的数没有任何影响， // 因为取模后值还是没有变化的 yhsj[i][j] %= 2; &#125; &#125; AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// P1498 南蛮图腾.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include "pch.h"#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;long long yhsj[1050][1050]; //注意长度要大于2的10次方 需要注意的问题就是可能存不下=v=int main()&#123; int n; cin &gt;&gt; n; yhsj[1][1] = 1; for (int i = 2; i &lt;= pow(2, n); i++) &#123; for (int j = 1; j &lt;= pow(2, n); j++) &#123; yhsj[i][j] = yhsj[i-1][j-1] + yhsj[i-1][j]; //因为这样递加下去，难免超过Long long,但是可以发现在这里进行取模，对后面生成的数没有任何影响， // 因为取模后值还是没有变化的 yhsj[i][j] %= 2; &#125; &#125; //cout &lt;&lt; yhsj[1024][505] &lt;&lt; endl; //system("pause"); int nums = 1; for (int i = 1; i &lt;= pow(2,n); i++) &#123; int space_times = pow(2,n) - nums; for (int k = 0; k &lt; space_times; k++) cout &lt;&lt; " "; // for (int j = 1; j &lt;= nums; j++) // &#123; // yhsj[i][j] %= 2; // &#125; for (int j = 1; j &lt;= nums; j++) &#123; if (yhsj[i][j] == 1) &#123; if (yhsj[i][j + 1] == 1) &#123; cout &lt;&lt; "/__\\"; j++; &#125; else &#123; cout &lt;&lt; "/\\"; &#125; &#125; else if (yhsj[i][j] == 0) cout &lt;&lt; " "; &#125; nums++; cout &lt;&lt; endl; &#125; return 0;&#125; 总结 需要注意值的最大范围 此外，这些输入题通常是找规律而言，倘若知道规律，那么对解题有很大的帮助 脑子依旧是个好东西，我还没有=v=]]></content>
      <categories>
        <category>OJ</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>杨辉三角</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序--逆序对]]></title>
    <url>%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[归并排序将两个或两个以上的有序表合并成一个有序表的过程 时间复杂度：O(nlog2n) 空间复杂度：需要一个辅助数组空间，复杂度为O(n) 题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 Update:数据已加强。 输入格式第一行，一个数n，表示序列中有n个数。 第二行n个数，表示给定的序列。序列中每个数字不超过10910^9109 输出格式给定序列中逆序对的数目。 输入输出样例输入 #1 1265 4 2 6 3 1 输出 #1 111 说明/提示对于25%的数据，n≤2500n \leq 2500n≤2500 对于50%的数据，n≤4×104n \leq 4 \times 10^4n≤4×104。 对于所有数据，n≤5×105n \leq 5 \times 10^5n≤5×105 请使用较快的输入输出 应该不会n方过50万吧 by chen_zhe 思路：暴力比较肯定会超时，需要进行n!次比较，可以使用归并排序，唯一需要处理的就是在归并比较判断大小排序时，可以对res（表示逆序对的个数）进行更新，例如：[5 4 ] [8 3 2 1]，因为每一个区间都是一个有序表，所以将这两个区间进行归并的时候，比较，如果5大于3后，那么5肯定也大小第二个区间后面的所有的数，所有这时候就可以进行更新res的值。、 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// P1908 逆序对.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include "pch.h"#include &lt;iostream&gt;using namespace std;int arr[500008];int temp[500008];long long n;int res = 0;void merge(int low,int high, int mid)&#123; int i = low; int j = mid+1; int k = low; while (i &lt;= mid &amp;&amp; j&lt;=high) &#123; if (arr[i] &gt; arr[j]) &#123; temp[k++] = arr[i++]; res += high - j+1; //加上剩下的个数 &#125; else temp[k++] = arr[j++]; &#125; while (i &lt;= mid) temp[k++] = arr[i++]; while (j &lt;= high) temp[k++] = arr[j++]; for (int i = low; i &lt;= high; i++) //更新arr数组 arr[i] = temp[i];&#125;void f(int low, int high)&#123; if (low &lt; high) &#123; int mid = (low + high) / 2; f(low, mid); f(mid + 1, high); merge(low, high, mid); &#125;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; arr[i]; f(1, n); cout &lt;&lt; res &lt;&lt; endl; &#125; 总结 认识到了如何用递归实现归并排序，且要注意，归并好两个区间的值后，要更新原来的数组，注意！！！ 待完成：用迭代实现归并排序]]></content>
      <categories>
        <category>OJ</category>
        <category>洛谷</category>
        <category>算法</category>
        <category>排序算法</category>
        <category>归并排序</category>
      </categories>
      <tags>
        <tag>归并</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NFS网络文件系统]]></title>
    <url>%2FNFS%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[NFS网络文件系统–文件共享–目录 配置NFS服务 安装软软件包 yum -y install nfs-utils 配置文件 vim /etc/exports 格式： 共享目录 客户端列表（选项） /nfs *(rw) 123[root@chenxiaojian chenxiaojian]# vim /etc/exports[root@chenxiaojian chenxiaojian]# cat /etc/exports/nfs *(rw) 创建共享目录 mkdir /nfs 重载配置文件 exportfs -rv 启动nfs服务 systemctl enable nfs 设置开机启动 systemctl start nfs systemctl status nfs 防火墙 firewall-cmd –add-service=nfs –permanent 查看是否成功： ip addr 查看ip地址 123t@chenxiaojian /]# showmount -e 192.168.18.131Export list for 192.168.18.131:/nfs * 客户端挂载 （vim /etc/fstab） 192.168.18.131:/nfs /mnt/nfs nfs defaults 0 0 查看信息 mount命令 12192.168.18.131:/nfs on /mnt/nfs type nfs4 (rw,relatime,vers=4.1,rsize=262144,wsize=262144,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.18.131,local_lock=none,addr=192.168.18.131)[root@chenxiaojian nfs]# 例如：hard表示就是请求nfs服务时，会等到响应才结束，可以设置soft （已解决） 123456789101112131415[root@chenxiaojian nfs]# cat /etc/fstab## /etc/fstab# Created by anaconda on Sun Sep 15 21:47:41 2019## Accessible filesystems, by reference, are maintained under '/dev/disk'# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#/dev/mapper/centos_chenxiaojian-root / xfs defaults 0 0UUID=cad510ce-5467-4544-89aa-efd687b4ac39 /boot xfs defaults 0 0/dev/mapper/cetos_chenxiaojian-swap swap swap defaults 0 0192.168.18.131:/nfs /mnt/nfs nfs rw,soft defaults 0 0# 对文件系统挂载表进行配置就可以了...# 此外，修改完成后，有些需要重启才能看得到效果 (注意加逗号，配置soft软挂载) 自动挂载 AutoFS自动挂载 通过脚本实现 优点：节省资源 样例1：通过AutoFS挂载本地镜像 安装软件包 yum -y install autofs 修改配置文件 vim /etc/auto.master 主配置文件 格式：挂载点父目录 辅助配置文件 首先要明白挂什么，然后挂在哪里，例如我们本次例子中，挂的是本地镜像，所以我们要挂的是/dev/sr0，然后我们打算挂在/mnt/autofs/sr0这个目录下 所以格式为：/mnt/autofs /etc/auto.sr0 然后创建/etc/auto/sr0文件并去编辑他（可以参考 cat /etc/auto.misc） 格式：挂载点的相对路径（相对于父目录） 选项 挂载设备 例子： sr0 -fstype=iso9660（表示文件的类型）:/dev/sr0 （冒号表示的是本地文件） vim /etc/auto.sr0 1sr0 -fstype=iso9660 :/dev/sr0 启动服务 systemctl enable autofs systemctl restart autofs 验证查看 首先我们先将之前挂载点卸载 umount /dev/sr0，然后你通过df-Th是查看不到本地镜像的挂载情况，但是当你去访问之前挂载点的目录时，就会自动挂载了cd /mnt/auto.sr0，然后在执行df-Th就会查看到这个光碟的挂载情况了，如果没有使用，他就会自动将它卸载了。 样例2：通过AutoFS挂载NFS 同样的操作，只不过要注意挂载点的父目录不要一样，因为挂载点的父目录会被锁定 样例3：通过AutoFS挂载LDAP用户的主目录]]></content>
      <categories>
        <category>Linux</category>
        <category>NFS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux软件包管理]]></title>
    <url>%2FLinux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[软件包管理 rpm是一个中软件包管理，同时一种软件包格式 RPM包管理器RPM的软件包查询 rpm -qa 查询已经安装的软件名称 rpm -q &lt;软件包&gt; 查询软件是否安装，安装过则输出该软件包的信息 1234567[chenxiaojian@chenxiaojian ~]$ rpm -q ssh未安装软件包 ssh [chenxiaojian@chenxiaojian ~]$ rpm -q sshd未安装软件包 sshd [chenxiaojian@chenxiaojian ~]$ rpm -q pythonpython-2.7.5-76.el7.x86_64[chenxiaojian@chenxiaojian ~]$ RPM的软件包的下载 yum -ivh &lt;软件包&gt; i：表示安装 v：表示更详细的安装信息页面 h：表示显示安装进度 例如;从镜像网站下载一个rpm包 可以先使用wget命令下载，wget -O （表示下下载到指定的目录，如果没有-O，则是下载到当前目录） yum软件包管理 相关命令：Linux uname命令用于显示系统信息，uname可显示电脑以及操作系统的相关信息 12chenxiaojian@ohenxiaojian:~$ uname -aLinux ohenxiaojian 5.0.0-27-generic #28~18.04.1-Ubuntu SMP Thu Aug 22 03:00:32 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 软件的类型 源码包 需要编译 二进制包 已编译 在ubantu系统上，在线包管理工具是apt,而在红帽中则为yum（在线工具）管理 使用yum管理RPM包安装 yum -y install &lt;包名&gt; yum -y reinstall &lt;包名&gt; yum -y update &lt;包名&gt; yum -y update 更新所有包 卸载 yum remove &lt;包名&gt; 查询 yum list &lt;包名&gt; yum info &lt;包名&gt; 可以查询包的信息（无论是否安装过） yum history info 2 、yum history 撤销yum history的动作，yum history undo yum search &lt;包名&gt; 搜索软件包 yum provides &lt;文件&gt; 查询命令提供的软件包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081root@chenxiaojian yum.repos.d]# yum history 已加载插件：fastestmirror, langpacksID | 登录用户 | 日期和时间 | 操作 | 变更数 ------------------------------------------------------------------------------- 2 | &lt;chenxiaojian&gt; | 2019-09-16 22:29 | Install | 3 1 | 系统 &lt;空&gt; | 2019-09-15 21:48 | Install | 1527 history list[root@chenxiaojian yum.repos.d]# yum history info 2已加载插件：fastestmirror, langpacks事务 ID： 2起始时间 ： Mon Sep 16 22:29:52 2019启动 RPM 数据库 ： 1527:8b2dcf21844ade1205674f58ecb3b0f2be946f78结束时间 ： 22:29:54 2019 （2 秒）结束 RPM 数据库 ： 1530:34cb8a59af417b144b21b6f139a91d27f8216274用户 ： chenxiaojian &lt;chenxiaojian&gt;返回码 ： 成功命令行 ： install httpd事务完成属主： 已安装 rpm-4.11.3-35.el7.x86_64 @anaconda 已安装 yum-3.4.3-161.el7.centos.noarch @anaconda 已安装 yum-plugin-fastestmirror-1.1.31-50.el7.noarch @anaconda已变更的包： 安装 httpd-2.4.6-89.el7.centos.1.x86_64 @updates 依赖安装 httpd-tools-2.4.6-89.el7.centos.1.x86_64 @updates 依赖安装 mailcap-2.1.41-2.el7.noarch @basehistory info[root@chenxiaojian yum.repos.d]# yum history undo 2已加载插件：fastestmirror, langpacksUndoing transaction 2, from Mon Sep 16 22:29:52 2019 安装 httpd-2.4.6-89.el7.centos.1.x86_64 @updates 依赖安装 httpd-tools-2.4.6-89.el7.centos.1.x86_64 @updates 依赖安装 mailcap-2.1.41-2.el7.noarch @base正在解决依赖关系--&gt; 正在检查事务---&gt; 软件包 httpd.x86_64.0.2.4.6-89.el7.centos.1 将被 删除---&gt; 软件包 httpd-tools.x86_64.0.2.4.6-89.el7.centos.1 将被 删除---&gt; 软件包 mailcap.noarch.0.2.1.41-2.el7 将被 删除--&gt; 解决依赖关系完成依赖关系解决===================================================================================== Package 架构 版本 源 大小=====================================================================================正在删除: httpd x86_64 2.4.6-89.el7.centos.1 @updates 9.4 M httpd-tools x86_64 2.4.6-89.el7.centos.1 @updates 169 k mailcap noarch 2.1.41-2.el7 @base 62 k事务概要=====================================================================================移除 3 软件包安装大小：9.6 M是否继续？[y/N]：yDownloading packages:Running transaction checkRunning transaction testTransaction test succeededRunning transaction 正在删除 : httpd-2.4.6-89.el7.centos.1.x86_64 1/3 正在删除 : mailcap-2.1.41-2.el7.noarch 2/3 正在删除 : httpd-tools-2.4.6-89.el7.centos.1.x86_64 3/3 验证中 : httpd-2.4.6-89.el7.centos.1.x86_64 1/3 验证中 : mailcap-2.1.41-2.el7.noarch 2/3 验证中 : httpd-tools-2.4.6-89.el7.centos.1.x86_64 3/3 删除: httpd.x86_64 0:2.4.6-89.el7.centos.1 httpd-tools.x86_64 0:2.4.6-89.el7.centos.1 mailcap.noarch 0:2.1.41-2.el7 完毕！[root@chenxiaojian yum.repos.d]# yum list httpd已加载插件：fastestmirror, langpacksLoading mirror speeds from cached hostfile * base: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com可安装的软件包httpd.x86_64 2.4.6-89.el7.centos.1 updates[root@chenxiaojian yum.repos.d]# 将源换成阿里云的源 https://opsx.alibaba.com/mirror?lang=zh-CN 查看不同的源的配置文件/etc/yum.repos.d/.. 安装epel扩展源https://opsx.alibaba.com/mirror 这样做，就可以安装类似于nginx的包 12345678910[root@chenxiaojian ~]# [root@chenxiaojian ~]# yum list nginx已加载插件：fastestmirror, langpacksLoading mirror speeds from cached hostfile * base: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com可安装的软件包nginx.x86_64 1:1.12.2-3.el7 epel[root@chenxiaojian ~]# 软件包管理相关命令 uname 12345678910111213141516171819202122232425[chenxiaojian@chenxiaojian ~]$ uname -mx86_64[chenxiaojian@chenxiaojian ~]$ uname Linux[chenxiaojian@chenxiaojian ~]$ uname --help用法：uname [选项]...输出一组系统信息。如果不跟随选项，则视为只附加-s 选项。 -a, --all 以如下次序输出所有信息。其中若-p 和 -i 的探测结果不可知则被省略： -s, --kernel-name 输出内核名称 -n, --nodename 输出网络节点上的主机名 -r, --kernel-release 输出内核发行号 -v, --kernel-version 输出内核版本 -m, --machine 输出主机的硬件架构名称 -p, --processor 输出处理器类型或"unknown" -i, --hardware-platform 输出硬件平台或"unknown" -o, --operating-system 输出操作系统名称 --help 显示此帮助信息并退出 --version 显示版本信息并退出GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;请向&lt;http://translationproject.org/team/zh_CN.html&gt; 报告uname 的翻译错误要获取完整文档，请运行：info coreutils 'uname invocation'[chenxiaojian@chenxiaojian ~]$ 12[chenxiaojian@chenxiaojian etc]$ cat /etc/redhat-releaseCentOS Linux release 7.6.1810 (Core) 123456789101112[chenxiaojian@chenxiaojian etc]$ yum repolist已加载插件：fastestmirror, langpacksDetermining fastest mirrors * base: ftp.sjtu.edu.cn * extras: mirrors.163.com * updates: mirrors.cn99.com源标识 源名称 状态!base/7/x86_64 CentOS-7 - Base 10,019!extras/7/x86_64 CentOS-7 - Extras 435!updates/7/x86_64 CentOS-7 - Updates 2,500repolist: 12,954# 默认的三个国外源 firewalld 防火墙服务systemctl status firewalld 查看防火墙守护进程 命令行方式操作防火墙 firewall-cmd 图形化界面操作操作防火墙 firewall-config 1234567891011121314151617[root@chenxiaojian chenxiaojian]# firewall-cmd --add-service=http --permanent Warning: ALREADY_ENABLED: httpsuccess[root@chenxiaojian chenxiaojian]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 sources: services: ssh dhcpv6-client http ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: 配置文件 /etc/firewalld/ 当前配置 12345678910111213141516171819[root@chenxiaojian etc]# cd firewalld[root@chenxiaojian firewalld]# ll总用量 8-rw-r--r--. 1 root root 2006 10月 31 2018 firewalld.confdrwxr-x---. 2 root root 6 10月 31 2018 helpersdrwxr-x---. 2 root root 6 10月 31 2018 icmptypesdrwxr-x---. 2 root root 6 10月 31 2018 ipsets-rw-r--r--. 1 root root 271 10月 31 2018 lockdown-whitelist.xmldrwxr-x---. 2 root root 6 10月 31 2018 servicesdrwxr-x---. 2 root root 46 9月 15 21:59 zones[root@chenxiaojian firewalld]# cat lockdown-whitelist.xml &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;whitelist&gt; &lt;command name="/usr/bin/python -Es /usr/bin/firewall-config"/&gt; &lt;selinux context="system_u:system_r:NetworkManager_t:s0"/&gt; &lt;selinux context="system_u:system_r:virtd_t:s0-s0:c0.c1023"/&gt; &lt;user id="0"/&gt;&lt;/whitelist&gt;[root@chenxiaojian firewalld]# SELinux基础SELinux可以给文件，目录，端口，进程打上标签，标签称为上下文 不同的标签就不能访问各自的上下文 httpd服务的进程上下文：httpd_t httpd服务的文件上下文：httpd_sys_content_t httpd服务的进程上下文：http_port_t 模式 enforcing （强制模式）启动SELinux，禁用违反策略的行为，并发送警告 permissive（允许模式）启用SELinux，不禁用违反策略的行为 disabled（禁用模式） 临时更改：setenforce 1 | 0 永久更改：/etc/selinux/config 12345678910111213[root@chenxiaojian /]# cat /etc/selinux/config # This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=enforcing# SELINUXTYPE= can take one of three values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.SELINUXTYPE=targeted 文件上下文查看文件上下文 ls -Z[d] 查看目录或文件的上下文 -Z 表示查看上下文，d表示查看文件，目录本身 12[root@chenxiaojian chenxiaojian]# semanage fcontext -l#查看所有文件的上下文 配置管道命令 | grep 添加文件上下文 semanage fcontext -a -t &lt;上下文&gt; &lt;目录文件&gt; a表示添加，-t表示上下文类型 restorecon -RFvv &lt;目录文件&gt; vv表示查看过程 修改文件上下文 semanage fcontext -m -t &lt;上下文&gt; &lt;目录文件&gt; m表示修改，-t表示上下文类型 restorecon -RFvv &lt;目录文件&gt; vv表示查看过程 临时修改上下文：chcon -t &lt;上下文类型&gt; &lt;文件目录&gt;，内核安全上下文列表（semanage fcontent -l）经过刷新后（restorecon -RFvv &lt; 文件&gt;）就会恢复之前的上下文 命令： chcon -t &lt;上下文类型&gt; &lt;文件、目录&gt; 临时修改 semanage fcontent -a -t &lt;上下文类型&gt; &lt;文件、目录&gt; 添加默认上下文 semanage fcontent -m -t &lt;上下文类型&gt; &lt;文件、目录&gt; 修改默认上下文 restorecon -RFvv &lt;文件。目录&gt; 当这个文件在策略里有定义是，可以恢复原来的 文件标签。 样例：123456789101112[root@chenxiaojian chenxiaojian]# mkdir dir3[root@chenxiaojian chenxiaojian]# ls1.sh dir1 dir3 test_file.txt 模板 图片 下载 桌面Anaconda3-2018.12-Linux-x86_64.sh dir2 fstab 公共 视频 文档 音乐[root@chenxiaojian chenxiaojian]# ls -Zd dir3drwxr-xr-x. root root unconfined_u:object_r:user_home_t:s0 dir3[root@chenxiaojian chenxiaojian]# semanage fcontext -a -t httpd_sys_content_t /home/chenxiaojian/dir3[root@chenxiaojian chenxiaojian]# restorecon -Rv dir3restorecon reset /home/chenxiaojian/dir3 context unconfined_u:object_r:user_home_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0[root@chenxiaojian chenxiaojian]# ls -Zd dir3drwxr-xr-x. root root unconfined_u:object_r:httpd_sys_content_t:s0 dir3[root@chenxiaojian chenxiaojian]# 总结： 文件或者目录要写成绝对路径，记得查看文件安全上下文列表，restorecon 就是重新加载这个列表 此外，要就注意移动文件和复制文件对于上下文的不同影响 1234567891011121314[root@chenxiaojian chenxiaojian]# echo hello &gt; file1[root@chenxiaojian chenxiaojian]# echo hello &gt; file2[root@chenxiaojian chenxiaojian]# ls -Z | grep file-rw-r--r--. root root unconfined_u:object_r:user_home_t:s0 file1-rw-r--r--. root root unconfined_u:object_r:user_home_t:s0 file2-rw-rw-r--. chenxiaojian chenxiaojian unconfined_u:object_r:user_home_t:s0 test_file.txt[root@chenxiaojian chenxiaojian]# cp file1 /var/www/html/[root@chenxiaojian chenxiaojian]# mv file2 /var/www/html/[root@chenxiaojian chenxiaojian]# ls -Z /var/www/html/ | grep file-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file1-rw-r--r--. root root unconfined_u:object_r:user_home_t:s0 file2 端口上下文查看123456[root@chenxiaojian chenxiaojian]# semanage port -l | grep httphttp_cache_port_t tcp 8080, 8118, 8123, 10001-10010http_cache_port_t udp 3130http_port_t tcp 80, 81, 443, 488, 8008, 8009, 8443, 9000pegasus_http_port_t tcp 5988pegasus_https_port_t tcp 5989 添加端口上下文 semanage port -a -t &lt;上下文&gt; -p &lt;tcp | udp&gt; &lt;端口&gt; 例如：semanage port -a -t httpd_port_t -p tcp 10000 删除端口上下文 semanage port -d -t &lt;上下文&gt; -p &lt;tcp | udp&gt; &lt;端口&gt; 例如：semanage port -d -t httpd_port_t -p tcp 10000 修改端口上下文 semanage port -m -t &lt;上下文&gt; -p &lt;tcp | udp&gt; &lt;端口&gt; 例如：semanage port -m -t httpd_port_t -p tcp 10000 布尔值 布尔值是selinux的策略开关 查看布尔值 getsebool -a 修改布尔值 setsebool -P （P表示永久修改） 例如：setsebool -P nfs_export_all_rw off 查看用户修改的布尔值 semanage boolean -l -C 1234567891011[root@chenxiaojian chenxiaojian]# setsebool -P nfs_export_all_rw off[root@chenxiaojian chenxiaojian]# semanage boolean -l -CSELinux 布尔值 状态 默认 描述nfs_export_all_rw (关 , 关) Allow nfs to export all rw[root@chenxiaojian chenxiaojian]# setsebool -P nfs_export_all_rw on[root@chenxiaojian chenxiaojian]# semanage boolean -l -CSELinux 布尔值 状态 默认 描述nfs_export_all_rw (开 , 开) Allow nfs to export all rw[root@chenxiaojian chenxiaojian]# LDAP用户集中管理，可以理解为将所有用户的信息存放在一个特定的服务器中，然后用户的信息存放在不同的目录下，这样我们可以在本机连接LDAP服务器，就可以共享该用户的信息 连接LDAP服务器 安装软件包 yum -y install authconfig-gtk sssd 执行authconfig-gtk 选择LDAP认证 输入域名 dc=xxx,dc=xxx 输入LDAP服务器的ip地址或主机名 √ TLS，下载证书 选择LDAP password 连接成功后，可以查看服务器内的用户数据 查看用户 id &lt;用户&gt; （该用户不是本地创建的，cat/etc/passwd查看）]]></content>
      <categories>
        <category>Linux</category>
        <category>软件包管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[putty连接ubantu]]></title>
    <url>%2Fputty%E8%BF%9E%E6%8E%A5ubantu%2F</url>
    <content type="text"><![CDATA[首先查看ssh的服务 123root@chenxiaojian:~# ps -e | grep ssh 5391 ? 00:00:00 ssh-agent 16936 ? 00:00:00 sshd ssh程序分为有客户端程序openssh-client和服务端程序openssh-server 如果需要ssh登陆到别的电脑，需要安装openssh-client，该程序Ubuntu是默认安装的。而如果需要从远程连接到本机，则需要安装openssh-server 安装openssh-server1sudo apt-get install openssh-server 查看是否安装成功 1ps -e | grep ssh 启动、停止和重启openssh-server 123/etc/init.d/ssh start/etc/init.d/ssh stop/etc/init.d/ssh restart 查看ip地址：apt install net-tools1ipconfig Ubuntu中SSH服务安装完成后查看是否允许root用户登陆，若不允许则无法远程登陆root用户，需要修改配置 首先，打开“/etc/ssh/sshd_config” 查看是否有“PermitRootLogin yes”，没有添加即可，完成后保存退出 然后需要重新载入这文件，不然用putty连接用root登录会超时，无法成功 1systemctl reload ssh 注意问题主机和虚拟机中ubantu的网段要一致 1234567891011121314151617C:\Users\陈小坚&gt;ipconfigWindows IP 配置无线局域网适配器 本地连接* 1: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . :以太网适配器 VMware Network Adapter VMnet1: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::dd9:6adc:aff4:2a8d%12 IPv4 地址 . . . . . . . . . . . . : 192.168.235.1 #ip地址 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : 123456789101112131415161718root@chenxiaojian:~# ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.18.129 netmask 255.255.255.0 broadcast 192.168.18.255 inet6 fe80::db1b:b0e6:2904:f468 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:52:d5:63 txqueuelen 1000 (以太网) RX packets 15579 bytes 17077036 (17.0 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 4466 bytes 360668 (360.6 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (本地环回) RX packets 556 bytes 48721 (48.7 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 556 bytes 48721 (48.7 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0]]></content>
      <categories>
        <category>Linux</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux--Systemctl]]></title>
    <url>%2FLinux-Systemctl%2F</url>
    <content type="text"><![CDATA[SystemCtl 一个程序有一个或多个进程 SystemCtl可以管理服务 服务就是守护进程（sshd, httpd） systemctl -t sevice (查看服务) systemctl start ssh systemctl stop ssh systemctl restart ssh systemctl reload ssh systemctl enable ssh systemctl disable ssh RHEL7网络 ip地址，掩码，网关，DNS，主机名 IPV4 192.168.1.1 点分十进制 32位 ip address 查看Ip信息 ip route 查看路由信息 ip -s link 查看接口统计信息 设置 图形化 nmtui，设置完成后记得重新启动网络，systemctl restart network 命令行 nmcli con mod help 查看帮助 nmcli con mod （不同的linux版本可能不同） nmcli con add nmcli con del nmcli con show 修改文件 不同版本的linux系统，网络配置文件可能不容 REHE的配置文件为：/etc/sysconfig/network-scripts/ifcfg DNS（域名系统） 提供ip地址和域名的映射关系 主机名 hostname查看 12345678910root@chenxiaojian:/etc/network# hostnamectl Static hostname: chenxiaojian Icon name: computer-vm Chassis: vm Machine ID: f71657539bed41b18d278ff8d76a60f7 Boot ID: 1c3e9e525f2348aa8412bed75c6a79bf Virtualization: vmware Operating System: Ubuntu 18.04.3 LTS Kernel: Linux 5.0.0-27-generic Architecture: x86-64 1234567root@chenxiaojian:/etc/network# hostnamectl set-hostname chenchenxiaojianroot@chenxiaojian:/etc/network#root@chenxiaojian:/etc/network# hostnamechenchenxiaojianroot@chenxiaojian:/etc/network# hostnamectl set-hostname chenxiaojianroot@chenxiaojian:/etc/network# hostnamechenxiaojian 12root@chenxiaojian:/etc/network# vim /etc/hostname# 修改hostname文件]]></content>
      <categories>
        <category>Linux</category>
        <category>Systemctl</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷P1118】数字三角形]]></title>
    <url>%2F%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题目描述FJ and his cows enjoy playing a mental game. They write down the numbers from 111 toN(1≤N≤10) N(1 \le N \le 10)N(1≤N≤10) in a certain order and then sum adjacent numbers to produce a new list with one fewer number. They repeat this until only a single number is left. For example, one instance of the game (when N=4N=4N=4) might go like this: 12343 1 2 4 4 3 6 7 9 16 Behind FJ‘s back, the cows have started playing a more difficult game, in which they try to determine the starting sequence from only the final total and the number NNN. Unfortunately, the game is a bit above FJ‘s mental arithmetic capabilities. Write a program to help FJ play the game and keep up with the cows. 有这么一个游戏： 写出一个111至NNN的排列aia_iai，然后每次将相邻两个数相加，构成新的序列，再对新序列进行这样的操作，显然每次构成的序列都比上一次的序列长度少111，直到只剩下一个数字位置。下面是一个例子： 3,1,2,43,1,2,43,1,2,4 4,3,64,3,64,3,6 7,97,97,9 161616 最后得到161616这样一个数字。 现在想要倒着玩这样一个游戏，如果知道NNN，知道最后得到的数字的大小sumsumsum，请你求出最初序列aia_iai，为111至NNN的一个排列。若答案有多种可能，则输出字典序最小的那一个。 [color=red]管理员注：本题描述有误，这里字典序指的是1,2,3,4,5,6,7,8,9,10,11,121,2,3,4,5,6,7,8,9,10,11,121,2,3,4,5,6,7,8,9,10,11,12 而不是1,10,11,12,2,3,4,5,6,7,8,91,10,11,12,2,3,4,5,6,7,8,91,10,11,12,2,3,4,5,6,7,8,9[/color] 输入格式两个正整数n,sumn,sumn,sum。 输出格式输出包括111行，为字典序最小的那个答案。 当无解的时候，请什么也不输出。（好奇葩啊） 输入输出样例输入 #1 14 16 输出 #1 13 1 2 4 说明/提示对于40%40%40%的数据，n≤7n≤7n≤7； 对于80%80%80%的数据，n≤10n≤10n≤10； 对于100%100%100%的数据，n≤12,sum≤12345n≤12,sum≤12345n≤12,sum≤12345。 思路：首先对n个数的最终值进行模拟可以发现一个规律，如图所示 因此，我们可以用一个二维数组保存杨辉三角的值—yhsj[i][j] 表示第i行第j个数字 ​ yhsj[i][j] = yhsj[i-1][j] + yhsj[i-1][j-1] 也就是说我们可以知道sum有n项组成。每一项的系数我们也都知道了，接下来对每一项进行枚举就行了 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdlib.h&gt;#include &lt;iostream&gt;using namespace std;int n;int sum;int yhsj[13][13]; //存放杨辉三角 全局变量默认为0int res[13];int vis[13];void dfs(int step, int temp_sum)&#123; if (temp_sum &gt; sum) return; if (step == n+1) &#123; if (temp_sum != sum) return; else &#123; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; res[i] &lt;&lt; " "; cout &lt;&lt; endl; exit(0); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (vis[i] == 0) &#123; vis[i] = 1; res[step] = i; dfs(step + 1, i*yhsj[n][step]+temp_sum); vis[i] = 0; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt;sum; yhsj[1][1] = 1; for (int i = 2; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) yhsj[i][j] = yhsj[i-1][j] + yhsj[i-1][j-1]; //生成杨辉三角 dfs(1, 0);&#125; 总结 脑子是个好东西，可惜我还在还没有=V= 此外，需要掌握杨辉三角的生成代码]]></content>
      <categories>
        <category>OJ</category>
        <category>洛谷</category>
        <category>算法</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>暴力枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户和组]]></title>
    <url>%2F%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%2F</url>
    <content type="text"><![CDATA[用户和组 linux是多用户系统 文件和目录是属于一个用户，进程是以一个用户的身份运行（查看进程的命令 ps aux） 用户可以加入一个或多个组，但是只有一个主要组，可以有多个附属组 /etc/passwd 保存用户信息 cat 查看文件 root​ : x:0:0:root:/root:/bin/bash root：用户名称 x: 密码，以前存放密码的位置 0：UID,标识用户 0固定分配给root；1-999分配给系统用户；1000及以上分配普通用户 0：GID，标识用户组 root：填充字段 /root：用户的主目录 /bin/bash :用户使用的登录shell /etc/group保存用户组信息 root​ ​：x:0: root: 用户组名称 x：密码，以前存放密码的位置 0：GID，标识用户组 : 用户列表 id +用户 12chenxiaojian@chenxiaojian:~$ id chenxiaojianuid=1000(chenxiaojian) gid=1000(chenxiaojian) 组=1000(chenxiaojian),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare) /etc/shadow保存用户密码 管理用户 (nologin –不可登录的shell) useradd 添加用户 会自动创建/home 目录和邮箱目录 用法：useradd [选项] &lt;用户&gt; -d 指定用户的主目录 -u 指定用户的UID -g 指定主要组 -G 指定附属组 -s 指定用户登录的shell 1234567root@chenxiaojian:~# useradd user1root@chenxiaojian:~# id user1uid=1001(user1) gid=1001(user1) 组=1001(user1)root@chenxiaojian:~# tail -1 /etc/passwd (查看文件的最后一行)user1:x:1001:1001::/home/user1:/bin/sh# 可以看出user1用户的主目录是/home/user1 (默认的) 1234567891011121314151617181920212223242526272829303132333435363738394041 #指定用户的主目录 root@chenxiaojian:/# useradd -d /test user2 root@chenxiaojian:/# id user2 uid=1002(user2) gid=1002(user2) 组=1002(user2) root@chenxiaojian:/# tail -1 /etc/passwduser2:x:1002:1002::/test:/bin/sh #指定用户的UID root@chenxiaojian:/# useradd -u 1500 user3 root@chenxiaojian:/# id user3 uid=1500(user3) gid=1500(user3) 组=1500(user3) root@chenxiaojian:/# tail -1 /etc/passwduser3:x:1500:1500::/home/user3:/bin/sh #指定用户的主要组 root@chenxiaojian:/# useradd -g chenxiaojian user4 root@chenxiaojian:/# id user4 uid=1501(user4) gid=1000(chenxiaojian) 组=1000(chenxiaojian) root@chenxiaojian:/# tail -1 /etc/passwduser4:x:1501:1000::/home/user4:/bin/sh #指定用户的附属组 root@chenxiaojian:/# useradd -G user1,user2,user3 user5 root@chenxiaojian:/# id user5 uid=1502(user5) gid=1502(user5) 组=1502(user5),1001(user1),1002(user2),1500(user3) root@chenxiaojian:/# tail /etc/group avahi:x:122: colord:x:123: geoclue:x:124: gdm:x:125: chenxiaojian:x:1000: sambashare:x:126:chenxiaojian user1:x:1001:user5 #（这里表示user5是user1的用户） user2:x:1002:user5 user3:x:1500:user5user5:x:1502: #指定用户登录的shell root@chenxiaojian:/# useradd -s /sbin/nologin webuser root@chenxiaojian:/# tail -1 /etc/passwd webuser:x:1503:1503::/home/webuser:/sbin/nologin usermod 修改用户 -g 修改用户的主要组 不建议使用这个，创建用户不指定这个，会自动创一个和本用户相同名字的组作为主要组 -a 添加附属组，与-G 配合使用 （如果只是usermod -G 修改附属组，那么会覆盖掉当前的组）-a表示追加的 12345root@chenxiaojian:/# id user2uid=1002(user2) gid=1002(user2) 组=1002(user2)root@chenxiaojian:/# usermod -aG user1 user2root@chenxiaojian:/# id user2uid=1002(user2) gid=1002(user2) 组=1002(user2),1001(user1) -m移动主目录，与-d配合使用 1234567891011121314root@chenxiaojian:/home# tail -5 /etc/passwduser2:x:1002:1002::/test:/bin/shuser3:x:1500:1500::/home/user3:/bin/shuser4:x:1501:1000::/home/user4:/bin/shuser5:x:1502:1502::/home/user5:/bin/shwebuser:x:1503:1503::/home/webuser:/sbin/nologinroot@chenxiaojian:/home# usermod -md /home/user2 user2root@chenxiaojian:/home# tail -5 /etc/passwduser2:x:1002:1002::/home/user2:/bin/shuser3:x:1500:1500::/home/user3:/bin/shuser4:x:1501:1000::/home/user4:/bin/shuser5:x:1502:1502::/home/user5:/bin/shwebuser:x:1503:1503::/home/webuser:/sbin/nologin userdel 删除用户 -r 删除 1root@chenxiaojian:/home# userdel webuser 管理用户组 groupadd 添加用户组 -g 指定GID groupmod groupdel 设置用户密码 passwd &lt;用户&gt; 注：root可以设置所有用户的密码，普通用户只能设置自身的密码、 echo &lt;密码&gt; | passwd –stdin &lt;用户&gt; 切换用户 su &lt;用户名&gt; 1234#修该用户登录的shellroot@chenxiaojian:/home# usermod -s /bin/bash user1root@chenxiaojian:/home# su user1user1@chenxiaojian:/home$ ^C 注意，使用sudo 提升权限的前提是你这个用户的组之中有root组 文件权限 UGO：用户、组、其他 r代表读取 w代表写入 x代表执行 权限 对文件的影响 对目录的影响 r读取 查看文件的内容 查看目录的内容（目录下的文件） w写入 修改文件的内容 创建或删除文件或子目录 x执行 执行文件 访问目录，修改目录下文件的内容（文件本身权限） 修改文件权限 （change + mod）（修改 + 权限） 符号法 （ugoa）–&gt;user,group,other, any(任何) chmod &lt;ugoa&gt;&lt;+-=&gt;&lt;rwx-&gt; chmod u=rw,g=rw,o=rw file1 注意，u=rw,g=rw之间不能有空格 chmod -R ==&gt;递归设置 drwxr-xr-x 其中，u代表文件所有者的权限，也就是第二到第四位（rwx） g代表的文件所属组的权限，也就是第五位到第七位的权限（r-x） o代表的其他用户的权限，也就是第八位到第10位（r-x） 而a则是代表全部。(也可以省略不写) 1234567891011drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-r--r-- 1 chenxiaojian chenxiaojian 0 9月 11 14:13 file1drwxr-xr-x 2 chenxiaojian chenxiaojian 4096 9月 11 14:13 test_dir/chenxiaojian@chenxiaojian:~/test$ chmod g+w file1chenxiaojian@chenxiaojian:~/test$ ll总用量 12drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-rw-r-- 1 chenxiaojian chenxiaojian 0 9月 11 14:13 file1drwxr-xr-x 2 chenxiaojian chenxiaojian 4096 9月 11 14:13 test_dir/ 1234567chenxiaojian@chenxiaojian:~/test$ chmod u=rw,g=rw,o=rw file1chenxiaojian@chenxiaojian:~/test$ ll总用量 12drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-rw-rw- 1 chenxiaojian chenxiaojian 0 9月 11 14:13 file1drwxr-xr-x 2 chenxiaojian chenxiaojian 4096 9月 11 14:13 test_dir/ 数值法 chmod NNN &lt;文件&gt; r = 4, w = 2 ,x = 1, -= 0 chmod 640 file1 就是设置file1的所有者的权限为r + w = 6 所属组的权限为r = 4 其他用户没有权限 0 = - 修改文件的所有者和所属组 注意：默认的所有者是创建该文件的用户，所属组是创建该文件的用户的主要组 chown &lt;所有者&gt;:&lt;所属组&gt; &lt;文件&gt; 用法 12345678910111213141516171819202122232425262728293031root@chenxiaojian:/home/chenxiaojian/test# ll总用量 12drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-rw-rw- 1 chenxiaojian chenxiaojian 0 9月 11 14:13 file1drwxrwxrwx 3 chenxiaojian chenxiaojian 4096 9月 11 14:35 test_dir/root@chenxiaojian:/home/chenxiaojian/test# chown root:root file1root@chenxiaojian:/home/chenxiaojian/test# ll总用量 12drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-rw-rw- 1 root root 0 9月 11 14:13 file1drwxrwxrwx 3 chenxiaojian chenxiaojian 4096 9月 11 14:35 test_dir/root@chenxiaojian:/home/chenxiaojian/test# root@chenxiaojian:/home/chenxiaojian/test# root@chenxiaojian:/home/chenxiaojian/test# chown chenxiaojian file1root@chenxiaojian:/home/chenxiaojian/test# ll总用量 12drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-rw-rw- 1 chenxiaojian root 0 9月 11 14:13 file1drwxrwxrwx 3 chenxiaojian chenxiaojian 4096 9月 11 14:35 test_dir/root@chenxiaojian:/home/chenxiaojian/test# root@chenxiaojian:/home/chenxiaojian/test# root@chenxiaojian:/home/chenxiaojian/test# chown :chenxiaojian file1root@chenxiaojian:/home/chenxiaojian/test# ll总用量 12drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-rw-rw- 1 chenxiaojian chenxiaojian 0 9月 11 14:13 file1drwxrwxrwx 3 chenxiaojian chenxiaojian 4096 9月 11 14:35 test_dir/ 文件的特殊权限 权限 对文件的影响 对目录的影响 u+s 4 以文件所有者的身份运行，而不是运行该命令的用户身份运行 无 g+s 2 以文件所属组的身份运行 目录文件或子目录会继承组关系 o+t 1 无 只有root和文件的所有者才能删除这个目录 123# u+s表示在user的权限中有个s,那么例如passwd,这个命令，我们在chenxiaojian的身份下运行，实际上是由该命令的所有者也就是root执行root@chenxiaojian:/home/chenxiaojian/test# ll /usr/bin/passwd-rwsr-xr-x 1 root root 59640 3月 23 03:05 /usr/bin/passwd* 设置特殊权限 符号法 chmod u+s &lt;文件&gt; chmod g+s &lt;文件 | 目录&gt; chmod o+t &lt;目录&gt; 数值法 chmod NNNN &lt;文件/目录&gt; 第一个N就是表示特殊权限 ACL(访问控制列表) UGO权限不能满足精细设置权限的要求 ACL可以针对用户或组设置单独的权限 setfacl -m u:&lt;用户&gt;:&lt;权限&gt; &lt;文件&gt;（其中u代表的就是用户，如果是g,则表示为组） setfacl -x u:&lt;用户&gt; &lt;文件&gt; 删出用户对文件的权限 setfacl -b &lt;文件&gt; 删出所有的设置权限 查看设置文件权限的结果：getfacl &lt;文件&gt; 问题：设用户chenxiaojian对file1没有任何权限，而用户user1对file1有读写的操作 12 chenxiaojian@chenxiaojian:~/test$ setfacl -m u:chenxiaojian:- file1chenxiaojian@chenxiaojian:~/test$ setfacl -m u:user1:rw file1 结果： file: file1 owner: chenxiaojian group: chenxiaojian user::rw-user:chenxiaojian:—user:user1:rw-group::rw-mask::rw-other::rw-]]></content>
      <categories>
        <category>Linux</category>
        <category>用户和组</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVM]]></title>
    <url>%2FLVM%2F</url>
    <content type="text"><![CDATA[逻辑卷管理器LVM MBR磁盘分区方式的局限性 LVM的原理 LVM机制的基本概念 PV –物理卷 默认包括许多大小为4MB的PE块 VG –卷组 一个或多个物理卷组合而成的整体 LV –逻辑卷 从卷组汇总分割出的一块空间，用于建立文件系统 LVM的管理命令 功能 物理卷管理 卷组管理 逻辑卷管理 Scan 扫描 pvscan vgscan lvscan Create 建立 pvcreate vgcreate lvcreate Display 显示 pvdisplay vgdisplay lvdisplay Remove 删除 pvremove vgremove lvremove Exttend 扩展 vgextend lvextend 创建LVM逻辑卷的过程 分区–》pv–》vg–》lv–》格式化–》挂载文件系统 转化物理卷 使用fdisk命令规划两个分区，类型设置为“8e”（也就是说，如果我们新加入两个盘，我们可以在这两个盘上各自新建一个分区，然后再对两个分区进行操作） 如果设置为“8e”， fdisk进入命令，输入“t”改变分区id类型，输入“8e”，代表逻辑卷类型，输入p打印，确认无误输入w保存退出 pvcreate创建物理卷 可以先用pvscan扫描是否有pv物理卷 使用pvcreate命令进行创建 pvcreate /dev/sdc1 pvcreate /dev/sdd1 创建卷组 使用vgcreate命令（可以使用vgscan扫描一遍） vgcreate mail_store /dev/sdc1 /dev/sdd1 mail_store表示的卷组名，后面两个就是刚才新建的分区 创建逻辑卷 使用lvcreate命令创建逻辑卷 例如：mail,分配3G lvcreate -L 3G -n mail mail_store 创建文件系统 mkfs -t ext4 /dev/mail_store/mail 挂载 mount -t ext4 /dev/mail_store/mail /testLvm 挂载到文件夹testLvm df -Th查看 文件系统添加完后会自动添加一个别名 /dev/mapper/mail_store/mail LVM的扩容 VG卷组还有剩余空间 执行 lvextend -L +3G /dev/mail_store/mail (扩展lvm逻辑卷mail的大小) 更新文件系统大小 resize2fs /dev/mail_store/mail 如果文件系统为 xfs 则用 xfs_growfs 来扩容文件系统， 如果为ext4，则使用resize2fs 更新文件系统的大小 VG卷组没有剩余空间 解决方案：新找一块分区/dev/sd* 转化为pv，加到VG中 pvcreate /dev/sdc2 vgextend mail_store /dev/sdc2（将新建的pv加到mail_store卷组上） 将之前创建的lv（本来是3G，现在扩展到6G） lvextend -L +3G /dev/mail_store/mail （如果不加“+”,表示加到3G） 使用resize2fs命令更新系统识别的文件系统大小 resize2fs /dev/mail_store/mail LVM的缩减操作 前提是不影响数据 脱机状态下的缩减（之前创建的文件系统ext4不支持online状态进行缩减） 先卸载挂载点 umount /testLvm 重新识别缩减的文件大小 resize2fs /dev/mail_store/mail 3G （表示缩减到3G） lvreduce -L 3G /dev/mail_store/mail 重新挂载 mount -t ext4/ /dev/mail-store/mail /test/Lvm 注意注意！！！需要注意的是，mount命令进行挂载只是暂时的，永久挂载需要到/etc/fstab这个配置文件进行挂载]]></content>
      <categories>
        <category>Linux</category>
        <category>LVM逻辑卷</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全排列]]></title>
    <url>%2F%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[全排列的思想 对于一串序列，首先确定第一个数，也就是第一个数与其他数进行交换（包括他本身） 例如1 2 3 —》 1 2 3 、 2 1 3、3 2 1 然后确定第二个数 例如1 2 3 已经确定第一个数为1，那么第二个数为 1 2 3 –&gt; 1 2 3 、1 3 2 对于多位数，以此类推=v= 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 全排序问题.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;using namespace std;int arr[500];void swap(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp;&#125;void permutations(int n, int m)&#123; if (n == m) &#123; for (int k = 0; k &lt; m; k++) cout &lt;&lt; arr[k] &lt;&lt; " "; cout &lt;&lt; endl; &#125; else &#123; for (int k = n; k &lt; m; k++) &#123; swap(arr[k], arr[n]); permutations(n + 1, m); swap(arr[k], arr[n]); &#125; &#125;&#125;int main()&#123; for (int i = 0; i &lt; 3; i++) cin &gt;&gt; arr[i]; permutations(0, 3); return 0;&#125;//这个代码的执行顺序是第一个数需要与其他数（包括他本身）进行交换，这样就确定了第一个数//然后第二个数也是同样的原理，第二个数与第二个数，还有后面也就是第三个数...进行交换，这样也就是确定了第二个数//例如：1,2,3 //首先执行的是1和1进行交换，然后递归，2与2进行交换，然后递归，3与3进行交换，这样确定了3个数，然后就可以输出来//然后第3个递归不能再继续了，所以结束，之前交换的值重新交换回来，也就是2与2进行交换，然后第二个递归的//进行的是2与第二个数进行交换，也就是2，在for()循环的下一步，2与2后面的3进行交换，然后进入下一个递归，第三个数的确定3与3进行交换，//三个数确定，输出1 ， 3，2，依次类推.....=v=/*1 2 3 全排列的序列1 2 31 3 22 1 32 3 13 2 13 1 2*/ 但是这种方法不能正确地输出字典序，可以在每次交换进行递归的前面将后面未确定的数进行排序1234567891011121314151617181920212223242526272829void permutations(int n, int m)&#123; if (n == m) &#123; for (int k = 0; k &lt; m; k++) cout &lt;&lt; arr[k] &lt;&lt; " "; cout &lt;&lt; endl; &#125; else &#123; for (int k = n; k &lt; m; k++) &#123; sort(arr + k, arr + m); //加上这个就行了 swap(arr[k], arr[n]); permutations(n + 1, m); swap(arr[k], arr[n]); &#125; &#125;&#125;/*2 1 3 带排列的序列1 2 31 3 22 1 32 3 13 1 23 2 1*/ C++ stl的函数next_permutation函数，prev_permutation函数12345678910111213141516171819202122int main()&#123; int arr[10]; for (int i = 0; i &lt; 3; i++) cin &gt;&gt; arr[i]; sort(arr, arr + 3); //必不可少的，因为是要按照字典序输出 do &#123; cout &lt;&lt; arr[0] &lt;&lt; " " &lt;&lt; arr[1] &lt;&lt; " " &lt;&lt; arr[2] &lt;&lt; endl; &#125; while (next_permutation(arr, arr + 3)); return 0;&#125;/*2 1 31 2 31 3 22 1 32 3 13 1 23 2 1*/ 1234567891011121314151617181920212223242526bool cmp(int a, int b)&#123; return a &gt; b;&#125;int main()&#123; int arr[10]; for (int i = 0; i &lt; 3; i++) cin &gt;&gt; arr[i]; sort(arr, arr + 3,cmp); //需要从大到小排序 do &#123; cout &lt;&lt; arr[0] &lt;&lt; " " &lt;&lt; arr[1] &lt;&lt; " " &lt;&lt; arr[2] &lt;&lt; endl; &#125; while (prev_permutation(arr, arr+3)); return 0;&#125;/*1 2 33 2 13 1 22 3 12 1 31 3 21 2 3*/]]></content>
      <categories>
        <category>算法</category>
        <category>全排列</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVM逻辑卷]]></title>
    <url>%2FLVM%E9%80%BB%E8%BE%91%E5%8D%B7%2F</url>
    <content type="text"><![CDATA[逻辑卷管理器LVM MBR磁盘分区方式的局限性 LVM的原理 LVM机制的基本概念 PV –物理卷 默认包括许多大小为4MB的PE块 VG –卷组 一个或多个物理卷组合而成的整体 LV –逻辑卷 从卷组汇总分割出的一块空间，用于建立文件系统 LVM的管理命令 功能 物理卷管理 卷组管理 逻辑卷管理 Scan 扫描 pvscan vgscan lvscan Create 建立 pvcreate vgcreate lvcreate Display 显示 pvdisplay vgdisplay lvdisplay Remove 删除 pvremove vgremove lvremove Exttend 扩展 vgextend lvextend 创建LVM逻辑卷的过程 分区–》pv–》vg–》lv–》格式化–》挂载文件系统 转化物理卷 使用fdisk命令规划两个分区，类型设置为“8e”（也就是说，如果我们新加入两个盘，我们可以在这两个盘上各自新建一个分区，然后再对两个分区进行操作） 如果设置为“8e”， fdisk进入命令，输入“t”改变分区id类型，输入“8e”，代表逻辑卷类型，输入p打印，确认无误输入w保存退出 pvcreate创建物理卷 可以先用pvscan扫描是否有pv物理卷 使用pvcreate命令进行创建 pvcreate /dev/sdc1 pvcreate /dev/sdd1 创建卷组 使用vgcreate命令（可以使用vgscan扫描一遍） vgcreate mail_store /dev/sdc1 /dev/sdd1 mail_store表示的卷组名，后面两个就是刚才新建的分区 创建逻辑卷 使用lvcreate命令创建逻辑卷 例如：mail,分配3G lvcreate -L 3G -n mail mail_store 创建文件系统 mkfs -t ext4 /dev/mail_store/mail 挂载 mount -t ext4 /dev/mail_store/mail /testLvm 挂载到文件夹testLvm df -Th查看 文件系统添加完后会自动添加一个别名 /dev/mapper/mail_store/mail LVM的扩容 VG卷组还有剩余空间 VG卷组没有剩余空间 解决方案：新找一块分区/dev/sd* 转化为pv，加到VG中 pvcreate /dev/sdc2 vgextend mail_store /dev/sdc2（将新建的pv加到mail_store卷组上） 将之前创建的lv（本来是3G，现在扩展到6G） lvextend -L +3G /dev/mail_store/mail （如果不加“+”,表示加到3G） 使用resize2fs命令更新系统识别的文件系统大小 resize2fs /dev/mail_store/mail LVM的缩减操作 前提是不影响数据 脱机状态下的缩减（之前创建的文件系统ext4不支持online状态进行缩减） 先卸载挂载点 umount /testLvm 重新识别缩减的文件大小 resize2fs /dev/mail_store/mail 3G （表示缩减到3G） lvreduce -L 3G /dev/mail_store/mail 重新挂载 mount -t ext4/ /dev/mail-store/mail /test/Lvm]]></content>
      <categories>
        <category>Linux</category>
        <category>LVM逻辑卷</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘管理与文件系统]]></title>
    <url>%2F%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[磁盘管理硬盘接口 SATA/SAS 硬盘命名 sd[a..z] vd[a..z] //半虚拟化 分区方式 MBR 最多支持4个主分区（如果想创建多个分区），可以创建3个主分区，1个扩展分区，在扩展分区的基础上进行逻辑分区，就可以创建多个分区 操作软件 mdish GPT 可以创建128个分区 MBR方式进行分区—》磁盘–》分区–》格式化–》挂载 /dev/sdb 20G p1 /dev/sdb1 5G p2 /dev/sdb2 5G E /dev/sdb3 10G L1 /dev/sdb5 3G （注意，逻辑分区是从5开始的） L2 /dev/sdb6 3G L3 /dev/sdb7 4G fdish 进行分区 mkfs 在分区中创建文件系统（格式化） mkfs -t ext4 /dev/sdb1 挂载使用（df -hl查看挂载情况） mount 命令 / umount 卸载==&gt;&gt;重启后就会失效 自动挂载 进入/etc/fstab配置文件 追加 ：分区设备名 挂载点 文件系统格式 defaults 0 0 /dev/sdb1 /test ext4 defaults 0 0 （保存） 保存后执行mount /dev/sdb1 /test （test是你要挂载到的目录） 知识点 win 的盘的格式 NTFS/FAT32 dev/sr0 代表光驱 UUID ：硬件唯一标识符 光驱的文件系统格式：iso9660 swap:用于linux磁盘交换分区的特殊文件系统格式 linux支持的文件系统格式ext2/ext3/ext4 （xfs：RHEL7.0支持的文件系统） 查看文件系统情况：lsblk 磁盘的分区 /dev/sda / /boot 启动引导目录 /swap 交换目录]]></content>
      <categories>
        <category>Linux</category>
        <category>磁盘管理与文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim操作]]></title>
    <url>%2Fvim%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[vim 文本编辑器 三种模式 命令模式：默认进入的模式，复制，粘贴，删除等操作 插入模式：由命令模式进入，进行文本编辑，按ESC键退回命令模式 底行模式：在命名模式下按：键进入。进行文本的保存，退出，按ESC键退回命令模式 gg 和G 将光标跳转到首行和尾行 yy复制一行 nyy （n为数字）复制多行 p粘贴 u撤销 支持多次\ x删除一个字符 dd删除一行字符 进入插入模式 i 在光标前插入 a在光标后插入 I(大写i)在行首插入 A 在行尾插入 o在下方另起一行插入 O在上方另起一行插入 :q退出 :q！强制退出 :w 保存 :wq 保存并退出 :x 如果文件更改了，相当于wq，如果文件没有更改，相当于q :shell 暂时进入shell命令，找到相关的信息，然后按ctrl + d :set number 设置行号 :set nonumber 不设置行号 /关键字 搜索关键字 ，按n/N跳转到上/下一个关键字 :nohlsearch 取消搜索高亮 搜索与替换 :%s/搜索的字符/替换的字符/&lt;选项&gt; %代表全部的意思， s代表搜索的意思，进入搜索模式 1,9s/chenxiaojian/student/g 表示从1到9行进行搜索，g的意思代表全部替换，如果不加，则只是替换每一行的第一个字符 9s/chenxiaojian/student/g 表示在第9行进行搜索与替换]]></content>
      <categories>
        <category>Linux</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理]]></title>
    <url>%2FLinux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[linux的文件结构 目录 作用 /sbin 存放系统命令 /bin 存放用户命令 例如：ls /usr/bin/ls /root 存放启动信息和内核信息 /dev 存放设备 /home 普通用户的主目录，存放普通用户的信息和配置信息 /mnt 用于挂载设备的目录 /proc 系统运行的文件，占用内存 例如：/proc/cpuinfo /proc/meminfo /root root用户的主目录，存放root用户的信息和配置信息 /tmp 临时目录 /usr 安装软件的默认目录 /var 存放可变 大文件 /etc 存放系统配置文件 文件路径 文件类型 /var/log 日志文件 /usr/bin 普通执行程序文件 /usr/sbin 服务器执行程序文件和管理程序文件 /etc 应用程序配置文件 /usr/share/doc 应用程序文档文件 /usr/share/man 应用程序手册页文件 dev目录 存放的东西,也就是设备，我们不能直接访问这个目录的设备，Linux有挂载的概念，也就是提供一个目录，然后访问这些不能直接访问的东西 ls /dev/sda 查看你有第一块硬盘（首字母s代表着这个硬盘是SATA接口） ls /dev/sdb 查看你的第二块硬盘 (不同系统的硬盘结构可能不同，可能是以v开头的) ls /dev/sda1 代表的是第一块硬盘的第一个分区 ls /dev/sda2 代表的是第一块硬盘的第二个分区 ls /dev/sdb1 代表的是第二块硬盘的第一个分区 ls /dev/sr0 存放着光驱，也就是光碟 man 命令 1 –代表用户命令 5 –代表文件格式 8 –代表系统命令 文件（目录）处理查看文件 cat命令 用法 cat &lt;文件名&gt;注意之间有一个空格 查看cat命令的用法 cat –help 例如 ： cat -n /ect/passwd 就会给文件每一行进行编号 head 可以用于查看文件的前十行信息 tail 可以查看文件的后面10行信息 less 可以以翻页的形式查看文件 上下键，PaUp PaDn键 /关键字 –》》搜索 查看目录 ls 查看目录 -a 查看所有文件，包括隐藏文件 隐藏文件或者目录是 . 开头 . 代表当前目录， ..代表上一级目录 -l 查看详细信息 ls -l ==&gt;&gt; ll dr-xr-x—. 5 root root 205 8月 7 10:47 root 第一个字母表示文件类型 d :代表目录 -：代表文件 l : 代表链接 b: 代表块设备 第二，第三，第四r-x：所有者文件权限 r : 表示读取 w：表示写入 x：表示执行 -：表示无权限 第五，第六，第七r-x：所属组文件权限 第八，第九，第十r-x：其他用户的文件权限 第十一位 ：点代表没有配置ACL，+代表有配置ACL 第二段 “5” ：如果是目录表示目录下有几个子目录，如果是文件表示文件的链接数量 第三，四段：分别表示文件的所有者，文件所属（主要）组 第五段“205”：大小 第六七八段：代表文件的修改时间 第九段：文件、目录的名字 -d：查看目录本身的信息，通常与 -l 一起使用 ls -ld -R：以递归方式查看文件目录 -h：人性化的，就是将文件的字节转换成兆，千兆 创建目录 mkdir：创建目录 选项：-p 递归创建 创建文件 touch 创建空文件或更新文件时间戳（用于修改文件的时间属性，如果文件不存在，就创建一个新的文件） 复制 文件/目录 cp 复制文件 cp /root/file1 /home/student cp file1 file2 dir/ (复制多个文件) 复制目录 cp -r 递归复制目录，将目录的子目录和文件复制 cp -d link复制链接 cp -a == cp -rd cp -r &lt;源&gt;… &lt;目标&gt; 移动或重命名 mv 移动或重命名文件或目录（如果文件或者目录的位置没有改变，就是重命名） 用法： mv &lt;源&gt;… &lt;目标&gt; 例子 mv file1 file2 (重命名文件) mv file1 dir （将file1移动到dir的目录下） mv file1 dir2 dir （将dir2和file移动到dir） 删除文件、目录 rm 删除文件或目录（没有回收站）（如果是root用户，则会提示是否删除，需要输入y） rm -f 强制删除 删除目录，rm -r 递归删除 rm -rf （rm -rf /） 路径扩展 通配符 （用于shell命令行中匹配路径名） ”*****“ 匹配0个或多个字符 [abc123] 匹配括号任意一个字符 ？匹配任意一个字符 如果将aaa bbb复制到dir, cp ??? dir/ {} 大括号扩展 mkdir dir{1..4}{a..c} mkdir dir{a, d,1,9} 转义字符 \ 取消 \后一个字符的含义 mkdir a\ b ‘’ “” –取消引号中字符的含义 $ mkdir file$(date +%c) —-》》 file2019年09月07日 （命令输出代替命令本身） 文件归档与压缩 文件归档：将多个文件打包成一个文件的过程（并没有缩小文件的体积） 文件压缩：缩小文件体积的过程 tar 文件归档与压缩 用法： tar [选项] c(创建) t(查看) x(压缩) f(必选) v(可选) 查看详细 创建归档 用法：tar cvf &lt;归档后文件&gt;.tar &lt;需要归档的文件&gt; tar cvf dir.tar dir 归档目录 tar cvf dir.tar file？ 归档文件 查看归档 tar tvf dir.tar 提取归档 创建目录，并在新目录下提取归档 tar xvf &lt;归档文件&gt; 文件压缩 tar命名本身不支持压缩，但是可以调用压缩 压缩方式 特点 选项 标准格式 gzip 速度快，历史久，使用最广泛 z &lt;名字&gt;.tar.gz , &lt;名字&gt;.tar.tgz bzip 压缩率较小，速度最快 j &lt;名字&gt;.tar.bz2 xz 最新，压缩率最小 J &lt;名字&gt;.tar.xz 例如 tar cvf etc.tar /etc tar czvf etc.tar.gz /etc tar cjvf etc.tar.bz2 /etc tar cJvf etc.tar.xz /etc 文件查找 locate在locate数据库中按名称查找文件或目录 updatedb 手动更新locate数据库（每日更新一次） locate chenxiaojian find 在文件系统中查找文件 find &lt;查找范围&gt; &lt;选项&gt; &lt;参数&gt; 如果不指定目录，则在当前目录中查找 -name 按名称查找文件 -iname 按名称查找文件，不区分大小写 find / -name chenxiaojian -user 按用户查找文件 -group 按用户组查找文件 -size 按大小查找文件 大小： k，M, G +代表大于，-代表小于，没有指定代表等于（是向上取整的） find / -size -100M -exec find的二次处理 用法：find &lt;查找范围&gt; &lt;选项&gt; &lt;参数&gt; -exec &lt;处理动作&gt; 要求：在整个操作系统中查找admin用户的文件和目录，并将查找的结果复制到/root/dir目录下 find / -user admin -exec cp -r {} /root/dir \; find / -name “1.txt” -exec rm -rvf {} ; {}表示查找的结果； 分号代表结束；前面的\表示转义 重定向与管道每个进程都有三个通道，分别是标准输入，标准输出，标准错误 标准输入 stdin 0 键盘 标准输出 stdout 1显示 标准错误 stderr 2显示 重定向：将输出的默认位置替换为文件或其他设备 进程 1 &gt; 文件 作用：将进程1的标准输出写到文件里，覆盖文件内容 echo hello &gt; file1 将hello写入文件file1中，注意覆盖写(echo hello 1&gt;file1,通常1是可以省略的) 进程1 &gt;&gt; 文件 作用：将进程1的标准输出写入文件中，追加写 echo hello &gt;&gt; file1 进程1 2&gt; 文件 作用：将进程1的标准错误写到文件中，覆盖文件内容 ll /sdf 2&gt; file1 作用：将错误信息写入文件中 进程1 2&gt;&gt; 文件 作用：将进程1的标准错误写到文件中，追加写 ll /sdf 2 &gt;&gt; file1 如果一条进程，也就是一条命令既有正确也有错误，都写入文件中 ll file1 /dfs &amp;&gt; file1 ll file1 /dfs &amp;&gt;&gt; file1 如果将标准错误和标准输出写入不同的文件 ll file1 /dfs &gt;&gt; log1 2&gt;&gt; log2 管道：是指将进程1 的输出作为输入传递给进程2 进程1 | 进程2 ll /etc | less 文本处理 grep 进行文本处理，参数文件例如/etc/passwd，查找关键字是否在这个文件中 用法： grep &lt;关键字&gt; &lt;文件&gt; （注意grep匹配的是文件里面的信息） grep chenxiaojian /etc/passwd 跟管道配合使用 cat /etc/passwd | grep chenxiaojian 正则表达式 –模式匹配，数据匹配 *匹配0个或多个字符 ^ 行首定位符 $行尾定位符 -v 反选 -e 支持多个关键字 -E 支持更复杂的匹配模式 ^$ 匹配空行 常用命令 cd 切换路径 pwd 查看当前目录的绝对路径 常见错误 如果当前路径为/home/chenxiaojian，然后这个chenxiaojian的目录下有许多文件例如file1，那么进入/操作都是 cd / ll file1（前提是当前目录是/home/chenxiaojian）]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux文件管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中str和repr方法]]></title>
    <url>%2Fpython%E4%B8%ADstr%E5%92%8Crepr%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[str()方法面向用户 repr()方法面向程序员 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Item: def __init__(self,name): self.name = name def __str__(self): print("我在调用重写的str方法") return self.name def __repr__(self): print("我正在调用重写的repr方法") return 'Item(&#123;!r&#125;)'.format(self.name)a = Item("陈小坚")print(repr(a)) # 调用重写的repr方法,print("\n我是分割线-----------------------------\n")b = Item(repr('陈小坚')) # repr函数，这里其实是object的repr方法，也就是默认的repr方法print(b)print("\n我是分割线-----------------------------\n")c = repr('陈小坚') # repr函数，这里其实是object的repr方法，也就是默认的repr方法print(c)print("\n我是分割线-----------------------------\n")d = Item('陈小坚') """ 这里d是一个类对象，print输出时就会d这个对象时，相当于就是对d进行渲染，就会调用str方法， 然后这个对象是类对象，就查看这个类有没有重写的str方法，有就会调用重写的str方法，没有就会调用object的str方法 """print(d)print("\n我是分割线-----------------------------\n")"""我正在调用重写的repr方法Item('陈小坚')我是分割线-----------------------------我在调用重写的str方法'陈小坚'我是分割线-----------------------------'陈小坚'我是分割线-----------------------------我在调用重写的str方法陈小坚请按任意键继续. . ."""class test: def __repr__(self): print("我是str方法") return "hahahah"e = test()print(e) # print方法默认会调用str方法，然后str方法默认就会调用repr方法"""我是str方法hahahah""" 总结 print函数默认会调用str方法，然后str方法如果没有定义，内部默认是调用repr方法 然就对于类对象来说，print方法首先查看内部有没有重写的str方法，如果有调用该方法，如果没有就会 看看有没有重写的repr方法，如果有就会调用该方法，如果也没有repr方法，就会调用object类的str方法 因为所有的类都会继承这个object类 此外，str方法默认就是调用repr方法，此外，对于repr方法和str方法，都要return字符串]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python堆队列算法]]></title>
    <url>%2Fpython%E5%A0%86%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[heapq模块 – 堆队列算法堆：堆是个一个二叉树，他的每个父结点的值都大于或者小于所有孩子节点的值]]></content>
      <categories>
        <category>Python数据结构</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷】P1019 单词接龙]]></title>
    <url>%2F%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P1019%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%2F</url>
    <content type="text"><![CDATA[题目描述单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beastbeastbeast和astonishastonishastonish，如果接成一条龙则变为beastonishbeastonishbeastonish，另外相邻的两部分不能存在包含关系，例如atatat 和 atideatideatide 间不能相连。 输入格式输入的第一行为一个单独的整数nnn (n≤20n \le 20n≤20)表示单词数，以下nnn 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在. 输出格式只需输出以此字母开头的最长的“龙”的长度 输入输出样例输入 #1 12345675attouchcheatchoosetacta 输出 #1 123 说明/提示（连成的“龙”为atoucheatactactouchoose） NOIp2000提高组第三题 思路： 首先采用一个string数组，存取输入的单词，然后根据输入的字母，也就是龙的头，找到数组中每一个能够与这个字母进行相接的单词，从这些单词开始，进行DFS。 然后，每一个单词可以出现最多两次，可以设置一个visited数组进行标记 需要判断两个单词能否相接，设置一个处理函数，传入两个参数，也就是两个要处理的单词，如果这两个单词能够相接，并且对原来的单词的长度产生影响，也就是变长了，那么返回这个这两个单词相接的结果。如果不能相连接，那么返回第一个参数；注意特殊情况，如果能够相接，并且a包含b,或者b包含a,那么他们相接后的结果，即是长度跟原来相比，没有增加，所以还是返回第一个参数。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// P1019 单词接龙.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//// P1019 单词接龙.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int visited[30];string arr[30];string first;string res_str = "";int n;int res = 0;string deal(string a, string b) //分成两种情况进行判断&#123; //大佬说ddababab 和 abab，这个可以连成 ddabababab,不过，这个两个不是包含关系吗=-= //我持保留意见 if (a.size() &gt; b.size()) //判断包含，因为存在特殊情况 XXXtact tact &#123; string temp = a.substr(a.size() - b.size()); if (temp == b) return a; &#125; if (a.size() &lt; b.size()) &#123; string temp = b.substr(0, a.size()); if (temp == a) return a; &#125; int i = 1; while (i &lt; a.size() &amp;&amp; i &lt; b.size()) &#123; string c = a.substr(a.size() - i); string d = b.substr(0, i); // cout &lt;&lt; "hahah " &lt;&lt; d &lt;&lt; endl; if (c == d) break; else i++; &#125; if (i &lt; a.size() &amp;&amp; i &lt; b.size()) return a + b.substr(i); else return a;&#125;void dfs(string temp)&#123; if (res &lt; temp.size()) res = temp.size(); for (int i = 0; i &lt; n; i++) &#123; if (visited[i] &gt;= 2) continue; else &#123; string temp1 = deal(temp, arr[i]); //cout &lt;&lt; "temp:" &lt;&lt; temp &lt;&lt; " " &lt;&lt; "temp1:" &lt;&lt; temp1 &lt;&lt; endl; if (temp1.size() == temp.size()) continue; else &#123; visited[i]++; dfs(temp1); visited[i]--; &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; cin &gt;&gt; first; for (int i = 0; i &lt; n; i++) &#123; if (arr[i][0] == first[0]) &#123; visited[i]++; dfs(arr[i]); visited[i]--; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; //cout &lt;&lt; deal("", "penv11") &lt;&lt; endl;&#125;//判断重复部分出现问题//规则理解错误。。。算了/*1envelopee15*/ 总结 对于DFS和回溯的理解还是太浅了=-=，看别人的代码又懒得看下去，只能自己写，然后有点丑陋=-= 不过，通过这道题，我想我对DFS和回溯的思想更深了，毕竟代码调试了很久=-= 此外对于一些结果条件的判断，还是能冷静，静下心来=-=（被一个小失误耽误了很久=-=）]]></content>
      <categories>
        <category>OJ</category>
        <category>洛谷</category>
        <category>算法</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中深拷贝和浅拷贝解析]]></title>
    <url>%2Fpython%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[直接赋值，浅拷贝和深拷贝的区别直接赋值1234567# 直接赋值，其实就是对对象的引用a = [1,2,[3,4,5]]b = aprint(id(a)," ", id(b))# 1568089149128 1568089149128# 因为a b 都是[1,2,[3,4,5]]这个对象的引用，a和b指向同一块的内存地址 浅拷贝：拷贝父对象，不会拷贝对象内部的子对象 12345678910111213141516171819# 浅靠别拷贝import copya = [1,2,3,4,[99,88]]b = copy.copy(a)print(b)print(id(a), id(b))# [1, 2, 3, 4, [99, 88]]# 1781465341832 1781465338504# 可以看出a，b指向不同的对象# 修改a的子对象a[4][1] = 100000print("a的值", a)print("b的值", b)# a的值 [1, 2, 3, 4, [99, 100000]]# b的值 [1, 2, 3, 4, [99, 100000]]# 可以看出，a,b的对象内部的子对象还是同一个、 深拷贝： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。 12345678910111213141516171819# 深拷贝import copya = [1,2,3,4,[99,88]]b = copy.deepcopy(a)print("id a:",id(a))print("id b:",id(b))# id a: 2207231741768# id b: 2207226938760# 修改a对象的子对象a[4][1] = 100000print('a的值',a)print('b的值',b)# a的值 [1, 2, 3, 4, [99, 100000]]# b的值 [1, 2, 3, 4, [99, 88]]# 可以看出这次修改a的子对象并不会对b造成影响,说明这两个对象的子对象不是同一个]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python双向队列deque]]></title>
    <url>%2Fpython%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97deque%2F</url>
    <content type="text"><![CDATA[deque:返回一个双向队列的对象、 deque([iterable, [maxlen]])，从左到右初始化，（用方法append()），从iterable可迭代对象创建数据，如果没有指定，则这个双向队列为空。 从队列两端添加或者弹出元素的复杂度是O(1)，这个跟列表不同，列表的头部插入和移除元素的复杂度为O(n) maxlen如果没有指定或者为None，那么deque可以增长到任意长度，否则，deque就限定到最大长度。当指定长度的deque满了之后，当新项加入时，就从另一端弹出元素。 123456789101112from collections import dequeq = deque('123',maxlen=3)print(q)# deque(['1', '2', '3'], maxlen=3)q.append('5') # 队列右端插入,如果满了，就将左端的第一个元素弹出print(q)q.appendleft('99')print(q)# deque(['1', '2', '3'], maxlen=3)# deque(['2', '3', '5'], maxlen=3)# deque(['99', '2', '3'], maxlen=3) 方法append(x)–添加x到右端appendleft(x)–添加x到左端clear()–移除所有元素，使其长度为0copy()–创建一份浅拷贝count(x)–计算deque中个数等于x的元素123456789101112131415161718from collections import dequeq = deque('1234')q.append(55)# deque(['1', '2', '3', '4', 55])q.appendleft(88)# deque([88, '1', '2', '3', '4', 55])q.append('1')print(q.count('1'))# 2q.clear()# deque([])print(q) extend(iterable)–扩展deque的右侧，通过添加iterable参数中的元素extendleft(iterable)–扩展deque的左侧。注意可迭代对象中的元素顺序被反着过来添加index(x)–返回x在deque中的下标123456789101112from collections import dequeq = deque('123')q.extendleft([4,5,6])# deque([6, 5, 4, '1', '2', '3'])q.extend([7,8,9])# deque([6, 5, 4, '1', '2', '3', 7, 8, 9])print(q)print(q.index('1'))# 3 insert(i,x)–在位置i插入x,如果插入会超过最大长度，则会返回一个IndexErrorpop()–移除并且返回一个元素，队列最右端的那一个，如果没有，就返回IndexErrorpopleft()–移除返回最左的一个元素remove(value)–移除找到的第一个value,没有返回ValueErrorreverse()–将队列逆序排序，返回Nonerotate(n)–向右循环移动N步，如果是负数，就向左循环1234567891011121314151617181920212223242526272829303132# from collections import dequeq = deque('123', maxlen=3)# q.insert(0, 55)# print(q)# 发生异常: IndexError# deque already at its maximum sizeprint(q.popleft())# 1q.appendleft('2')# deque(['2', '2', '3'], maxlen=3)q.remove('2')# deque(['2', '3'], maxlen=3)print(q.reverse())# Noneprint( q)# deque(['3', '2'], maxlen=3)q1 = deque([1,2,3,4])print(q1)q1.rotate(2)print(q1)# deque([1, 2, 3, 4])# deque([3, 4, 1, 2]) 应用限长的deque提供一个过滤功能打开文件的坑：可能是由于vscode的配置的python环境问题，在本次例子中，cwd的路径应该是 d:\python学习\python数据结构，导致文本文件的相对路径问题。本来在同一个目录的py文件和文本文件，文件名的相对路径直接写上文件名就好了。 1234567# 注意一个问题，就是启动python进程的当前路径，要根据这个路径进行写文件的相对路径f = open('python数据结构/1.txt')import oscwd = os.getcwd()print(cwd)# d:\python学习print(os.path.dirname(__file__)) #当前脚本所在目录的绝对路径 1234567891011121314from collections import dequedef tail(filename, n=10): 'Return the last n lines of a file' with open(filename) as f: return deque(f, n)a = tail('python数据结构/1.txt')print(a)"""结果：返回了文件的最后10行，我想应该是相当于是因为由于限长，相当于append方法的原理deque(['444\n', '5555\n', '666666\n', '77777\n', '88888\n', '9999999\n', 'AAAAAAAAAAA\n', 'BBBBBBBBBBBBBBB\n', 'CCCCCCCCCCCCCCCCCC\n', 'DDDDDDDDDDDDDDDDDDDD'], maxlen=10)请按任意键继续. . ."""]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python生成器与迭代器]]></title>
    <url>%2Fpython%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[生成器 定义：调用一次，只生成一个值的特殊函数； 如果一个函数中含有yiled关键字，这个函数就成了生成器，只会在next方法的调用下执行，遇到yelid结束函数，并返回yiled后面所跟的值 产生生成器的方法_next_()，send()，都是启动生成器，但是send会yield返回一个值，即是yield=send的参数，而__next__方法则不会传值，或者传None; 注意yield在一个函数中，那么这个函数就是一个生成器，例如a = f()，这时a是一个生成器对象的实例，需要a.__next__()或者a.send(args)，启动生成器，第一次启动，send的参数应为None 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 列表生成式a = [i*2 for i in range(10)]print(a)# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]# 产生一个生成器可以将列表生成式的[]改成（）# 调用这个生成器,生成的数据并不是一次存放在内存中的，# 只有当这个数据循环或者__next__()到这个数据时才会生成b = (i*2 for i in range(10))print(b)# &lt;generator object &lt;genexpr&gt; at 0x000001D667CF3840&gt;print(next(b))print(b.__next__())print("begin loop\n")for i in b: print(i) # 0# 2# begin loop# 4# 6# 8# 10# 12# 14# 16# 18# 生成器实现裴波那契s数列# yield的作用就是一个函数变成一个生成器，调用fo(10)不会执行fo函数，而是返回一个可迭代对象# 每次执行到yield语句时，就会返回一个可迭代值，然后程序运行就会停留在yield语句这里，然后退出这个fo函数，下次# 用__next__()方法调用这个可迭代值，就会回到yield的下一句语句，然后继续执行fo函数，直到遇到下一个yield语句# 当函数执行结束时，generator 自动抛出 StopIteration 异常，表示迭代完成。# 在 for 循环里，无需处理 StopIteration 异常，循环会正常结束。"""def fo(number): i,a,b=0, 0, 1 while i &lt; number: yield b a,b=b,a+b i = i+1 return "我是fo函数的返回值"c = fo(10)print(c)# &lt;generator object fo at 0x0000023382C33750&gt;while True: try: print(c.__next__(), end=" ") except StopIteration as e: # as定义异常实例 print("已经10个数了", e.value) break# 1 1 2 3 5 8 13 21 34 55 已经10个数了 我是fo函数的返回值""" 迭代器 可迭代对象 iterable —可以进行for循环的对象，例如列表，元组。。。 迭代器 iterator —可以被next()函数调用并不断返回下一个值的对象 1234567891011# 导入模块，可能是版本问题，collections加上.abcfrom collections.abc import Iterable,Iteratorprint(isinstance([], Iterable))# True# 内置方法，将可迭代对象转成迭代器 iter()print(isinstance(iter([]), Iterator))# True#]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数参数]]></title>
    <url>%2Fpython%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数参数的类型 必需参数 关键字参数 默认参数 不定长参数 必需参数调用时传入的参数的个数须和声明时的参数个数一样，并且传入的顺序需要一致，一一对应。 123456789101112def f(a,b): print("函数参数的值为&#123;&#125;,&#123;&#125;".format(a,b))f(1,5)list1 = [2,3]f(*list1) # 在调用函数时在参数中加个*是将列表、元组转成多个参数# 执行结果：# 函数参数的值为1,5# 函数参数的值为2,3# 请按任意键继续. . . 关键字参数使用关键字参数允许传入参数的顺序与声明时不一致，因为python解释器能够根据参数名匹配参数值 12345678910# 关键字参数def f1(name, age): print("我的名字：&#123;&#125;，我的年龄：&#123;&#125;".format(name,age))f1(age=18, name="陈小坚")# 执行结果：# 我的名字：陈小坚，我的年龄：18# 请按任意键继续. . . 默认参数调用函数时，如果函数没有没有传递参数，就会使用默认参数 总结：带默认值的参数必须放在没有默认值的参数后面，如果不这样做，可能会产生歧义，程序error 123456789101112131415161718192021222324# 默认参数# error code"""def f2(name='陈小坚', age): print("我的名字：&#123;&#125;我的年龄：&#123;&#125;")f2("晨晨陈",20)"""def f2(age,name='陈小坚'): print("我的名字：&#123;&#125;\n我的年龄：&#123;&#125;".format(name,age))f2(20, "陈陈陈")print("----------------")f2(20)# 程序结果：# 我的名字：陈陈陈# 我的年龄：20# ----------------# 我的名字：陈小坚# 我的年龄：20 不定长参数函数调用时传入的参数比声明时的参数多，两个基本语法 带*星号的参数会以元组的形式导入，存放一些多的，没有命名的参数 带**的参数则会以字典的形式处理 123456789101112131415161718192021222324252627282930313233343536# 不定长参数def f3(a, b, *c): print(a) print(b) print(c)list2=[1,2,3,4,5,6,7,8]f3(1,3,1,2,3,4,5)print("\n")f3(1,4) # 如果不传入第3个参数，则默认传入一个空元组print("\n")f3(1,2,list1)print("\n")f3(1,2,*list1) # 将列表转成多个参数传入# 执行结果：# 1# 3# (1, 2, 3, 4, 5)# 1# 4# ()# 1# 2# ([2, 3],)# 1# 2# (2, 3)# 请按任意键继续. . 123456789101112131415# 总结：以字典传入参数时，如果实参没有key=Value这个形式的参数例如：f4(1,2,3)，会默认将这些实参传给# 例子中的a,然后出现错误,因为a接受了多个参数def f4(a, **arg): print(a) #不指定参数的话，就是一个空字典 print(arg)print("执行结果：")f4(1)f4(1,a1=4, b=9, c="陈小坚")# 执行结果：# 1# &#123;&#125;# 1# &#123;'a1': 4, 'b': 9, 'c': '陈小坚'&#125;# 请按任意键继续. . . 声明函数时，可以单独出现，但是在传入参数的时候，后面的参数需要以关键字参数的形式传入 1234567# 特殊情况：def f5(a,b,*,d): return a+b+dprint(f5(1,2,d=4))# 7 对*和**的使用方法的总结： 形参加*，在调用函数时可以将传入的多个参数转换成一个元组；实参加*，可以将传入的列表或者元组转换成多个参数 123456789101112131415161718192021222324def f1(a,b,*c): print(a) print(b) print(c)f1(99,88,77,66,55,44,33)# 99# 88# (77, 66, 55, 44, 33)# 请按任意键继续. . .def f2(a,b,c,d): print(a) print(b) print(c) print(d)list1 = [2,3,4]f2(0,*list1)# 0# 2# 3# 4# 请按任意键继续. . . 形参加**，在调用函数时可以将传入的多个键值对转换成一个字典；实参将**，可以将传入的字典转成多个键值对，相当于以关键字参数传给形参 123456789101112131415161718192021def f3(a,b,**c): print(a) print(b) print(c)f3(1,2,d=3,f=4,m="陈小坚")# 1# 2# &#123;'d': 3, 'f': 4, 'm': '陈小坚'&#125;def f4(name, age, sex): print("我的名字:&#123;&#125;\n我的年龄：&#123;&#125;\n我的性别：&#123;&#125;".format(name,age,sex))dict1= dict(name="陈小坚", age=18,sex="男")f4(**dict1)# 我的名字:陈小坚# 我的年龄：18# 我的性别：男# 请按任意键继续. . .]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python装饰器]]></title>
    <url>%2Fpython%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器：本质就是一个函数 不会修改被装饰函数的源代码 不会修改被装饰函数的调用方式 实现装饰器的前提知识 函数即是”变量“，变量名其实相当于门牌号，其实就是对对象的引用，然后去内存中根据变量名找到对象； 而python的内存回收机制就是当一个对象没有没用被引用时，python就会自动地释放这个对象的内存空间；所以当我们用del删除一个变量，例如x,只是删除x对1这个对象的引用，当1没有被引用时，就会释放1啦； 此外，需要注意的是打印一个函数名，结果是这个函数在内存的地址 12345678910111213141516def f(): print("这个是f函数") f1()def f1(): print("这是个f1函数")f()# 这个是f函数# 这是个f1函数# 请按任意键继续. . .# 总结：f()函数被调用时，首先执行Print语句，然后执行f1()，就去内存中找“门牌号"为f1的”变量“# 即是：只要f1()只要已经被定义，存在内存中，在f()函数调用之前# 这个跟c/c++有所不同 高阶函数： 把一个函数名当做实参传给另外一个函数 返回值中包含函数名 123456789101112131415161718192021222324252627282930# 高阶函数# 做函数参数def f1(fune): print(fune) fune()def f2(): print("hahah")f1(f2)# 结果：# &lt;function f2 at 0x000001316AB9B9D8&gt;# hahah# 总结：函数名其实也是一个变量，也是可以作为参数进行传递的，打印函数名的结果就是这个函数的内存地址# 做返回值def f3(): print("这个是函数f3") return f3a = f3()a()# 结果：# 这个是函数f3# 这个是函数f3 嵌套函数——在一个函数的函数体内用def声明一个函数 需要注意局部作用域和全局作用域 函数体的内容只有在调用时才会被执行 123456789101112131415161718192021222324252627282930# 嵌套函数def f4(): def f5(): print("我是f5函数") return f5 f5() return f5b = f4()b()print(b)# 执行结果：# 我是f5函数# 我是f5函数# &lt;function f4.&lt;locals&gt;.f5 at 0x000002576940CBF8&gt;##################################################def f6(): print("这个是f6") def f7(): print("这个是f7")f6()# 执行结果：# 这个是f6# 请按任意键继续. . .# 总结：需要注意局部作用域，f7这个函数它只在f6这个函数的函数体内存在作用 装饰器实现样例：12345678910111213141516171819202122232425262728293031323334353637# 问题：给f()函数增加程序执行时间计算的功能。import timedef deco(fune): def count_time(): start_time = time.time() fune() end_time = time.time() print("函数执行的时间为&#123;&#125;".format(end_time-start_time)) return count_time @decodef f(): time.sleep(3) print("我是f函数")@decodef f1(): time.sleep(3) print("我是f1函数")# f = deco(f) #可以改成“@装饰器”f()f1()# 执行结果# 我是f函数# 函数执行的时间为3.0018532276153564# 我是f1函数# 函数执行的时间为3.0000414848327637# 请按任意键继续. . .# 总结：需要注意装饰器函数需要声明在被装饰函数的前面，因为@deco就是相当于f = deco(f),# 如果不这样做的话，python解释器运行到@deco,就会起调用这个deco函数，你得保证内存中已经定义好# 这个deco函数 实现样例存在问题：函数返回值的问题与不同函数会有不同的参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 存在问题，如果装饰的函数存在不同的函数参数的个数，import timedef deco(fune): def calculater_time(*args1, **args2): start_time = time.time() funtion_return_values = fune(*args1, **args2) # 新增代码，解决加上装饰器函数的返回值问题 end_time = time.time() print("程序运行的时间为%s" %(end_time-start_time)) return funtion_return_values # 新增代码，解决加上装饰器函数的返回值问题 return calculater_time@decodef test1(): time.sleep(2) print("程序执行test1") return "我是test1的返回值"@decodef test2(a): time.sleep(2) print("程序执行test1,并且传入一个参数为&#123;&#125;".format(a))@decodef test3(name, age): time.sleep(2) print("名字：&#123;&#125;, 年龄：&#123;&#125;".format(name,age))# 调用：res = test1()test2("陈小坚")test3(1, age=18) #装饰器不影响原来的调用方式print("表面调用test1的返回值：&#123;&#125;".format(res)) # 表面调用test1的返回值：None# 本来应当返回 "我是test1的返回值",但是却返回None，因为这个test1在调用时其实已经不是test1,# calculater_time函数的函数体内其实已经test1已经返回"我是test1的返回值"，但是却没有人接受，所以装饰器还可以在修改# 程序执行test1# 程序运行的时间为2.002197504043579# 程序执行test1,并且传入一个参数为陈小坚# 程序运行的时间为2.004718065261841# 名字：1, 年龄：18# 程序运行的时间为2.0046701431274414# 表面调用test1的返回值：我是test1的返回值# 请按任意键继续. . . 存在需求：根据装饰器的参数的不同，选择不同的执行方式解决：在上面的基础上在外层加上一个函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 存在需求，如果根据装饰器的不同参数，执行不同的代码,例如登录系统中，不同的认证方式# 事先设置用户名username="陈小坚"password="123"def deco(auth_type): def deco_inside(func): def auth_funtion(*agrs1, **agrs2): if auth_type=="local": username1 = input("input your name:").strip() password1 = input("input your password:").strip() if username==username1 and password==password1: print("welcome &#123;&#125;,login in sucessfully!!".format(username1)) func() else: print("error: valiavd username or password") else: print("你不是在本地登录的！！！") return auth_funtion return deco_inside@deco(auth_type="local")def home(): print("welcome to home page!!")@deco(auth_type="foreign")def about(): print("welcome to about page!!")# 其实就是在加了一层，只不过执行顺序还是要注意home()#运行顺序，首先将local传递给auth_type，然后返回return deco_inside,这样就会去执行deco_inside(func)---&gt;&gt;相# 当于home=deco_inside(home),home--&gt;func,而这个deco_inside函数返回auth_funtion给home赋值，# 于是home()--&gt;auth_funtion()about()# 程序执行结果：# input your name:陈小坚# input your password:123# welcome 陈小坚,login in sucessfully!!# welcome to home page!!# 你不是在本地登录的！！！# 请按任意键继续. . .]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块]]></title>
    <url>%2Fpython%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[1.实现类似进度条的方法12345678import sys, timefor i in range(20): sys.stdout.write('#') # 不换行的输出 sys.stdout.flush() # 刷新缓冲区 time.sleep(0.5) # 函数推迟调用线程的运行# 实现类似进度条的效果 2.输出python3文件的默认编码12345import sysprint(sys.getdefaultencoding# python3中字符的编码格式默认是Unicode，如果gbk编码的文件要在utf-8显示， 步骤，先decode('gbk').encode('utf-8') 即是gbk--&gt;Unicode--&gt;utf-8]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python未解决问题]]></title>
    <url>%2Fpython%E6%9C%AA%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[python中文件读写，对于英文字符的文件内容，读意味着文件指针移动一个，也就是说文件指针的位置跟所读的字符个数相等，但是对于中文字符，文件指针的位置跟自己想象的不同解决：首先知道文件编码英文和汉字所占的字节个数英文字母：·字节数 : 1;编码：GB2312 字节数 : 1;编码：GBK 字节数 : 1;编码：GB18030 字节数 : 1;编码：ISO-8859-1 字节数 : 1;编码：UTF-8 字节数 : 4;编码：UTF-16 字节数 : 2;编码：UTF-16BE 字节数 : 2;编码：UTF-16LE 中文汉字：字节数 : 2;编码：GB2312 字节数 : 2;编码：GBK 字节数 : 2;编码：GB18030 字节数 : 1;编码：ISO-8859-1 字节数 : 3;编码：UTF-8 字节数 : 4;编码：UTF-16 字节数 : 2;编码：UTF-16BE 字节数 : 2;编码：UTF-16LE 12345678910111213141516171819f = open('test1.txt', 'r', encoding='utf-8')print("当前文件指针的位置：", f.tell())# 0data = f.read(10)print("读出的字符串的内容为：", data)print(type(data))print("读出字符串的长度：", len(data))print("当前文件指针的位置：", f.tell())f.close()# 当前文件指针的位置： 0# 读出的字符串的内容为： 我陈小坚哈哈哈陈小坚# &lt;class 'str'&gt;# 读出字符串的长度： 10# 当前文件指针的位置： 30# 请按任意键继续. . . 读取文件的10个汉字，然后文件指针移动到了30的位置，说明了read()函数是读取字符个数，而所读取的字符都是汉字，占3个字节，因为是utf-8的编码 总结：seek()移动的是字节数，read()读取的是字符的个数]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[python函数:返回值数为0时，返回None,大于1时，返回元组。 高阶函数 strip() 方法 用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。 注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。 12345str1 = "0000你好0000"print(str1.strip('0'))# 执行结果# 你好# 请按任意键继续. . enumerate()方法 enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 如果第二个参数不指定的话，默认下标从0开始，否则按照参数的值作为起始下标 12345678910111213list1 = ['哈哈','嗯嗯','嘿嘿','额鹅鹅鹅']for index, i in enumerate(list1, 6): print(index,i)list2 = list(enumerate(list1))print(list2)# 6 哈哈# 7 嗯嗯# 8 嘿嘿# 9 额鹅鹅鹅# [(0, '哈哈'), (1, '嗯嗯'), (2, '嘿嘿'), (3, '额鹅鹅鹅')]# 请按任意键继续. . . isinstance(obj,type) 判断一个对象是属于什么类型，返回值为bool值 1234567891011121314class animals(): def run(self): print("动物正在奔跑")class cat(animals): def run(self): print("小猫正在奔跑")cat1 = cat()cat1.run()# 小猫正在奔跑print(isinstance(cat1, animals))# True]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件操作]]></title>
    <url>%2Fpython%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件操作的三个步骤 打开文件 操作文件 关闭文件 文件打开模式 r：open()方法不指定的时候，默认是只读模式 w：打开一个文件进行写入，如果文件存在，则打开文件并从头编辑，如果文件不存在，则会创建新的文件 a：打开一个文件进行追加写，也就是说，这种模式不能进行读文件，且如果文件存在，文件指针就会指向文件的末尾，这样写文件时就会将字符串写在文件的末尾；若文件不存在，则会创造一个新文件 r+：读写模式，打开一个文件，并追加写 1.open()方法1234567f = open("test1.txt", encoding="utf-8").read()print(f)# &lt;_io.TextIOWrapper name='test1.txt' mode='r' encoding='cp936'&gt;# open()如果不指定打开模式，默认是以只读打开# 此外要注意文件的编码方式# 如果文件是用utf-8编码的，那么如果不指定以什么编码方式打开，可能就会默认以系统打开文件的方式打开，在windows系统上通常用GBK方式打开文本文件。但是GBK是不能解析utf-8. 2.read()方法​ 用于从文件读取指定的字符个数，如果未给定或为负则读取所有。 123456789f = open("test1.txt", encoding="utf-8")data1 = f.read()data2 = f.read()print(data1," ----", data2)# 程序执行结果：# 哈哈哈 啊啊啊 ----# 结果显示data2为空，说明第一次读文件的时候，读完之后文件指针指向了文件的末尾，所以第二次就没有读到任何东西 1234567f = open("test1.txt",encoding="utf-8")data1 = f.read(2)print(data1)# 程序执行结果# 哈哈# 说明了汉字在这里是算一个字符的 3.write()方法​ 将字符串写入文件，并且返回写入字符串的长度。在文件关闭前或者缓冲区刷新前，字符串的内容是存放在缓冲区中，这时在文件内是看不到字符串的。 1234f = open("test1.txt",'w',encoding="utf-8")print(f.write("我是陈小坚"))# 程序执行结果# 5 注意，如果是wb模式打开文件的话，即二进制写文件，那么字符串要转换为bytes形式（字节） 此外，以wb模式打开文件，不能指定encoding编码方式，如果指定则会报错 binary mode doesn&#39;t take an encoding argument 1234567f = open("test1.txt",'wb')print(f.write("我陈小坚".encode(encoding='utf-8')))print("我陈小坚".encode(encoding='utf-8'))# 测试结果# 12# b'\xe6\x88\x91\xe9\x99\x88\xe5\xb0\x8f\xe5\x9d\x9a' 123456789# 追加方式打开字符串f = open("test1.txt", 'a', encoding="utf-8")print(f.write("哈哈哈陈小坚是个白痴！！"))# 测试结果# 12"""文件内容我陈小坚哈哈哈陈小坚是个白痴！！""" 4.readlin()方法​ 读取文件的一行，包括换行符 12345678910111213141516f = open("test1.txt",'r',encoding='utf-8')for i in range(5): print(f.readline())# 程序执行结果# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈1坚哈哈哈陈小坚是个白痴！！# 我陈2坚哈哈哈陈小坚是个白痴！！# 我陈3坚哈哈哈陈小坚是个白痴！！# 我陈4坚哈哈哈陈小坚是个白痴！！# 请按任意键继续. . . 5.readlines()方法​ 返回一个列表，列表的每个元素是文件一行的数据，包括换行符 只是适用读小文件 123456789f = open("test1.txt",'r',encoding='utf-8')# data = f.readlines()# print(data)# # 执行结果""" ['我陈小坚哈哈哈陈小坚是个白痴！！\n', '我陈1坚哈哈哈陈小坚是个白痴！！\n', '我陈2坚哈哈哈陈小坚是个白痴！！\n', '我陈3 坚哈哈哈陈小坚是个白痴！！\n', '我陈4坚哈哈哈陈小坚是个白痴！！\n', '我陈5坚哈哈哈陈小坚是个白痴！！\n', '我陈6坚哈哈哈 陈小坚是个白痴！！\n', '我陈小坚哈哈哈陈小坚是个白痴！！\n', '我陈小坚哈哈哈陈小坚是个白痴！！\n', '我陈小坚哈哈哈陈小坚是个白痴！！'] """ 123456789101112131415161718192021222324252627282930313233343536# 效率低的循环f = open("test1.txt",'r',encoding='utf-8')for i in f.readlines(): print(i.strip())# 由于readlines返回一个列表，并且列表中的元素是字符串形式，所以调用str.strip(),用于去除头尾的空格或者换行符# 执行结果# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈1坚哈哈哈陈小坚是个白痴！！# 我陈2坚哈哈哈陈小坚是个白痴！！# 我陈3坚哈哈哈陈小坚是个白痴！！# 我陈4坚哈哈哈陈小坚是个白痴！！# 我陈5坚哈哈哈陈小坚是个白痴！！# 我陈6坚哈哈哈陈小坚是个白痴！！# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈小坚哈哈哈陈小坚是个白痴！！# --------------------------------------------#高效的循环方式，将文件对象作为迭代器使用f = open("test1.txt",'r',encoding='utf-8')for line in f: print(line.strip())# line对象是str类型# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈1坚哈哈哈陈小坚是个白痴！！# 我陈2坚哈哈哈陈小坚是个白痴！！# 我陈3坚哈哈哈陈小坚是个白痴！！# 我陈4坚哈哈哈陈小坚是个白痴！！# 我陈5坚哈哈哈陈小坚是个白痴！！# 我陈6坚哈哈哈陈小坚是个白痴！！# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈小坚哈哈哈陈小坚是个白痴！！ 6.tell()方法返回文件的当前位置，即是文件指针的位置，位置是按照字符算的 123456789101112131415161718f = open('test1.txt', 'r', encoding='utf-8')print("当前文件指针的位置：", f.tell())# 0data = f.read(10)print("读出的字符串的内容为：", data)print(type(data))print("读出字符串的长度：", len(data))print("当前文件指针的位置：", f.tell())f.close()# 当前文件指针的位置： 0# 读出的字符串的内容为： 我陈小坚哈哈哈陈小坚# &lt;class 'str'&gt;# 读出字符串的长度： 10# 当前文件指针的位置： 30# 请按任意键继续. . . 7.seek()方法用于移动文件读取指针到指定位置。 第一个参数–开始的偏移量，也就是代表需要移动偏移的字节数，如果是负数表示从倒数第几位开始 第二个参数–默认是0.0表示当前位置，1表示文件头，2表示文件尾 123456789101112131415f = open('test1.txt', 'r', encoding='utf-8')# f.seek(10) # 出现utf-8编码错误，首先文本文件的编码方式是utf-8，所以可能是文件指针移动到10个字节，前提条件是我们的文件是utf-8编码# 然后一个汉字占3个字节，但是你文件指针移动10个字节，导致指针移动后所在的位置加上后面一个字节的内容不是utf-8所# 编码的内容，从而编码错误# 只需seek()参数是3的倍数就不会出现问题f.seek(9)print("当前文件指针的位置：", f.tell())data = f.readline()print("读取的内容为：", data.strip())# 当前文件指针的位置： 9# 读取的内容为： 坚哈哈哈陈小坚是个白痴！！# 请按任意键继续. . . 8.encoding返回文件的编码方式 1234f = open('test1.txt', 'r', encoding='utf-8')print(f.encoding)# utf-8# 请按任意键继续. . . 9.name–返回文件的名字10.flush()方法flush() 方法是用来刷新缓冲区的，即将缓冲区中的数据立刻写入文件，同时清空缓冲区，不需要是被动的等待输出缓冲区写入。 一般情况下，文件关闭后会自动刷新缓冲区，但有时你需要在关闭前刷新它，这时就可以使用 flush() 方法。 11.truncate()方法参数可选，如果指定参数，就是从参数所在的位置开始截断，参数是按照字节的大小进行保留的 Windows下换行符占两个字节 1234567f = open('test1.txt', 'r+', encoding='utf-8')f.truncate(25)# 文件结果：你好啊啊啊啊啊12# 因为这个文件是utf-8编码的，7个汉字占了21个字节，然后Windows下换行符占两个字节，数字英文utf-8占一个字符，所以截断后文件保留的内容就是这个占了25个字节的内容# 此外还应当注意文件的打开模式，r+读写模式，如果w模式打开，则文件内容变成二进制的。。。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceshi]]></title>
    <url>%2Fceshi%2F</url>
    <content type="text"></content>
      <categories>
        <category>OJ</category>
        <category>leetcode</category>
        <category>算法</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>hh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷】p3952时间复杂度]]></title>
    <url>%2F%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P3952%20%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下： 123F i x y 循环体E 其中F i x y表示新建变量 iii（变量 iii 不可与未被销毁的变量重名）并初始化为 xxx， 然后判断 iii 和 yyy 的大小关系，若 iii 小于等于 yyy 则进入循环，否则不进入。每次循环结束后 iii 都会被修改成 i+1i +1i+1，一旦 iii 大于 yyy 终止循环。 xxx 和 yyy 可以是正整数（xxx 和 yyy 的大小关系不定）或变量 nnn。nnn 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100100100。 “E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。 输入格式输入文件第一行一个正整数 ttt，表示有 ttt（t≤10t \le 10t≤10）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构 允许嵌套。 接下来每个程序的第一行包含一个正整数 LLL 和一个字符串，LLL 代表程序行数，字符 串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为nwn^wnw，其 中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。 接下来 LLL 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 iii 是一个小写字母（保证不为nnn），表示新建的变量名，xxx 和 yyy 可能是正整数或 nnn ，已知若为正整数则一定小于 100。 程序行若以E开头，则表示循环体结束。 输出格式输出文件共 ttt 行，对应输入的 ttt 个程序，每行输出Yes或No或者ERR（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出Yes，不一致则输出No，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出ERR 。 注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 输入输出样例输入 #1 1234567891011121314151617181920212223242526272829303132333482 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE 输出 #1 12345678YesYesERRYesNoYesYesERR 思路： 1.采用在线处理的方法，将F x i j 和E定义成string类型，每次读入一行数据，就判断是什么类型的语句 如果是F x i j就进栈中 如果E，就判断一下栈是否为空，不为空说明有F x i j与它相互匹配，就可以将栈顶元素，也就是也E语句相互匹配的最近的F x i j弹出来 2.如何判断结果是Yes or No，因为结果只有O(1)和O(n^m)，所以我们可以求出循环嵌套次数的最大值，然后跟1or m比较，如果相等，输出Yes，否则输出No。 3.判断输入是否存在错误，错误情况： 如果全部语句的个数是奇数的话，那肯定是错误的 如果F和E语句的个数不相等的话，也是错误的。例如：FFFFEE 如果F x i j和E语句的个数相等的话，如果存在FFEEEF，那么这种情况就是错误，这种情况循环结束后栈是不为空的，可以根据这个条件进行判断 还有一种错误就是变量名重复，由于变量名是一个小写字母，所以我们可以全局定义数组，循环输入语句时，判断，如果是F x i j，就提取第三个字符即是string[2]，对其处理，index= string[2]-97，所以例如字符a，就存放在数组的0号位置。因此，初始化数组，全部置0，表示还没定义变量，遇到一个变量，判断是不是没有被定义过，即是0，如果没有，置为1，表示被定义了，如果输入的变量被定义过了，设置一个flag，就可以判断错误了。此外销毁变量即是在出栈的时候，就把变量在数组中的置为0. 4.特殊情况 FEFE FFFEEFFEEE 此外就是如果一个F是不能进行循环的，那么其内嵌套的循环也是不是使得嵌套次数增加的，具体处理看代码 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;iostream&gt;# include &lt;string&gt;# include &lt;cstring&gt;# include &lt;stack&gt;using namespace std;int x_tag[30] = &#123; 0 &#125;; //变量名标志string temp_a = "";string temp_b = "";string temp_c = "";int string_int1(string a)&#123; for (int i = 4; i &lt; a.size()-1; i++) &#123; temp_c += a[i]; &#125; int temp = stoi(temp_c); temp_c = ""; return temp;&#125;void string_int(string a)&#123; int index; for (int i = 4; i &lt; a.size(); i++) &#123; if (a[i] != ' ') temp_a += a[i]; else &#123; index = i; break; &#125; &#125; for (int i = index + 1; i &lt; a.size(); i++) &#123; temp_b += a[i]; &#125; return;&#125;int main()&#123; int f_times = 0; int e_times = 0; int n; int line_number; //行数 string time; //时间复杂度 int times = 0; //看看有多少层循环 int max_times = 0; //最大层数 int flag = 0; //判断变量是否重复 int flag1 = 0; //判断是否错误 int flag_time = 0; //提取复杂度的特殊情况 FFFEEFFEEE int flag2 = 0; //如果在线读入的F少于E，也就是说，FFEEEE 这种特殊情况 stack&lt;string&gt;s; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; line_number; cin &gt;&gt; time; cin.ignore(); //清空缓冲区 for (int j = 0; j &lt; line_number; j++) &#123; string a; getline(cin, a); //这样空格也能被读进string a中 if (a[0] == 'F') &#123; if (x_tag[a[2] - 97] == 0) &#123; x_tag[a[2] - 97] = 1; &#125; else flag = 1;//出现同名变量 f_times++; //出现循环F的次数 s.push(a); //进栈 string_int(a); //得到F x i j的i和j if (temp_b == "n" &amp;&amp; temp_a != "n") //第一个为数字，第二个为n &#123; if (flag_time == 0) times += 1; //n次循环 else flag_time++; &#125; /* times flag_time F 1 0 F 2 0 F 不会进入循环 1 F 2 F 3 E 2 F 3 F 4 E 3 E 2 E 1 E 0 F 3 F 4 E E E E 最后max_times为4，也就是结果为O(n^4) */ //不会进入循环的情况 else if (temp_a != "n" &amp;&amp; temp_b != "n" &amp;&amp; stoi(temp_a) &gt; stoi(temp_b)) //两个都是数字,并且第一个数字大于第二个数字 flag_time++; else if (temp_a == "n" &amp;&amp; temp_b != "n") //第一个为n,第二个为数字 flag_time++; //至于其他情况不会对times嵌套次数造成影响，不用处理 temp_a = temp_b = ""; //更新嵌套的最大层数 if (max_times &lt;= times) &#123; max_times = times; &#125; &#125; else &#123; e_times++; if (e_times &gt; f_times) //特殊情况： FFEEEF flag2 = 1; if (!s.empty()) &#123; string temp1 = s.top(); int len = temp1.size(); s.pop(); x_tag[temp1[2] - 97] = 0; if(times != 0) //FFFEEFFFEEEE times--; //FEFE 最大次数为1，先times++,更新最大值，然后出栈减一 if (flag_time != 0) flag_time--; &#125; &#125; &#125; if (line_number % 2 != 0 || f_times !=e_times || !s.empty() || flag2 == 1 || flag==1) &#123; cout &lt;&lt; "ERR" &lt;&lt; endl; flag = 0; flag1 = 0; flag2 = 0; times = 0; f_times = e_times = 0; max_times = 0; flag_time = 0; memset(x_tag, 0, sizeof(x_tag)); while (!s.empty()) s.pop(); continue; &#125; if (max_times == 0 &amp;&amp; time[2] == '1') &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; // cout &lt;&lt; endl; times = 0; max_times = 0; flag = 0; flag1 = 0; flag2 = 0; f_times = e_times = 0; flag_time = 0; memset(x_tag, 0, sizeof(x_tag)); while (!s.empty()) s.pop(); continue; &#125; else if (max_times != 0 &amp;&amp; string_int1(time)== max_times) &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; // cout &lt;&lt; endl; times = 0; max_times = 0; flag = 0; flag1 = 0; flag2 = 0; f_times = e_times = 0; flag_time = 0; memset(x_tag, 0, sizeof(x_tag)); while (!s.empty()) s.pop(); continue; &#125; else &#123; cout &lt;&lt; "No" &lt;&lt; endl; // cout &lt;&lt; endl; times = 0; max_times = 0; flag = 0; flag1 = 0; flag2 = 0; f_times = e_times = 0; flag_time = 0; memset(x_tag, 0, sizeof(x_tag)); while (!s.empty()) s.pop(); continue; &#125; &#125; return 0;&#125;/*int main()&#123; int b; cin &gt;&gt; b; cin.ignore(); //它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容， //消除上一次输入对下一次输入的影响 string a; getline(cin, a); cout &lt;&lt; a &lt;&lt; endl; return 0;&#125;int main()&#123; string a = "F i 1 2"; //string_int(a, temp_a,temp_b)如果全局变量做函数参数，还是一个基本问题，只有引用参数和指针参数才会改变实参的值 string_int(a); cout &lt;&lt; temp_a &lt;&lt; " " &lt;&lt; temp_b &lt;&lt; endl; return 0;&#125;*/ 总结 输入一开始的问题：getline()，如果前面有cin，就需要清空键盘缓存区的回车键，用cin.ignore() 此外，每次大循环一次过后，要将所有用到的临时变量，标志啥的置为初始值，由于stack没有函数清空，所以要注意。]]></content>
      <categories>
        <category>OJ</category>
        <category>洛谷</category>
        <category>算法</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>模拟</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面向对象]]></title>
    <url>%2Fpython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类对象 1.类对象支持两种操作：属性引用和实例化。 2.类中一个特殊方法（构造方法)__ init__()，该方法在类实例化时会自动调用，构造方法可以传参数。 3.self代表类的实例，代表当前对象的地址，而非类 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 12345678910111213141516class stu: #定义构造方法 def __init__(self, name, sno): self.n = name self.s = sno print("我先执行--") print(self) #代表当前对象的地址 print(self.__class__) #指向类名student1 = stu("陈小坚", 1706200065)print("学生的名字为：&#123;&#125;,学号为：&#123;&#125;".format(student1.n, student1.s))# 我先执行--# &lt;__main__.stu object at 0x0000020AA2AC3748&gt;# &lt;class '__main__.stu'&gt;# 学生的名字为：陈小坚,学号为：1706200065# 请按任意键继续. . . 继承 继承：子类共享父类的数据（变量）和方法（函数） 如果子类中定义与父类同名的方法或属性，则会自动覆盖父类对应的方法和属性 1234567891011121314# 单继承class fun: def fun1(self): print("我是类fun的函数")class f(fun): def fun1(self): print("我是类f的函数")a = f() #类对象aa.fun1()# 我是类f的函数::::子类的方法覆盖了父类的方法 多继承 方法搜索顺序（类名.__mro______）,这个顺序是跟多继承的括号中父类的顺序有关的 在搜索方法时，是按照 mro 的输出结果 从左至右 的顺序查找的 如果在当前类中 找到方法，就直接执行，不再搜索 如果 没有找到，就查找下一个类 中是否有对应的方法，如果找到，就直接执行，不再搜索 如果找到最后一个类，还没有找到方法，程序报错 总结：子类从多个父类派生，而子类又没有自己的构造函数时， （1）按顺序继承，哪个父类在最前面且它又有自己的构造函数，就继承它的构造函数； （2）如果最前面第一个父类没有构造函数，则继承第2个的构造函数，第2个没有的话，再往后找，以此类推 123456789101112131415161718# 多继承class A: def fun(self): print("这是A的方法")class B: def fun(self): print("这是B的方法")class C(A, B): passc = C()c.fun()print(C.__mro__)# 这是A的方法#(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;) 多继承调用父类方法的方法： super()函数是用于调用父类(超类)的一个方法。 Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx 使用类名.方法名()的 多继承需要注意的问题1.继承关系混乱1234567891011121314151617181920212223242526class A: def __init__(self): print("进入A") print("退出A")class B(A): def __init__(self): print("进入B") A.__init__(self) #注意这里的self是B的实例 print("退出B")class C(A): def __init__(self): print("进入C") A.__init__(self) #注意这里的self是B的实例 print("退出C")class D(A, B): #error 继承关系混乱 def __init__(self): print("进入D") A.__init__(self) B.__init__(self) print("退出D")# 可以定义为 :class D(B, A)或者class(B) 2.多继承中使用类名.方法名()调用父类函数123456789101112131415161718192021222324252627282930313233343536class A: def __init__(self): print("进入A") print("退出A")class B(A): def __init__(self): print("进入B") A.__init__(self) #注意这里的self是B的实例 print("退出B")class C(A): def __init__(self): print("进入C") A.__init__(self) #注意这里的self是B的实例 print("退出C")class D(B, C): def __init__(self): print("进入D") A.__init__(self) B.__init__(self) print("退出D")d = D()# 结果可以发现:类A的函数被执行了两次# A.__init(self)中的self不能省略，跟super.__init__()有区别# 进入D# 进入A# 退出A# 进入B# 进入A# 退出A# 退出B# 退出D 3.多继承中使用super.方法名()调用父类函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# class A:# def __init__(self):# print("进入A")# print("退出A")# class B(A):# def __init__(self):# print("进入B")# A.__init__(self) #注意这里的self是B的实例# print("退出B")# class C(A):# def __init__(self):# print("进入C")# A.__init__(self) #注意这里的self是B的实例# print("退出C")# class D(A, B): #error 继承关系混乱# def __init__(self):# print("进入D")# A.__init__(self)# B.__init__(self)# print("退出D")# # 可以定义为 :class D(B, A)或者class(B)# """# ####################class A: def __init__(self): print("进入A") print("退出A")class B(A): def __init__(self): print("进入B") super().__init__() #注意这里的self是B的实例 print("退出B")class C(A): def __init__(self): print("进入C") super().__init__() #注意这里的self是B的实例 print("退出C")class D(B, C): def __init__(self): print("进入D") super().__init__() # super(D, self).__init__() #理解:可能是我们定义的父类A的init()只有一个默认参数self,而根据博主，多继承中super调用需要传全部的参数，而我们本身就没有参数，所以在这里不需要参数 # 错误的写法: 原因:函数只需要一个参数,但是却传入了两个.所以报错 # super(D, self).__init__(self) # super().__init__(self) print("退出D")d = D()# """ # 问题:super().__init__()函数参数问题# 进入B# 进入C# 进入A# 退出A# 退出C# 退出B # 退出D #请按任意键继续. . . 总结： super()会保证每个父类的函数只被执行一次。至于父类函数执行的顺序是子类的mro顺序来执行的 super函数调用父类函数传递参数的问题： 多继承时，使用super方法，对父类的传参数，应该是由于python中super的算法导致的原因，必须把参数全部传递，否则会报错- 单继承时，使用super方法，则不能全部传递，只能传父类方法所需的参数，否则会报错 多继承时，相对于使用类名.init方法，要把每个父类全部写一遍, 而使用super方法，只需写一句话便执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因 参考https://blog.csdn.net/qq_26442553/article/details/81775449 ———–我是分割线——————————- 类的私有变量和私有方法 类型的私有属性 __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs 类的方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。 类的私有方法 __private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。 类的专有方法 init : 构造函数，在生成对象时调用 del : 析构函数，释放对象时使用 repr : 打印，转换 setitem : 按照索引赋值 getitem: 按照索引获取值 len: 获得长度 cmp: 比较运算 call: 函数调用 add: 加运算 sub: 减运算 mul: 乘运算 truediv: 除运算 mod: 求余运算 pow: 乘方 可以对这些方法进行重载]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的格式化输出---str.format()]]></title>
    <url>%2Fpython%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[前言：python的字符串编码全部是unicode编码 按位置访问参数1234567print('&#123;&#125;, &#123;&#125;, &#123;&#125;'.format('a', 'b', 'c'))print('&#123;1&#125;, &#123;2&#125;, &#123;0&#125;'.format('a', 'b', 'c'))print('&#123;1&#125;&#123;0&#125;&#123;1&#125;'.format('ab', 'hj'))# a, b, c# b, c, a# hjabhj 按名称访问参数12345print('按名称访问参数1：&#123;chen1&#125;,&#123;chen2&#125;'.format(chen1="你好", chen2="你也好啊"))dict1 = &#123;'chen1': "你好", 'chen2': "你也好啊"&#125;print("按名称访问参数2: &#123;chen1&#125;&#123;chen2&#125;".format(**dict1))# 按名称访问参数1：你好,你也好啊# 按名称访问参数2: 你好你也好啊 访问参数的属性1234complex1 = 3-5jprint("这个复数&#123;0&#125;的实数是：&#123;0.real&#125;,虚数是&#123;0.imag&#125;".format(complex1))# 这个复数(3-5j)的实数是：3.0,虚数是-5.0 保留小数点后多少位12345import mathprint('常量pi的值近似为：&#123;0:.3f&#125;'.format(math.pi))print('常量pi的值近似为：&#123;:.3f&#125;'.format(math.pi))# 常量pi的值近似为：3.142# 常量pi的值近似为：3.142 访问参数的项1234567tuple1 = (3, 5)list1 = [3, 5]print("元组的元素为：&#123;0[0]&#125;, &#123;0[1]&#125;".format(tuple1))print("列表的元素为：&#123;0[0]&#125;, &#123;0[1]&#125;".format(list1))# 元组的元素为：3, 5# 列表的元素为：3, 5 替代%s和%r123print("repr()表示的数：&#123;!r&#125;, str()表示的数：&#123;!s&#125;".format('test1', 'test2'))# repr()表示的数：'test1', str()表示的数：test2 对齐文本以及指定宽度12345678910111213print("&#123;:&lt;30&#125;".format('左对齐'))print("&#123;:&gt;30&#125;".format('右对齐'))print("&#123;:^30&#125;".format('居中对齐'))print("&#123;:*^30&#125;".format('居中对齐'))print("&#123;:*&lt;30&#125;".format('左对齐'))print("&#123;:*&gt;30&#125;".format('右对齐'))# 左对齐# 右对齐# 居中对齐# *************居中对齐*************# 左对齐***************************# ***************************右对齐 替代 %+f, %-f 和 % f 以及指定正负号:12345678910111213# '+' 表示标志应该用于正数和负数。# '-' 表示标志应仅用于负数（这是默认行为）。# space 表示应在正数上使用前导空格，在负数上使用减号print("&#123;:+f&#125;; &#123;:+f&#125;".format(3.14, -3.14))print("&#123;: f&#125;; &#123;: f&#125;".format(3.14, -3.14))print("&#123;:-f&#125;; &#123;:-f&#125;".format(3.14, -3.14))# +3.140000; -3.140000# 3.140000; -3.140000# 3.140000; -3.140000 替代 %x 和 %o 以及转换基于不同进位制的值:1234567print("十进制：&#123;0:d&#125;; 十六进制：&#123;0:x&#125;; 八进制：&#123;0:o&#125;; 二进制：&#123;0:b&#125;".format(42))# 十进制：42; 十六进制：2a; 八进制：52; 二进制：101010print("十进制：&#123;0:d&#125;; 十六进制：&#123;0:#x&#125;; 八进制：&#123;0:#o&#125;; 二进制：&#123;0:#b&#125;".format(42))# 十进制：42; 十六进制：0x2a; 八进制：0o52; 二进制：0b101010# 注意&#123;&#125;中的0一定要加，因为format()里面此时只有一个参数，而前面的槽有4个# 在这里format里面的参数和前面的槽是一一对应的，因此当槽的个数大于参数时就会出现报错 使用逗号作为千位分隔符12print("&#123;1:,&#125;||||||&#123;0:,&#125;".format(1234567890, 9999999999999999))# 9,999,999,999,999,999||||||1,234,567,890 表示百分数12345678a = 1b = 3print("10除3等于：&#123;:.2%&#125;".format(a/b))print("10除3等于：&#123;:.3%&#125;".format(a/b))print("10除3等于：&#123;:.4%&#125;".format(a/b))# 10除3等于：33.33%# 10除3等于：33.333%# 10除3等于：33.3333% 使用特定类型的专属格式化1234567891011121314import datetimed = datetime.datetime(2019, 7, 17, 10, 53, 58)print(type(d))print(d)print(str(d))print(repr(d))# &lt;class 'datetime.datetime'&gt;# 2019-07-17 10:53:58# 2019-07-17 10:53:58# datetime.datetime(2019, 7, 17, 10, 53, 58)print('&#123;:%Y-%m-%d %H:%M:%S&#125;'.format(d))# 2019-07-17 10:53:58# 所以直接输出d就行..... 嵌套参数以及更复杂的示例:1234567891011121314151617181920212223242526ip = [192, 168, 0, 1]print("转换为16进制为：&#123;:02X&#125;|&#123;:02X&#125;|&#123;:02X&#125;|&#123;:02X&#125;".format(*ip))print("转换为16进制为：&#123;:2X&#125;|&#123;:2X&#125;|&#123;:2X&#125;|&#123;:2X&#125;".format(*ip))print("转换为16进制为：&#123;:3X&#125;|&#123;:3X&#125;|&#123;:3X&#125;|&#123;:3X&#125;".format(*ip))print("转换为16进制为：&#123;:03X&#125;|&#123;:03X&#125;|&#123;:03X&#125;|&#123;:03X&#125;".format(*ip))#总之注意“：”前面的数字要与format()内的参数个数对应，而十六进制的"X""x"是控制大于9的字母的大小写# 转换为16进制为：C0|A8|00|01# 转换为16进制为：C0|A8| 0| 1# 转换为16进制为： C0| A8| 0| 1# 转换为16进制为：0C0|0A8|000|001width = 5for num in range(5, 12): for base in "dXob": print('&#123;0:&#123;width&#125;&#123;base&#125;&#125;'.format(num, width=width, base=base), end=" ") print()# 5 5 5 101# 6 6 6 110# 7 7 7 111# 8 8 10 1000# 9 9 11 1001# 10 A 12 1010# 11 B 13 1011 补充：int():用于将一个字符串或数字转换为整型。int(x, base=10) x–字符串或数字； base–进制数，默认是十进制 123int('12',16) # 如果是带参数base的话，12要以字符串的形式进行输入，12 为 16进制#因此12是一个十六进制数，所以转化为二进制数为0001 0010，将二进制数转化成十进制数为：2+16 =18，输出为18]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中a += b和a = a + b的区别]]></title>
    <url>%2Fmyblog_2%2F</url>
    <content type="text"><![CDATA[变量和对象的理解 在python中，变量是没有类型的，当使用变量的时候，必须要给这个变量赋值，而没有赋值，那么python认为这个变量没有定义。对象赋值实际上是对象的引用。当创建一个对象，当创建一个对象，然后把它赋值给另一个变量的时候，python并没有拷贝这个对象，而是拷贝这个对象的引用。 在python中，对象分为可变和不可变的 可变的对象：list，set，dict 不可变的对象：int，float，long，str，tuple 变量无类型，对象有类型。 变量是指向内存中的对象的一个指针，都是值的引用 对象是内存中存储数据的实体，变量是指向对象的指针 在函数中参数是传引用的，如果一个变量进到函数中，被改变，那么这个变量所指的对象，如果是可变的对象，那么变量还是指向原先对象，如果是不可变对象，那么这个变量所指的对象就不是之前所指向的对象，旧的对象因为没被使用而被python的垃圾回收机制回收 12345678910a = [1, 2, 3]b = aprint(b)b += aprint(b)print(a)#运行结果：#[1, 2, 3]#[1, 2, 3, 1, 2, 3]#[1, 2, 3, 1, 2, 3] 123456789a = [1, 2, 3]b = aprint(b)b = b + aprint(b)print(a)# [1, 2, 3]# [1, 2, 3, 1, 2, 3]# [1, 2, 3] 123456789101112131415161718192021def fun_1(p): p += [1] print("函数中的p的id为：", id(p))def fun_2(p): p = p + [1] print("函数中的p的id为：", id(p))p1 = [2, 2]p2 = [2, 2]fun_1(p1)fun_2(p2)print("p1的id：", id(p1), "p1列表的值为", p1)print("p2的id: ", id(p2), "p2列表的值为", p2)# 操作结果：# 函数中的p的id为： 1381806107656# 函数中的p的id为： 1381810873096# p1的id： 1381806107656 p1列表的值为 [2, 2, 1]# p2的id: 1381806106504 p2列表的值为 [2, 2] 由此可以看出+= 操作的对象是可变的，例如list,那么对他进行操作就是对原来所指的对象进行操作，即是对原来存储地址中的内容进行操作，存储的地址不会改变（由p和p1的id可以知道，当然这是建立在这个对象是可变的）。而对与z = x + y这类来说，就是创建一个新的对象，然后z指向这个对象。 更新 变量是对数据的引用，也就是说用赋值语句对变量重新赋值时，python为其分配了新的内存单元，变量将指向新的地址。这种说法是针对一般情况的… 至于特殊情况，就是可变对象对于a = a + b和a += b之间的区别….记住这种特殊情况就好了=-= 函数参数传递的影响 实参的值传递给形参，实际上是将实参的所指向的对象的地址传递给形参，因此，如果传递对象是不可变对象（数值，字符，元组等），在函数体中形参值的变化不会影响到实参。如果传递的对象是可变对象（r列表，字典），在函数中形参值的变化会影响到实参。也就是说，变量名相当于指针，指向一个对象，例如数值5，因为数值5是不可变的，当变量重新赋值时，变量也就指向一个新的对象。 更新对于可哈希对象和不可变对象的理解 首先，可变对象（列表，集合，字典）是不可哈希的 然后，不可变对象（数字，字符串，元组）是可哈希的 但是有个特例，[{}],即是列表中嵌套字典是可哈希的 123456789101112portfplio = &#123; &#123;'name':'陈小坚1', 'prices':91.1&#125;, &#123;'name':'陈小坚2', 'prices':92.1&#125;, &#123;'name':'陈小坚3', 'prices':93.1&#125;, &#123;'name':'陈小坚4', 'prices':94.1&#125;, &#123;'name':'陈小坚5', 'prices':95.1&#125;, &#123;'name':'陈小坚6', 'prices':96.1&#125;,&#125;# 发生异常: TypeError# unhashable type: 'dict'print(heapq.nlargest(3, portfplio, key=lambda x:x['prices'])) 123456789101112portfplio = [ &#123;'name':'陈小坚1', 'prices':91.1&#125;, &#123;'name':'陈小坚2', 'prices':92.1&#125;, &#123;'name':'陈小坚3', 'prices':93.1&#125;, &#123;'name':'陈小坚4', 'prices':94.1&#125;, &#123;'name':'陈小坚5', 'prices':95.1&#125;, &#123;'name':'陈小坚6', 'prices':96.1&#125;,]print(heapq.nlargest(3, portfplio, key=lambda x:x['prices']))# [&#123;'name': '陈小坚6', 'prices': 96.1&#125;, &#123;'name': '陈小坚5', 'prices': 95.1&#125;, &#123;'name': '陈小坚4', 'prices': 94.1&#125;]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo博客系统]]></title>
    <url>%2Fmyblog_1%2F</url>
    <content type="text"><![CDATA[使用hexo 框架搭建个人博客准备工作： 注册Github账号 安装node.js 安装git 搭建过程 打开git bash,配置git 输入 git config –global user.name “你的用户名” 输入 git config –global user.email “你的邮箱” 登录你的github账号，创建一个仓库 仓库名是默认格式的 username.github.io (username是你的用户名) 配置ssh key 打开git bash输入ssh-keygen -t rsa -C “邮件地址”，连续回车键3次然后就会生成一个文件，路径在C盘目录下用户目录下有个.ssh文件，里面有两个文件，存放着ssh key 打开id_rsa.pub文件，复制，然后到你的github主页上打开settings,在ssh and GPG Keys下粘贴 打开git bash，下载hexo 命令：npm install -g hexo 设置存放的位置，在任意一个盘中，创建一个目录，这是你存放代码的位置，打开文件，鼠标右键，有Git bash here,然后就进入到这个目录在git bash环境 初始化 命令：hexo init,这时hexo就会自动生成一个文件 其中的sourse文件夹就存放你的md文件，用来写博客 public存放md文件对应的html文件 _config.yml文件就是配置文件，修改配置都是需要操作他 theme文件夹就存放你的博客框架的主题，对应的主题可以去网上hexo的官方网站下载，常用的yilia 然后在git bash输入命令 hexo g 生成静态页面到pubilc文件，输入hexo s,启动本地服务器，localhost::4000查看是否成功 然后现在要上传到github上，先在之前的_config.yml文件中配置一下，配置完后输入hexo d上传，打开”用户名.github.io”就可以看到啦！！！ &gt;deploy: &gt; type: git &gt; repository: 这里填写你之前配置ssh的两个url，随便一个都可以 例如：git@github.com:liuxianan/liuxianan.github.io.git &gt; branch: master]]></content>
      <categories>
        <category>博客框架</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
