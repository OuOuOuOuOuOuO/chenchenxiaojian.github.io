<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer-字符串的排列]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述:1输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 思路全排列: 实现的思路参见 需要注意的问题： 判重 字典序 输入样例空字符串 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;class Solution&#123;public: vector&lt;string&gt; Permutation(string str) &#123; vector&lt;string&gt; res; if (str == "") //空字符 return res; premutation(str, res, 0); //需要输出字典序，所以进行排序 sort(res.begin(), res.end()); return res; &#125; void swap(string &amp;str, int i, int j) &#123; char temp = str[i]; str[i] = str[j]; str[j] = temp; &#125; void premutation(string str, vector&lt;string&gt; &amp;res, int size) &#123; if (size == str.size()) &#123; if (find(res.begin(), res.end(), str) == res.end()) //判断重复 res.push_back(str); return; &#125; for (int i = size; i &lt; str.size(); i++) &#123; swap(str, i, size); premutation(str, res, size + 1); swap(str, i, size); //回溯 &#125; &#125;&#125;;int main()&#123; string str = "abc"; // string str = ""; // string str = "aab"; Solution so; vector&lt;string&gt; res = so.Permutation(str); for (vector&lt;string&gt;::iterator it = res.begin(); it != res.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-二叉搜索树与双向链表]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路因为这是一个二叉搜索树，并且要求将其变成排序的双向链表，这正符合二叉树的中序遍历思路，当我们遍历到根节点的时候，左子树已经排好序，我们要就是将左子树的最大节点与根节点相连，至于如何实现左子树的排序，用pre保存上一个节点，中序遍历到当前节点cur时，就将pre-&gt;right = cur，cur-&gt;left = pre，然后进行更新pre。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;using namespace std;struct TreeNode&#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;//先序创建TreeNode *Create_tree()&#123; TreeNode *T; int val; cin &gt;&gt; val; if (val == 0) //叶子结点用0标记 return NULL; else &#123; T = new TreeNode(val); T-&gt;left = Create_tree(); T-&gt;right = Create_tree(); &#125; return T;&#125;//先序遍历void pre_print(TreeNode *T)&#123; if (T) &#123; cout &lt;&lt; T-&gt;val &lt;&lt; " "; pre_print(T-&gt;left); pre_print(T-&gt;right); &#125;&#125;class Solution&#123;public: TreeNode *Convert(TreeNode *pRootOfTree) &#123; if (pRootOfTree == NULL) return NULL; TreeNode *p = NULL; //因为左子树的最后一个左孩子的左指针须为空 convert(pRootOfTree, p); //找到最左子树的最左孩子，然后返回 while (pRootOfTree-&gt;left) &#123; pRootOfTree = pRootOfTree-&gt;left; &#125; return pRootOfTree; &#125; void convert(TreeNode *cur, TreeNode *&amp;pre) &#123; if (cur == NULL) return; convert(cur-&gt;left, pre); cur-&gt;left = pre; if (pre) pre-&gt;right = cur; //将上一个节点指向当前节点，比如是5--&gt; 6 pre = cur; //更新上一个节点 convert(cur-&gt;right, pre); &#125;&#125;;int main()&#123; TreeNode *root = Create_tree(); pre_print(root); cout &lt;&lt; endl; Solution so; TreeNode *res = so.Convert(root); cout &lt;&lt; res-&gt;val &lt;&lt; endl; while (res) &#123; cout &lt;&lt; res-&gt;val &lt;&lt; " "; res = res-&gt;right; &#125; return 0;&#125;/*8 6 5 0 0 7 0 0 10 9 0 0 11 0 08 6 5 7 10 9 11 55 6 7 8 9 10 11*/ 总结 存在问题，对二叉树的线索化不熟悉啊=-=]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-复杂链表的复制]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路 先复制对应的节点并连接在对应节点的后面 设置各个节点的random指针 将新旧链表分割开来（这里我是一脸蒙蔽，明明我返回写的函数没有返回引用，就是通过不了测试….） 时间复杂度为$O(n)$，空间复杂度为$O(1)$ AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;using namespace std;struct RandomListNode&#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;class Solution&#123;public: RandomListNode *Clone(RandomListNode *pHead) &#123; first(pHead); second(pHead); return third(pHead); &#125; void first(RandomListNode *pHead) //复制每个节点，并将节点复制到对应节点的后面 &#123; RandomListNode *p = pHead; while (p) &#123; RandomListNode *new_node = new RandomListNode(p-&gt;label); //创建新节点 //将新节点复制到原节点的后面 new_node-&gt;next = p-&gt;next; //这里不能复制节点的random指针，因为后面的新节点还没有创建，就不能连接在一起 new_node-&gt;random = NULL; //先设置为NULL p-&gt;next = new_node; //指针移动到新的节点上 p = new_node-&gt;next; &#125; &#125; void second(RandomListNode *pHead) //连接每个节点的random指针 &#123; RandomListNode *p = pHead; while (p) &#123; RandomListNode * temp = p-&gt;next; if (p-&gt;random) temp-&gt;random = p-&gt;random-&gt;next; p = temp-&gt;next; &#125; &#125; RandomListNode *third(RandomListNode *pHead) //将新旧两个链表分割出来 &#123; /* 我这自己写的就是通过不了测试，感觉也没问题啊.... if (pHead == NULL) return NULL; RandomListNode * curnode = pHead-&gt;next; RandomListNode * res = curnode; RandomListNode * temp; while (curnode-&gt;next) &#123; temp = curnode-&gt;next; curnode-&gt;next = temp-&gt;next; curnode = temp-&gt;next; &#125; return res; */ if (pHead == NULL) return NULL; RandomListNode * pnew = pHead-&gt;next; RandomListNode *temp; RandomListNode * curnode = pHead; while(curnode-&gt;next) //将旧链表重新连接好，这样也就是将新旧链表分割开来了 &#123; temp = curnode-&gt;next; curnode-&gt;next =temp-&gt;next; curnode = temp; &#125; return pnew; &#125;&#125;;int main()&#123; RandomListNode *head = new RandomListNode(1); RandomListNode *p1 = new RandomListNode(2); RandomListNode *p2 = new RandomListNode(3); head-&gt;next = p1; p1-&gt;next = p2; head-&gt;random = p2; p2-&gt;random = p1; Solution so; RandomListNode *pnew = so.Clone(head); while (pnew) &#123; cout &lt;&lt; pnew-&gt;label &lt;&lt; " "; pnew = pnew-&gt;random; &#125; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-二叉树中和为某一值的路径]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 思路DFS，根据先序遍历的思想，往下深搜，先根结点，然后左子树，接着右子树，然后回溯（就是返回到根结点的状态），当发现target == 0并且他是叶子结点就可以返回了，需要注意题目要求的是从根结点到叶结点。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct TreeNode&#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;//先序创建TreeNode *Create_tree()&#123; TreeNode *T; int val; cin &gt;&gt; val; if (val == 0) //叶子结点用0标记 return NULL; else &#123; T = new TreeNode(val); T-&gt;left = Create_tree(); T-&gt;right = Create_tree(); &#125; return T;&#125;//先序遍历void pre_print(TreeNode *T)&#123; if (T) &#123; cout &lt;&lt; T-&gt;val &lt;&lt; " "; pre_print(T-&gt;left); pre_print(T-&gt;right); &#125;&#125;class Solution&#123;public: vector&lt;vector&lt;int&gt;&gt; FindPath(TreeNode *root, int expectNumber) &#123; if (root == NULL) return &#123;&#125;; vector&lt;int&gt; temp; vector&lt;vector&lt;int&gt;&gt; res; dfs(root, expectNumber, res, temp); return res; &#125; //temp ，res不是全局，所以要加引用 void dfs(TreeNode *root, int target, vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;temp) &#123; //temp表示当前记录的路径，如果正确，就把temp复制到res中 if(root == NULL) return; target = target - root-&gt;val; temp.push_back(root-&gt;val); //判断是否已经加满了,需要注意题目要求的是叶子结点...所以要加判断是不是叶子结点 if(target == 0 &amp;&amp; root-&gt;left== NULL &amp;&amp; root-&gt;right == NULL) &#123; res.push_back(temp); temp.pop_back(); return; &#125; dfs(root-&gt;left, target, res, temp); dfs(root-&gt;right, target, res, temp); target = target + root-&gt;val; //回溯 temp.pop_back(); &#125;&#125;;int main()&#123; TreeNode *root = Create_tree(); // pre_print(root); Solution so; vector&lt;vector&lt;int&gt;&gt; res; res = so.FindPath(root, 22); //二维数组的遍历 vector&lt;vector&lt;int&gt;&gt;::iterator iter; vector&lt;int&gt;::iterator it; vector&lt;int&gt; temp; for (iter = res.begin(); iter != res.end(); iter++) &#123; //cout &lt;&lt; "哈哈" &lt;&lt; endl; temp = *iter; for (it = temp.begin(); it != temp.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; return 0;&#125;/*1 2 4 0 0 6 0 0 3 5 0 0 7 0 01 2 6 1 3 5 */]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-二叉搜索树的后序遍历序列]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同 思路 二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 利用二叉搜索树的特点，在后序序列中通过比较与根结点（也就是最后一个值）的关系，找到相应的左子树和右子树，如果左子树或者右子树不符合二叉搜索树的定义，就不是二叉搜索树了 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution&#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; return so(sequence,0,sequence.size()-1); &#125; bool so(vector&lt;int&gt; sequence, int begin, int end) &#123; if (sequence.empty() || begin &gt; end) return false; int root = sequence[end]; int i = begin; for (; i &lt; end; i++)//注意这里不包括end，因为只需要比较end前面的数字而已 &#123; if (sequence[i] &gt; root) break; &#125; int j = i; for (; j &lt; end; j++) //从j开始就是判断右子树是否都大于根结点 &#123; if (sequence[j] &lt; root) return false; &#125; bool left = true; if (i &gt; begin) //判断是否有左子树 so(sequence, begin, i - 1); bool right = true; if (i &lt; end - 1) //判断是否有右子树 so(sequence, i, end - 1); return left &amp;&amp; right; &#125;&#125;;int main()&#123; Solution s; vector&lt;int&gt;v = &#123;4,5,2,6,7,3,1&#125;; if (s.VerifySquenceOfBST(v) == true) cout &lt;&lt;"yes" &lt;&lt;endl; else &#123; cout &lt;&lt;"no" &lt;&lt; endl; &#125; return 0;&#125;/*测试样例：功能测试- 只有右子树的bst &#123;8,7,6,5&#125;- 只有左子树的bst &#123;1,2,3,4&#125;- 不是搜索树 &#123;7,4,6,5&#125;- 是搜索二叉树&#123;4,5,2,6,7,3,1&#125;==》 1,2,3,4,5,6,7广度遍历的完全二叉树特殊测试：空序列*/]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-从上往下打印二叉数]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路BFS，使用队列实现 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;struct TreeNode&#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;//先序创建TreeNode *Create_tree()&#123; TreeNode *T; int val; cin &gt;&gt; val; if (val == 0) //叶子结点用0标记 return NULL; else &#123; T = new TreeNode(val); T-&gt;left = Create_tree(); T-&gt;right = Create_tree(); &#125; return T;&#125;//先序遍历void pre_print(TreeNode *T)&#123; if (T) &#123; cout &lt;&lt; T-&gt;val &lt;&lt; " "; pre_print(T-&gt;left); pre_print(T-&gt;right); &#125;&#125;class Solution&#123;public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode *root) &#123; queue&lt;TreeNode *&gt; q; vector&lt;int&gt; res; if (root == NULL) return res; q.push(root); while (!q.empty()) &#123; res.push_back(q.front()-&gt;val); if (q.front()-&gt;left) q.push(q.front()-&gt;left); if (q.front()-&gt;right) q.push(q.front()-&gt;right); q.pop(); &#125; return res; &#125;&#125;;int main()&#123; TreeNode *root; root = Create_tree(); Solution so; vector&lt;int&gt; res; res = so.PrintFromTopToBottom(root); for (vector&lt;int&gt;::iterator it = res.begin(); it != res.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125;/*测试样例：1 2 4 0 0 5 0 0 3 6 0 0 7 0 01 2 3 4 5 6 7 */]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-栈的压入和弹出序列]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 思路 需要注意栈的压入顺序不是一直都是直接压入，中间夹杂着弹出操作 使用一个辅助栈，将压入序列一个一个压入，每次判断如果辅助栈栈顶元素等于弹出序列的值，就把栈顶元素弹出，然后弹出序列的指针前移。如果将所有的压入序列压入栈中还没有在弹出序列中找到一个可以弹出的值，那么就return false啦。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;class Solution&#123;public: bool IsPopOrder(vector&lt;int&gt; pushV, vector&lt;int&gt; popV) &#123; stack&lt;int&gt; s; int index = 0; for (int i = 0; i &lt; pushV.size(); i++) &#123; s.push(pushV[i]); if (s.top() == popV[index]) &#123; s.pop(); index++; &#125; &#125; while (!s.empty()) //所有的元素压入完成，判断能否弹出 &#123; if (s.top() == popV[index]) &#123; s.pop(); index++; &#125; else return false; &#125; return true; &#125;&#125;;int main()&#123; vector&lt;int&gt; pushv = &#123;1, 2, 3, 4&#125;; vector&lt;int&gt; popv = &#123;4, 3, 2, 1&#125;; Solution so; cout &lt;&lt; so.IsPopOrder(pushv, popv); return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-包含min函数的栈]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 思路 如果我们将每一个最小数放在栈顶，这样能保证每次弹出的元素是最小值且复杂度为$O(1)$，但是如果要使最小的元素放在栈顶，这样就不能满足栈先进先出的原则 因此：用一个辅助栈，每一次压入最小元素，获取最小值就弹出辅助栈的栈顶元素即可 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;class Solution&#123;public: void push(int value) &#123; s1.push(value); if (s2.empty()) s2.push(value); if (s2.top() &gt;= value) s2.push(value); else s2.push(s2.top()); &#125; void pop() &#123; s1.pop(); s2.pop(); &#125; int top() &#123; return s1.top(); &#125; int min() &#123; return s2.top(); &#125;private: stack&lt;int&gt; s1; stack&lt;int&gt; s2;&#125;;int main()&#123; Solution so; int value; for (int i = 0; i &lt; 3; i++) &#123; cin &gt;&gt; value; so.push(value); &#125; cout &lt;&lt; so.min() &lt;&lt; endl;&#125; 总结 明确栈的数据结构定义 虽然有时候开个辅助栈太浪费空间了，但是还是要考虑这种结果]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-函数式编程]]></title>
    <url>%2Fpython-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言编程语言通常通过以下几种方式来解构具体问题 过程式：C语言 声明式：SQL 面向对象：java，c++ 函数式编程：将一个问题分解为一系列函数 对于python而言，python是多范式语言，在大型程序中，不同的部分可能会采用不同的方式编写，比如GUI可能是面向对象的而处理逻辑则是过程式或者函数式。 在函数式程序里，输入会经过一系列函数，每个函数接受输入并输出结果，因此函数式风格反对使用带有副作用的函数，副作用就是指修改内部状态，或者一些其他状态的变化。因此消除副作用意味着不能使用随程序运行而更新的数据结构，每个函数的输出只依赖于输入。 作用 形式证明更加容易？？？一脸蒙蔽 模块化 组合化 易于调试和测试 迭代器 迭代器是一个表示数据流的对象，这个对象每次只返回一个元素 必须支持__next__()方法，不接受参数，并总是返回数据流中的下一个元素，如果数据流中没有元素，__nex__()方法就会抛出StopIteration异常]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-使用python解释器]]></title>
    <url>%2Fpython-%E4%BD%BF%E7%94%A8python%E8%A7%A3%E9%87%8A%E5%99%A8%2F</url>
    <content type="text"><![CDATA[调用解释器 命令行下传入参数 就是相当Linux下直接运行脚本的命令，这里需要注意的是，python解释器会读取命令行参数，转化为字符串列表存入sys模块的argv变量中。argv是一个列表，列表的第一项默认为空字符串，如果使用-c或者-m，那么argv[0]就是为&#39;-c/-m&#39;,之后的参数不会被解释器解释，而是直接留在sys.argv中给命令或者模块来处理 -c command：command为python代码，由于python代码中经常会包含对终端来说比较特殊的字符，所以用英文单引号括起来，多个python语句就用分号分开，但是我在windows系统上出现一些我暂时不能解释的现象，可能是windows下cmd窗口的编码不同或者是其他原因（我暂时不清楚），但是linux系统能够正常执行，所以建议不要在windows下使用命令行传入参数执行python文件吧！ usage: python3 [option] ... [-c cmd | -m mod | file | -] [arg] ...，其中[option]的用法就是下面图片的选项，具体操作查看相关文档。需要注意：当使用-m 模块名的时候，模块后面不能加.py的后缀 在windows系统的linux子系统下的验证—符合预期执行 交互模式 IDLE 进入交互模式，在windows下使用ctrl + z，linux使用Ctrl + d退出交互模式 解释器的运行环境源文件字符编码 在python3中，python文件默认是用utf-8进行编码的 如果不使用默认编码，就是要在python文件的第一行申明文件编码 1# -*- coding: cp1252 -*- 注意：当源码中以UNIX的“Shebang”行(也就是以字符&quot;#!&quot;)开头时，就要把文件编码放在第二行 12#!/usr/bin/env python3# -*- coding: cp1252 -*- Shebang这个符号通常在Unix系统的脚本中第一行开头中写到，它指明了执行这个脚本文件的解释程序。 unicode支持所有的编程语言，所有的系统，如果gbk软件放在只支持ASCII码的电脑上，只要gbk加载到内存中转换为Unicode编码，就能够正常显示。（内存中unicode编码的） 在python3中，str就是unicode类型的字符，其他编码的字符就默认是bytes类型，也就是单纯的二进制。 encode（编码）（encode : Unicode ==》utf-8/gbk） decode(解码) （decode : utf-8/gbk ==&gt; unicode） 为什么python3的utf-8的编码文件能够在windows的gbk编码的终端显示呢，这是由于python3文件加载到内存中会转换为unicode编码。但是有些语言就不能转换，例如：Python2·····]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-顺时针打印矩阵]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 思路 将矩阵当做由多个圈组成，每个打印一个圈，每个圈的起点也就是(start,start)都满足这样一个条件，那就是(行数-1)&gt; start * 2 &amp;&amp; (列数-1) &gt; start * 2，因此把这个当做循环的终止条件，在循环中每次打印一个圈，直到打印完所有的圈(0,0),(1,1),(2,2)…… 如何打印一圈？分别打印四个方向，判断每个方向是否有值需要打印（具体见代码） AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void print(vector&lt;vector&lt;int&gt;&gt; matrix, int start, vector&lt;int&gt; &amp;res) //注意要传引用，因为这个res是个局部变量，传引用这样就会操作同一个res&#123; int y = matrix.size() - start - 1; //表示矩阵中列 int x = matrix[matrix.size() - 1].size() - start - 1; //表示矩阵中的行 for (int i = start; i &lt;= x; i++) //打印上面一行 &#123; // cout &lt;&lt; matrix[start][i] &lt;&lt; " "; res.push_back(matrix[start][i]); &#125; if (start &lt; y) //表明有多行 &#123; for (int i = start + 1; i &lt;= y; i++) //打印右边一列 &#123; // cout &lt;&lt; matrix[i][x] &lt;&lt; " "; res.push_back(matrix[i][x]); &#125; &#125; if (start &lt; x &amp;&amp; start &lt; y) //表明至少有2行2列 &#123; for (int i = x - 1; i &gt;= start; i--) //打印下面一行 &#123; //注意右边一列的最后一个被打印了，所以下面一行的最右边一个就不用再次打印，所以i从x-1开始 // cout &lt;&lt; matrix[y][i] &lt;&lt; " "; res.push_back(matrix[y][i]); &#125; &#125; if (start &lt; y - 1 &amp;&amp; start &lt; x) //表明具有三行两列的结构 &#123; for (int i = y - 1; i &gt; start; i--) &#123; // cout &lt;&lt; matrix[i][start] &lt;&lt; " "; res.push_back(matrix[i][start]); &#125; &#125;&#125;class Solution&#123;public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt;&gt; matrix) &#123; vector&lt;int&gt; res; if (matrix.size() &lt;= 0 || matrix[matrix.size() - 1].size() &lt;= 0) return res; int start = 0; //每一圈开始打印的起点 while (matrix.size() &gt; start * 2 &amp;&amp; matrix[matrix.size() - 1].size() &gt; start * 2) &#123; print(matrix, start, res); start++; // exit(0); &#125; return res; &#125;&#125;;int main()&#123; // vector&lt;vector&lt;int&gt;&gt;arr(3, vector&lt;int&gt;(3)); // arr[0] = &#123;1,2,3&#125;; // arr[1] = &#123;4,5,6&#125;; vector&lt;vector&lt;int&gt;&gt; arr = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;; Solution so; vector&lt;int&gt; res = so.printMatrix(arr); for (vector&lt;int&gt;::iterator it = res.begin(); it != res.end(); it++) cout &lt;&lt; *it &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125;//1 2 4 6 5 3 总结 对于这种不需要特殊的数据结构或者算法的题，需要找到其隐藏的规律，感觉更难=-=！]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python网络爬虫-scrapy框架学习]]></title>
    <url>%2Fpython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-scrapy%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[组件 引擎（scrapy engine） 调度器（scheduler） 下载器（download）：获取网页 爬虫器（spider）：解析网页 管道（item pipeline）：存储数据 下载器中间件（download middlewares） 爬虫中间件（spider middlewares） 数据流数据流的流动方向 引擎：向爬虫器请求第一个要抓取的网页url 爬虫器：提供url给引擎 引擎：接受到网址，交给调度器排序入队 调度器：将它处理成请求request给引擎 引擎：接受到request，并通过下载器中间件给下载器下载（也就是解析网页） 下载器：根据request下载页面，返回对应的回应（response）给引擎 引擎：接受到response，并通过爬虫器中间件给爬虫器处理 爬虫器：处理response，提取数据，返回结果item给引擎，如果有跟进的请求request也会给引擎 引擎：接受到item，交给管道；新的request给调度器 管道：存储数据 如果有新的request给调度器，那么从第2步开始重复直到调度器没有request，引擎就会关闭本次爬虫。 安装pip install scrapy，不过好像听说好像会出现错误，但是我忘记我怎么成功了 创建一个新项目 爬取博客文章的标题，链接以及文章的内容 scrapy startproject blog 定义爬虫的目标字段items.py中定义 123456789import scrapy# 定义需要保存的字段class BlogItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() title = scrapy.Field() link = scrapy.Field() content = scrapy.Field() 按照默认模板创建一个爬虫（获取网页的源代码） scrapy genspider santonstang www.santostang.com定义了一个名为santostang的爬虫，并制定了爬取的url为www.santostang.com santostang.py为爬虫的代码，其中提供的parse()方法：可以获取网页的response==》response.text 将www.santostang.com网页的源代码写入到index.html（注意这个html与整个项目处于同级结构中）中 123456789101112131415# -*- coding: utf-8 -*-import scrapy# 创建的爬虫器，必须要继承scrapy.Spider类class SantostangSpider(scrapy.Spider): name = 'santostang' #爬虫器的唯一名字 allowed_domains = ['www.santostang.com'] #搜索的域名范围，规定爬虫只会爬取这个域名下的网页 start_urls = ['http://www.santostang.com/'] #爬虫器在启动时会爬取的url列表 def parse(self, response): print(response.text) filename = "index.html" with open(filename,'w', encoding="utf-8") as f: f.write(response.text) 执行爬虫，在项目的目录下执行scrapy crawl santostang(爬虫器的名字) 提取内容，保存数据 将提取的数据封装到我们定义的items.py中的BlogItem类中 爬虫器代码 123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*-import scrapyimport sysfrom bs4 import BeautifulSoupfrom blog.items import BlogItem# 创建的爬虫器，必须要继承scrapy.Spider类class SantostangSpider(scrapy.Spider): name = 'santostang' #爬虫器的唯一名字 allowed_domains = ['www.santostang.com'] #搜索的域名范围，规定爬虫只会爬取这个域名下的网页 start_urls = ['http://www.santostang.com/'] #爬虫器在启动时会爬取的url列表 # def parse(self, response): # print(response.text) # filename = "index.html" # with open(filename,'w', encoding="utf-8") as f: # f.write(response.text) def parse(self, response): items = [] soup = BeautifulSoup(response.text, "lxml") title_list = soup.find_all("h1", class_="post-title") for i in range(len(title_list)): item = BlogItem() title = title_list[i].a.text.strip() link = title_list[i].a["href"] # 变成字典 item["title"] = title item["link"] = link items.append(item) return items 将抓取到的内容输出为文件的形式 scrapy crawl 爬虫名 -o 文件名.后缀 采用管道pipelines功能存储数据 文件存放路径问题，首先我们整个项目是blog 当我们使用file_path = &quot;blog/result.txt&quot;，文件存放在blog/result.txt 当我们使用file_path = &quot;result.txt&quot;，result.txt与blog处于同级 使用管道存储数据 pipelines.py 1234567891011121314151617181920# -*- coding: utf-8 -*-# Define your item pipelines here## Don't forget to add your pipeline to the ITEM_PIPELINES setting# See: https://docs.scrapy.org/en/latest/topics/item-pipeline.htmlclass BlogPipeline(object): #保存的地址,保存在整个blog的文件夹中 file_path = "blog/result.txt" def __init__(self): self.article = open(self.file_path, "a+", encoding="utf-8") # 定义管道的处理方法 def process_item(self, item, spider): title = item["title"] link = item["link"] output = title + "\t" + link + "\n" self.article.write(output) return item 修改settings.py，启动管道功能 命令行运行爬虫scrapy crawl 爬虫名]]></content>
      <categories>
        <category>python网络爬虫</category>
      </categories>
      <tags>
        <tag>python网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-二叉树的镜像]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 思路进行先序遍历到某个节点，首先判断这个节点是不是叶子结点，如果不是，就将这个节点的左右孩子节点进行交换，当所有的非叶子结点交换完毕后就得到镜像二叉树了 程序运行过程（如图） AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;using namespace std;typedef struct TreeNode&#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125; TreeNode;//先序创建TreeNode *Create_tree()&#123; TreeNode *T; int val; cin &gt;&gt; val; if (val == 0) //叶子结点用0标记 return NULL; else &#123; T = new TreeNode(val); T-&gt;left = Create_tree(); T-&gt;right = Create_tree(); &#125; return T;&#125;//先序遍历void pre_print(TreeNode *T)&#123; if (T) &#123; cout &lt;&lt; T-&gt;val &lt;&lt; " "; pre_print(T-&gt;left); pre_print(T-&gt;right); &#125;&#125;class Solution&#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == NULL || (pRoot-&gt;left == NULL &amp;&amp; pRoot-&gt;right == NULL)) //叶子结点就不用交换 return; TreeNode *temp = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = temp; if (pRoot-&gt;left) Mirror(pRoot-&gt;left); if (pRoot-&gt;right) Mirror(pRoot-&gt;right); &#125;&#125;;int main()&#123; TreeNode *root; root = Create_tree(); cout &lt;&lt; "先序遍历为："; pre_print(root); cout &lt;&lt; endl; cout &lt;&lt; "镜像交换后为："; Solution so; so.Mirror(root); pre_print(root); return 0;&#125;/*测试样例8 6 5 0 0 7 0 0 10 9 0 0 11 0 0先序遍历为：8 6 5 7 10 9 11 镜像交换后为：8 10 11 9 6 7 5 */]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-树的子结构]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路 涉及到树的问题，大多都可以用递归的方法进行解决 首先判断节点是否一样，如果一样，就递归判断节点的左节点和右节点；如果不一样，就转去节点的左节点和右节点递归判断 需要注意的问题就是递归的终止条件 可能root2到达空的时候，但是root1还没有为空，但是这种情况是符合树的子结构的定义的 当root1到达空的时候，但是root2却还没有为空，这时就不是树的子结构了=-= AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;using namespace std;typedef struct TreeNode&#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125; TreeNode;//先序创建TreeNode *Create_tree()&#123; TreeNode *T; int val; cin &gt;&gt; val; if (val == 0) //叶子结点用0标记 return NULL; else &#123; T = new TreeNode(val); T-&gt;left = Create_tree(); T-&gt;right = Create_tree(); &#125; return T;&#125;//先序遍历void pre_print(TreeNode *T)&#123; if (T) &#123; cout &lt;&lt; T-&gt;val &lt;&lt; " "; pre_print(T-&gt;left); pre_print(T-&gt;right); &#125;&#125;bool is_part_of_tree(TreeNode *root1, TreeNode *root2)&#123; if (root2 == NULL) //子树判断到空的位置了,可能root1数还不是为空，但是这样也是符合root2是root1的子结构的原则 return true; if (root1 == NULL) //树为空，但是子树还没有为空，结果说明root2不是root1的子结构 return false; if (root1-&gt;val != root2-&gt;val) return false; return is_part_of_tree(root1-&gt;left, root2-&gt;left) &amp;&amp; is_part_of_tree(root1-&gt;right, root2-&gt;right);&#125;//判断树的子结构class Solution&#123;public: bool HasSubtree(TreeNode *pRoot1, TreeNode *pRoot2) &#123; bool res = false; if (pRoot1 &amp;&amp; pRoot2) &#123; if (pRoot1-&gt;val == pRoot2-&gt;val) res = is_part_of_tree(pRoot1, pRoot2); if (!res) res = HasSubtree(pRoot1-&gt;left, pRoot2); //递归判断左子树 if (!res) res = HasSubtree(pRoot1-&gt;right, pRoot2);//递归判断右子树 &#125; return res; &#125;&#125;;int main()&#123; TreeNode *root1, *root2; root1 = Create_tree(); cout &lt;&lt; "第一个树的先序遍历二叉树为："; pre_print(root1); cout &lt;&lt; endl; root2 = Create_tree(); cout &lt;&lt; "子树的先序遍历为："; pre_print(root2); cout &lt;&lt; endl; cout &lt;&lt; "判断两个二叉树是否是嵌套关系" &lt;&lt; endl; Solution so; cout &lt;&lt; so.HasSubtree(root1, root2) &lt;&lt; endl; return 0;&#125;/*测试样例：2 3 5 0 0 6 0 0 4 0 0第一个树的先序遍历二叉树为：2 3 5 6 4 3 5 0 0 6 0 0 子树的先序遍历为：3 5 6 判断两个二叉树是否是嵌套关系1*/ 总结 要注意对空指针的判断，不仅在链表中，在树形结构更要加以出现 对树，用递归大法 要注意特殊情况的输入测试，比如空指针等等。]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-在O1时间删除链表节点]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E5%9C%A8O1%E6%97%B6%E9%97%B4%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目给定单向链表的头指针和一个结点指针，定义一个函数在 $O(1)$ 时间删除该结点。 思路 第一个思路就是顺序查找然后找到要删除节点的位置，时间复杂度为$O(n)$ 如果想要在$O(1)$时间内删除节点，给出一个要删除的节点，我们可以很快找到这个节点下一个节点 需要注意的问题就是这个算法的前提就是要删除的节点在这个链表中，因此判断一个节点是否在这个链表中还是需要$O(n)$的时间 如果这个节点在链表中，需要注意如果这个节点是最后一个节点，那么需要注意两个情况： 只有一个节点，那么就是要删除的节点既是头结点又是尾结点 链表中有多个节点，要删除的节点是尾结点，那么需要花费$O(n)$的时间来查找 因此时间复杂度为，（前提是这个节点是在这个链表中）$${(n-1)*O(1) + O(n) \over n} = O(1)$$ 但是在链表中找到所要删除的节点还是需要$O(n)$的时间复杂度的。所以我感觉这个两种思路都差不多，但是删除的节点的话第二种思路就能实现$O(1)$时间复杂度内完成。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;iostream&gt;using namespace std;typedef struct ListNode&#123; int values; struct ListNode *next;&#125; ListNode, *L;void ListInsert(L &amp;node)&#123; L p = node; L q = new ListNode; //q为要插入的节点 q-&gt;next = NULL; cin &gt;&gt; q-&gt;values; while (p-&gt;next != NULL) &#123; p = p-&gt;next; &#125; q-&gt;next = p-&gt;next; p-&gt;next = q;&#125;void print(L node)&#123; while (node != NULL) &#123; cout &lt;&lt; node-&gt;values &lt;&lt; endl; node = node-&gt;next; &#125;&#125;//在O(1)时间内删除节点,前提是要删除的节点在这个链表中ListNode *delete_node(L phead, ListNode *tobedeleted_node)&#123; if (phead == NULL || tobedeleted_node == NULL) return NULL; //不是最后一个节点 if (tobedeleted_node-&gt;next != NULL) &#123; ListNode *pnext = tobedeleted_node-&gt;next; tobedeleted_node-&gt;values = pnext-&gt;values; tobedeleted_node-&gt;next = pnext-&gt;next; delete pnext; pnext = NULL; &#125; //链表只有一个节点，删除头结点（也是尾结点） else if (phead == tobedeleted_node) &#123; delete tobedeleted_node; tobedeleted_node = NULL; phead = NULL; &#125; //链表中有多个节点，删除尾结点,只能顺序直接查找，因为尾结点指向为next else &#123; ListNode *pNode = phead; while (pNode-&gt;next != tobedeleted_node) &#123; pNode = pNode-&gt;next; &#125; pNode-&gt;next = NULL; delete tobedeleted_node; tobedeleted_node = NULL; &#125; return phead;&#125;ListNode *find_node(ListNode *L, int value)&#123; ListNode *p = L; while (p != NULL) &#123; if (p-&gt;values == value) return p; p = p-&gt;next; &#125;&#125;int main()&#123; L a; a = new ListNode; a-&gt;next = NULL; a-&gt;values = 99; for (int i = 0; i &lt; 3; i++) &#123; ListInsert(a); &#125; cout &lt;&lt; "输出链表为：" &lt;&lt; endl; print(a); cout &lt;&lt; "删除后为：" &lt;&lt; endl; print(delete_node(a, find_node(a, 3))); return 0;&#125;/*1 2 3输出链表为：99123删除后为：9913*//*1 2 3输出链表为：99123删除后为：9912*/ 出现问题好像Linux的bash命令不能随便出现括号，因为本来我的c文件名为：在O(1)时间删除链表节点，但是出现编译错误=-=]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-打印1到最大的n位数]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。 思路 1到最大的n位十进制数，其实就是n位数字的全排列 需要考虑long long不能存放的数字，只能用高精度的思想，也就是用数组存放数字 符合正常的交互方式，也就是从第一个非0的位置开始输出 AC代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;#define maxsize 100char number[maxsize];void print(char *number) //从第一个不为0的位置开始输出&#123; int flag = 0; for (int i = 0; i &lt; maxsize; i++) &#123; if (flag == 0 &amp;&amp; number[i] != '0') flag = 1; if (flag == 1) cout &lt;&lt; number[i]; &#125; cout &lt;&lt; endl;&#125;void print_number(char *number, int index, int n) //递归生成--本质实现全排列&#123; if (n &lt;= 0) //特殊输入处理 return; if (index == n) &#123; print(number); return; &#125; for (int i = 0; i &lt; 10; i++) &#123; number[index] = i + '0'; print_number(number, index + 1, n); &#125;&#125;int main()&#123; print_number(number, 0, 3); return 0;&#125; 总结 书上剑指offer的写法实在看得一脸蒙蔽=-= 只要理解了算法，还是自己写吧[逃]]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-合并两个排序的链表]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路新建一个链表头，然后比较两个链表每个节点之间的大小关系，然后将节点插入到新的链表中 AC代码123456789101112131415161718192021222324252627282930313233class Solution&#123;public: ListNode *Merge(ListNode *pHead1, ListNode *pHead2) &#123; if (pHead1 == NULL) return pHead2; if (pHead2 == NULL) return pHead1; ListNode *pHead3 = new ListNode(-1); ListNode *p1 = pHead1; ListNode *p2 = pHead2; ListNode *p3 = pHead3; while (p1 &amp;&amp; p2) &#123; if (p1-&gt;val &gt;= p2-&gt;val) &#123; p3-&gt;next = p2; p3 = p2; p2 = p2-&gt;next; &#125; else &#123; p3-&gt;next = p1; p3 = p1; p1 = p1-&gt;next; &#125; &#125; p3-&gt;next = (p1 != NULL) ? p1 : p2; return pHead3-&gt;next; &#125;&#125;; 测试运行代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;using namespace std;typedef struct ListNode&#123; int values; struct ListNode *next;&#125; ListNode, *L;void ListInsert(L &amp;node)&#123; L p = node; L q = new ListNode; //q为要插入的节点 q-&gt;next = NULL; // cin &gt;&gt; q-&gt;values; while (p-&gt;next != NULL) &#123; p = p-&gt;next; &#125; q-&gt;next = p-&gt;next; p-&gt;next = q;&#125;void print(L node)&#123; while (node != NULL) &#123; cout &lt;&lt; node-&gt;values &lt;&lt; endl; node = node-&gt;next; &#125;&#125;class Solution&#123;public: ListNode *Merge(ListNode *pHead1, ListNode *pHead2) &#123; if (pHead1 == NULL) return pHead2; if (pHead2 == NULL) return pHead1; ListNode *pHead3 = new ListNode; ListNode *p1 = pHead1; ListNode *p2 = pHead2; ListNode *p3 = pHead3; while (p1 &amp;&amp; p2) &#123; if (p1-&gt;values &gt;= p2-&gt;values) &#123; p3-&gt;next = p2; p3 = p2; p2 = p2-&gt;next; &#125; else &#123; p3-&gt;next = p1; p3 = p1; p1 = p1-&gt;next; &#125; &#125; p3-&gt;next = (p1 != NULL) ? p1 : p2; return pHead3-&gt;next; &#125;&#125;;int main()&#123; L a, b; a = new ListNode; a-&gt;next = NULL; a-&gt;values = 0; b = new ListNode; b-&gt;next = NULL; a-&gt;values = 1; for (int i = 0;i &lt; 3;i++) &#123; ListInsert(a); &#125; for (int i = 0;i &lt; 3;i++) &#123; ListInsert(b); &#125; cout &lt;&lt; "a链表为：" &lt;&lt;endl; print(a); cout &lt;&lt; "b链表为：" &lt;&lt;endl; print(b); Solution so; cout &lt;&lt; "合并后的链表为："&lt;&lt;endl; print(so.Merge(a,b)); return 0;&#125; 提交过程中出现的问题 出现段错误？？？？(我是一脸懵逼)，结果发现是我一开始的判断特殊语句的问题 一开始写的判断语句，然后提交出现段错误，但是我也没有越界访问啊，这个错误暂时不能解决=-=。 1234if (pHead1 == NULL &amp;&amp; pHead2-&gt;next) return pHead2;if (pHead2 == NULL &amp;&amp; pHead1-&gt;next) return pHead1; 提交出现编译错误，因为我的测试代码和这个题目的变量和数据结构的初始化不一样，说实话，提交一个函数有点太难受了=-=]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-反转链表]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，反转链表后，输出新链表的表头。 思路 第一种方法就是设置pre（表示当前节点的上一个节点）， next（表示当前节点的下一个节点），因为我们要反转链表，所以第一个节点经过反转后就是最后一个节点，因此他指向为NULL，因此pre初始化为NULL, 核心代码: next = 当前节点-&gt;next; pre = 当前节点-&gt;next; //也就是开始反转，本来是 1–》2，变成 2–》1 pre = phead; //更新下一个节点的前一个节点 phead = next; //更新当前节点为下一个节点，也就是右移 另外一种思路就是设置两个指针p1,p2，然后设置一个p3指向头结点，注意不是首元节点，过程： head–&gt;1–&gt;2–&gt;3–&gt;4 ====&gt; head–&gt;2–&gt;1–&gt;3–&gt;4…… 最后变成head–&gt;4–&gt;3–&gt;2–&gt;1 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;using namespace std;typedef struct ListNode&#123; int values; struct ListNode *next;&#125; ListNode, *L;void ListInsert(L &amp;node)&#123; L p = node; L q = new ListNode; //q为要插入的节点 q-&gt;next = NULL; // cin &gt;&gt; q-&gt;values; while (p-&gt;next != NULL) &#123; p = p-&gt;next; &#125; q-&gt;next = p-&gt;next; p-&gt;next = q;&#125;void print(L node)&#123; while (node != NULL) &#123; cout &lt;&lt; node-&gt;values &lt;&lt; endl; node = node-&gt;next; &#125;&#125;class Solution&#123;public: ListNode *ReverseList(ListNode *pHead) &#123; if (pHead == NULL || pHead-&gt;next == NULL) return pHead; ListNode *pre = NULL; ListNode *next = NULL; while (pHead) &#123; next = pHead-&gt;next; pHead-&gt;next = pre; pre = pHead; pHead = next; &#125; return pre; &#125; ListNode *ReverseList_2(ListNode *phead) &#123; if (phead == NULL || phead-&gt;next == NULL) return phead; ListNode *p1, *p2; p1 = phead; //p1指向首元节点 p2 = p1-&gt;next; ListNode *p3 = new ListNode; //p3就是相当于头结点 p3-&gt;next = phead; while (p2) &#123; p1-&gt;next = p2-&gt;next; p2-&gt;next = p3-&gt;next; p3-&gt;next = p2; p2 = p1-&gt;next; &#125; return p3-&gt;next; &#125;&#125;;int main()&#123; L a; a = new ListNode; a-&gt;next = NULL; a-&gt;values = 99; for (int i = 0; i &lt; 3; i++) &#123; ListInsert(a); //前插法 &#125; print(a); //打印链表 Solution so; cout &lt;&lt; "反转链表" &lt;&lt; endl; // print(so.ReverseList(a)); print(so.ReverseList_2(a)); return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-链表中倒数第k个结点]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，输出该链表中倒数第k个结点。 思路使用快慢指针，先让快指针先走k步，然后两个指针一起走，当快指针走到尽头的时候，慢指针所指向的节点就是倒数第k个节点，时间复杂度为$O(n)$,空间复杂度为$O(1)$. 需要注意的问题 当k = 0时，或者k大于链表的长度 给出的链表为空 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;typedef struct ListNode&#123; int values; struct ListNode *next;&#125; ListNode, *L;void ListInsert(L &amp;node)&#123; L p = node; L q = new ListNode; //q为要插入的节点 q-&gt;next = NULL; // cin &gt;&gt; q-&gt;values; while (p-&gt;next != NULL) &#123; p = p-&gt;next; &#125; q-&gt;next = p-&gt;next; p-&gt;next = q;&#125;void print(L node)&#123; while (node != NULL) &#123; cout &lt;&lt; node-&gt;values &lt;&lt; endl; node = node-&gt;next; &#125;&#125;class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; if (PListHead == NULL || k == 0) return NULL; ListNode * fast = pListHead; ListNode * low = pListHead; while (k &gt; 0 &amp;&amp; fast) &#123; fast = fast-&gt;next; k--; &#125; if (k &gt; 0) //当K大于0，说明上面的while终止条件是因为fast == NULL,也就是k没有减少0，然后链表就没了，说明k大于链表长度 return NULL; while (fast) &#123; fast = fast-&gt;next; low = low-&gt;next; &#125; return low; &#125;&#125;;int main()&#123; L a; a = new ListNode; a-&gt;next = NULL; a-&gt;values = 99; for (int i = 0; i &lt; 3; i++) &#123; ListInsert(a); //前插法 &#125; print(a); //打印链表 Solution so; a = so.FindKthToTail(a, 2); cout &lt;&lt; a-&gt;values &lt;&lt;endl; return 0;&#125; 总结 这种题挺具有参考意义的，面对不支持随机存取的数据结构时，可以采用快慢指针的做法。]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-调整数组的顺序使奇数位于偶数前面]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路 可以用空间换时间的做法，用两个数组分别保存奇数和偶数，最后在进行合并；时间复杂度为O(n)；空间复杂度为$O(n)$； 使用冒泡排序，这样要注意奇数和奇数，偶数和偶数之间的相对位置不变，也就是保持稳定性，而冒泡排序具有稳定性的特点，不过时间复杂度为$O(n^2)$， 空间复杂度为$O(1)$； 另外一种思路就是使用两个指针，如果第一个指针指向的数是偶数（此时下标为a），另一个指针就找到第一个奇数并指向了他（此时下标为b），那么下标为a~b-1之间的数就都是偶数，然后就把这个区间的数王往前面移动一个单位，然后在把第二个指针指向的数复制到第一个指针指向的位置；时间复杂度：假设一个数需要移动n个，那么n个数字需要移动n*n次，为$O(n^2)$。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution&#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; vector&lt;int&gt;odd; //奇数 vector&lt;int&gt;even; //偶数 for(int i = 0;i &lt; array.size();i++) &#123; if (array[i] % 2 == 1) odd.push_back(array[i]); else &#123; even.push_back(array[i]); &#125; &#125; int len = 0; for (int i = 0;i &lt; odd.size();i++) &#123; array[len++] = odd[i]; &#125; for(int i = 0;i &lt; even.size();i++) &#123; array[len++] = even[i]; &#125; &#125; void reOrderArray_by_bubble_sort(vector&lt;int&gt;&amp;array) &#123; int m = array.size()-1; while (m &gt; 0) &#123; for(int i = 0;i &lt; m;i++) &#123; if (array[i] % 2 == 0 &amp;&amp; array[i+1] %2 ==1) &#123; int temp = array[i]; array[i] = array[i+1]; array[i+1] = temp; &#125; &#125; m--; &#125; &#125;&#125;;int main()&#123; int arr[7] = &#123;1, 2, 3, 4, 5, 6, 7&#125;; vector&lt;int&gt; v(arr, arr + 7); Solution so; so.reOrderArray_by_bubble_sort(v); for (int i = 0; i &lt; v.size(); i++) cout &lt;&lt; v[i] &lt;&lt; endl; return 0;&#125; 总结 面对一些排序问题，我们会想到各种各样的排序算法，这时候需要考虑其空间复杂度，时间复杂度和其稳定性]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-数值的整数次方]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%2F</url>
    <content type="text"><![CDATA[题目描述 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 保证base和exponent不同时为0 思路 0的0次方没有意思 注意数的负数次方变成倒数 任何数的0次方等于1 0的负数次方是没有意义的，但是我的代码中只要base是0，就返回0，但是实际上0的负数次本质上是没有任何意义的。 double base判断base是否等于0时不能直接判断base==0，因为计算机中浮点数是不精确存储的，判断依据：两个数之差的绝对值小于一个很小的数，我们就能认为这个两个数相等 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;bool equal_zero(double a, double b)&#123; //两个数之差的绝对值小于一个很小的数，我们就能认为这个两个数相等 if (a-b &lt; -0.000001 &amp;&amp; a-b &gt; 0.000001) return true; else return false;&#125;class Solution&#123;public: double Power(double base, int exponent) &#123; int temp = abs(exponent); if (equal_zero(base, 0.0)) &#123; return 0; &#125; double res = 1; for (int i = 0; i &lt; temp; i++) &#123; res = res * base; &#125; if (exponent &gt;= 0) return res; else return 1 / res; &#125;&#125;;int main()&#123; Solution so; cout &lt;&lt; so.Power(2, -3); return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-二进制中1的个数]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路 遇到的问题就是我再一次想把这个数字转换为二进制码，但是其实计算机已经帮我们做了这个过程，转换为二进制数其实大多应用于高精度中 鉴于这个情况，我们可以用位运算，从而比较出该数字的每一位1，但是需要注意陷入死循环的问题，只要非空非0，循环就可以一直继续 至于代码中设置退出循环的条件就是flag超出unsigned int所能表示的数据范围，就会发生截断，然后只保留32位，也就是unsigned int占4个字节，变成0然后循环退出。 AC代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;class Solution&#123;public: int NumberOf1(int n) &#123; int count = 0; unsigned int flag = 1; int times = 0; while (flag) &#123; if (flag &amp; n) count++; flag = flag &lt;&lt; 1; cout &lt;&lt; flag &lt;&lt; endl; times++; &#125; // cout &lt;&lt; "次数为" &lt;&lt; times &lt;&lt;endl; return count; &#125;&#125;;int main()&#123; Solution so; cout &lt;&lt;so.NumberOf1(13)&lt;&lt;endl;&#125; 我写不出来的算法规律：一个数减去1然后与原来的数进行与运算，会将这个数最右边的1变成0；（虽然写不出，但还是学学嘛=-=）这种算法就是一个数里面有多少个1就循环多少次， 12345678910int NumberOf1_2(int n) &#123; int count = 0; while (n) &#123; count++; n = (n-1) &amp; n; &#125; return count; &#125; 遇到的问题&amp;总结 unsigned int与int做运算时，Int会强制转换为无符号整数 1234567unsigned int a = 1,int b = -2;// a b 都是无符号整数 这样编译不了，可能是有新版本吧，unsigned int a = 1;int b = -2;int c = -2;cout &lt;&lt; b &lt;&lt; endl; //-2if (a + c &gt; 0) //因此b,c在计算机中是以补码的形式存放，0xfffffff(1110) ==&gt;无符号表示的就是2^32-2 cout &lt;&lt; a + b &lt;&lt; endl; //4294967295 ==&gt;&gt;2^32-1 注意一个变量的类型，无符号整数和有符号整数此外，这个16进制数表示的负数的补码，正数就无所谓=-= 12345678910int res = 0xffffffff;unsigned int rea = 0xffffffff;cout &lt;&lt; 0xffffffff &lt;&lt;endl;cout &lt;&lt; res &lt;&lt;endl;cout &lt;&lt; rea &lt;&lt;endl;/*4294967295-14294967295*/ 遇到判断二进制数，不用在自己转为二进制数了，计算机底层会帮我们处理完成的，只有在高精度时才需要进行这样的处理 条件判断只要是不为0或者不为空就可以运行 最后一个问题就是左移32或者以上时，编译器如何处理这个越界情况,上代码=-= 12345678910111213unsigned int test1 = 2147483648;test1 = test1 &lt;&lt; 1;cout &lt;&lt; "test1: " &lt;&lt;test1 &lt;&lt;endl;unsigned int test = 1;test = (test &lt;&lt; 32);unsigned int i = 1;cout &lt;&lt; "test2 :" &lt;&lt;test &lt;&lt; endl;cout &lt;&lt;"test3:" &lt;&lt; (i&lt;&lt;32) &lt;&lt;endl;/*test1: 0test2 :1test3:1*/ 对上述代码的总结： 首先这个基于g++编译器 其次，如果对于左移1位的数，越界溢出按照截断处理（就是只是保留低位的二进制数） 但是如果左移32或者以上g++编译器就会默认处理为：左移位数与该数据类型位数做取模运算，例如无符号整数1 &lt;&lt; 32，那么32 % 32(无符号整数4个字节) = 0，也就是不移动，结果等于1]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-矩形覆盖]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 注意问题 本例测试样例中，当N = 2时，输出为2种。。。 假设f[n]表示当参数为n的方法数，则f[n] = f[n-1] + f[n-2]….斐波那契 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class Solution &#123;public: int rectCover(int number) &#123; // if (number &lt;=0 ) // return 0; // if (number &lt; 3) // return 1; //样例中2输出为2，正方形横竖放不是一个道理吗 if (number &lt; 0) return 0; if (number &lt; 3) return number; int res = 0; int a = 1; int b = 2; //对应于第二项 for (int i = 3;i &lt;= number;i++) &#123; res = a+b; a = b; b = res; &#125; return res; &#125;&#125;;int main()&#123; Solution so; cout &lt;&lt; so.rectCover(3) &lt;&lt;endl; cout &lt;&lt; so.rectCover(4) &lt;&lt;endl; cout &lt;&lt; so.rectCover(5) &lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-变态跳台阶]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 规律就是前面每一个步的累加的值然后加1 AC代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class Solution &#123;public: int jumpFloorII(int number) &#123; if (number &lt;3) return number; int a = 3; //1+2 int res = 0; //找到之间的规律，然后实现这种规律的本质是dp for (int i = 3;i &lt;= number;i++) &#123; res = a; res++; a += res; &#125; return res; &#125;&#125;;int main()&#123; Solution so; cout &lt;&lt;so.jumpFloorII(5) &lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-跳台阶]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 AC代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class Solution &#123;public: int jumpFloor(int number) &#123; if (number &lt; 3) return number; int a = 1; int b = 2; int value; for (int i = 3;i &lt;= number; i++) &#123; value = a + b; a = b; b = value; &#125; return value; //本题用dp也行，只是不知道number的取值，申请一个空间也没必要，而且dp的过程值也没有必要保存下 &#125;&#125;;int main()&#123; Solution so; cout &lt;&lt; so.jumpFloor(4); return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python网络爬虫-爬取虎扑步行街数据]]></title>
    <url>%2Fpython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-%E7%88%AC%E5%8F%96%E8%99%8E%E6%89%91%E6%AD%A5%E8%A1%8C%E8%A1%97%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前言由于虎扑页面的限制，因为访问虎扑步行街的第11个页面就需要用户进行登录，鉴于此时技术还没有学全，只能爬取1到10的页面。 抓取什么数据 帖子名称 帖子链接 发帖人 发帖人链接 发帖时间 帖子回复数 帖子浏览数 最后回复帖子的人 最后回复的时间 如何抓取数据 首先我们发现这个页面是用gzip进行压缩的，gzip是用utf-8进行编码的，也就是我们抓取的页面是用utf-8编码的，而r.text返回的是unicode编码的字符串，如果我们直接用就会出现乱码，因此，我们用r.content，返回的bytes数据（抓取音频，文件），然后将这个页面从utf-8解码为unicode编码 12html = r.contenthtml = html.decode('utf-8') #将utf-8解码为unicode 抓取数据对应的字段的html标签(代码中看) 用Mongodb存放抓取到的数据 需要注意的问题，就是可能会出现本来在第一页的帖子，然后凉了啥的，被顶到了第二页，那么这时候就不能存放在数据库中，所以每次插入数据要进行判断一下 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import requestsfrom bs4 import BeautifulSoupimport timefrom pymongo import MongoClientdef get_page(link): data_list = [] headers = &#123; "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0" &#125; r = requests.get(link, headers=headers) html = r.content html = html.decode('utf-8') #将utf-8解码为unicode soup = BeautifulSoup(html, 'lxml') for_list = soup.find('ul', class_="for-list") for_list = for_list.find_all('li') for each_for in for_list: # 帖子名称 for_name = each_for.find('div', class_="titlelink box").a.text.strip() # 帖子链接 for_link = each_for.find('div', class_="titlelink box").a['href'] for_link = 'https://bbs.hupu.com' + for_link # 作者 for_writer = each_for.find('div', class_="author box").a.text.strip() # 作者链接 for_writer_link = each_for.find('div', class_= "author box").a['href'] # 帖子创建时间 for_createtime = each_for.find('div', class_= "author box") # 获取节点的所有子节点，然后发现时间在列表中第6项 for_createtime = for_createtime.contents for_createtime = for_createtime[5].text.strip() # 回复数 for_reply_numbers = each_for.find('span', class_= "ansour box").text.split('/')[0].strip() # 浏览数 for_see_numbers = each_for.find('span', class_= "ansour box").text.split('/')[1].strip() # 最后回复用户 for_last_reply_user = each_for.find('div', class_="endreply box").span.text.strip() #最后回复时间 for_last_reply_time = each_for.find('div', class_="endreply box").a.text.strip() data_list.append([for_name, for_link, for_writer, for_writer_link, for_createtime, for_reply_numbers,for_see_numbers, for_last_reply_user,for_last_reply_time]) return data_listclass sort_by_Mongodb: def __init__(self, db_host, db_port, db_name, coll_name): self.db_host = db_host self.db_port = db_port self.db_name = db_name self.coll_name = coll_name self.client = MongoClient(host=self.db_host, port=self.db_port) self.db = self.client[self.db_name] self.coll = self.db[self.coll_name] def update(self, query, insert_data): # query表示查询条件, insert_data表示更新的数据，其实在本例中就是要插入的数据 self.coll.update_one(query, &#123;'$set':insert_data&#125;, upsert=True) # upsert (optional): If True, perform an insert if no documents match the filter.def main(): link = "https://bbs.hupu.com/bxj-" # 超过第10个页面就需要登录了。。。。 for i in range(1,11): link_temp = link + str(i) data_list = get_page(link_temp) #返回的是列表的列表 a = sort_by_Mongodb("localhost", 27017, "hupu", "buxingjie") for each in data_list: insert_dict = &#123; "帖子名称": each[0], "帖子链接": each[1], "发帖人": each[2], "发帖人链接": each[3], "发帖时间": each[4], "贴子回复数": each[5], "帖子浏览数": each[6], "最后回复帖子的人": each[7], "最后回复时间": each[8] &#125; # 帖子链接肯定是不一样的，因此把这个作为筛选条件 a.update(&#123;"帖子链接": each[1]&#125;, insert_dict) print("第"+ str(i)+ "页面存取完成！！！！！！！！！！！") time.sleep(2)if __name__ == "__main__": main() 结果截图 一共抓取到1151条贴子，对于10个页面来说，好像差不多吧~]]></content>
      <categories>
        <category>python网络爬虫</category>
      </categories>
      <tags>
        <tag>python网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-斐波那契序列]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39 AC代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;class Solution &#123;public: int Fibonacci(int n) &#123; //重复计算的东西太多 // int res[2] = &#123;0,1&#125;; // if (n &lt; 2) // return res[n]; // return Fibonacci(n-1) + Fibonacci(n-2); int dp[39]; dp[0] = 0; dp[1] = 1; for (int i = 2;i &lt;=n;i++) &#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n]; &#125;&#125;;int main()&#123; int n = 39; Solution a; cout &lt;&lt; a.Fibonacci(n); return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-旋转数组的最小数字]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路 直接遍历，但是时间复杂度为O(n) 根据旋转数组的特点，可以分为将整个序列分成两个递增数组，而最小值就是这个两个数组的分割线，由于他们是有序的，因而使用二分查找 如何二分：用p1和p2指针指向序列的首尾，如果中间值大于等于p1所以指向的值，说明中间值处于前面的递增序列中，因此p1指针更新为中间值的下标；若中间值小于等于p2所指向的值，说明中间值处于后面的递增序列中，因此p2更新为中间值的下标 特殊情况：如果旋转后的数组还是数组本身 特殊情况：中间值等于首等于尾，这样就不能区分中间值处于前面的序列还是后面的序列，算法退化为顺序遍历 时间复杂度约为O(logn) AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; if (rotateArray.size() == 0) return 0; //如果是数组本身 int p1 = 0; int p2 = rotateArray.size()-1; int res = p1; //当第一个数小于最后一个数，那么循环进不去，return while (rotateArray[p1] &gt;= rotateArray[p2]) &#123; if(p2 - p1 == 1) &#123; res = p2; break; &#125; res = (p1 + p2) /2; if (rotateArray[res] == rotateArray[p1] &amp;&amp; rotateArray[p1] == rotateArray[p2]) &#123; //特殊情况 1 0 1 1 1 只能顺序查找 int temp = rotateArray[p1]; for (int i = p1 + 1; i &lt;= p2;i++) &#123; if (temp &gt; rotateArray[i]) &#123; temp = rotateArray[i]; &#125; &#125; return temp; //返回最小值 &#125; else if (rotateArray[res] &gt;= rotateArray[p1]) //说明中间值在前面的递增序列中 &#123; p1 = res; &#125; else if (rotateArray[res] &lt;= rotateArray[p2]) //说明中间值在后递增序列中 &#123; p2 = res; &#125; &#125; return rotateArray[res]; &#125;&#125;;int main()&#123; int data[5] = &#123;1,0,1,1,1&#125;; vector&lt;int&gt;v(data, data+5); Solution a; cout &lt;&lt; a.minNumberInRotateArray(v); return 0;&#125; 总结 凡是含有特殊性质的数据结构，肯定会有优化的思想存在=-=]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-用两个栈实现队列]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型 思路一个栈用来存放，另一个栈用来输出，输出的时候注意要将输出栈的全部内容输出完毕后才能填充数据 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; while (1) &#123; if (!stack2.empty()) &#123; int y = stack2.top(); stack2.pop(); return y; &#125; while (!stack1.empty()) &#123; stack2.push(stack1.top()); stack1.pop(); &#125; &#125; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;;int main()&#123; Solution a; cout &lt;&lt; "11122" &lt;&lt; endl; a.push(1); a.push(2); cout &lt;&lt; a.pop() &lt;&lt; endl; a.push(3); cout &lt;&lt; a.pop() &lt;&lt;endl; cout &lt;&lt; a.pop() &lt;&lt;endl; cout &lt;&lt; "111" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-重建二叉树]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%E4%B9%8B%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) &#123; val = x; left = NULL; right = NULL; &#125;&#125; TreeNode;TreeNode *fun(int *pre, int *mid, int len)&#123; if (len == 0) return NULL; int index; TreeNode *p = new TreeNode(pre[0]); for (int i = 0; i &lt; len; i++) &#123; if (pre[0] == mid[i]) &#123; index = i; break; &#125; &#125; p-&gt;left = fun(pre + 1, mid, index); p-&gt;right = fun(pre + index + 1, mid + index + 1, len - index - 1); return p;&#125;// TreeNode *head;class Solution&#123;public: TreeNode *reConstructBinaryTree(vector&lt;int&gt; pre, vector&lt;int&gt; vin) &#123; if (pre.size() == 0 || vin.size() == 0) return nullptr; int *pre_tree = new int[pre.size()]; int *vin_tree = new int[vin.size()]; for (int i = 0; i &lt; pre.size(); i++) &#123; pre_tree[i] = pre[i]; vin_tree[i] = vin[i]; &#125; return fun(pre_tree, vin_tree, pre.size()); // return fun(pre, vin, 0, pre.size(), 0,vin.size()); &#125;&#125;;void print(TreeNode *root)&#123; //后序遍历 if (root != NULL) &#123; print(root-&gt;left); print(root-&gt;right); cout &lt;&lt; root-&gt;val; &#125;&#125;int main()&#123; Solution a; int Tree_pre[8] = &#123;1,2,4,7,3,5,6,8&#125;; int Tree_vin[8] = &#123;4,7,2,1,5,3,8,6&#125;; vector&lt;int&gt;pre(Tree_pre, Tree_pre+8); //用数组初始化向量 vector&lt;int&gt;vin(Tree_vin, Tree_vin+8); TreeNode *p = a.reConstructBinaryTree(pre, vin); print(p); return 0;&#125; 总结 感觉这个oj好麻烦，写个函数的参数都要严格要求 对于二叉树的构建这只是个简单的题目=-=，好像没啥总结的。。]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-从尾到头打印链表]]></title>
    <url>%2F%E9%94%AE%E5%80%BCoffer%E4%B9%8B%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;typedef struct ListNode&#123; int values; struct ListNode *next;&#125; ListNode, *L;void ListInsert(L &amp;node)&#123; L p = node; L q = new ListNode; //q为要插入的节点 q-&gt;next = NULL; // cin &gt;&gt; q-&gt;values; while (p-&gt;next != NULL) &#123; p = p-&gt;next; &#125; q-&gt;next = p-&gt;next; p-&gt;next = q;&#125;void print(L node)&#123; while (node != NULL) &#123; cout &lt;&lt; node-&gt;values &lt;&lt; endl; node = node-&gt;next; &#125;&#125;class Solution&#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode *head) &#123; vector&lt;int&gt; result; stack&lt;int&gt; s; if (head == NULL) return result; while (head != NULL) &#123; s.push(head-&gt;values); head = head-&gt;next; &#125; while (!s.empty()) &#123; // cout &lt;&lt; s.top(); result.push_back(s.top()); s.pop(); &#125; return result; &#125; //使用递归实现 void fun(L node) &#123; if (node != NULL) &#123; fun(node-&gt;next); cout &lt;&lt; node-&gt;values &lt;&lt; endl; &#125; &#125;&#125;;int main()&#123; L a; a = new ListNode; a-&gt;next = NULL; a-&gt;values = 99; for (int i = 0; i &lt; 3; i++) &#123; ListInsert(a); &#125; print(a); cout &lt;&lt; "反向输出" &lt;&lt; endl; Solution A; A.fun(a); return 0;&#125; 总结 用栈本质上都可以用递归输出]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-替换空格]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路如果从前面开始遍历然后替换，这样会导致后面的字符被替换，所以要将后面的字符往后移动2个单位，替换一个空格，假设后面移动的字符为n，那么复杂度为O(n)，如果有N个空格，那么复杂度就是O(N*n); 如果从后面开始遍历然后替换，先遍历字符串统计字符串中空格的个数，这样原来字符串的长度len+空格数*2就是新的字符串的长度，这样用两个指针分别指向两个字符串的末尾（p1指向原来字符串的末尾，p2指向新字符串的末尾），然后从原来字符串的末尾进行遍历，将p1指向的内容复制给p2.整个过程只需要遍历原来的字符串，时间复杂度O(n). AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;class a&#123;public: void solution(char * str, int length) &#123; if (str == NULL &amp;&amp; length &lt;=0) return; int p1; int p2; int number_size = 0; for (int i = 0;i &lt; length;i++) &#123; if (str[i] == ' ') number_size++; &#125; p2 = length + number_size * 2; p1 = length; for(int i = length; i &gt; 0; i--) &#123; if (str[p1-1] != ' ') &#123; str[p2-1] = str[p1-1]; p2--; p1--; &#125; else &#123; str[p2-1] = '0'; str[p2-2] = '2'; str[p2-3] = '%'; p1--; p2 = p2-3; &#125; &#125; // printf("%s", str); &#125;&#125;;int main()&#123; char *str = "we are happy."; // char str[] = "we are happy."; 注意这里不能用str[],这样只会分配14字节的长度，因为要扩展，就是出现数组越界，栈溢出 a A; A.solution(str, 14); return 0;&#125; 总结 对于字符串的操作，要判断是不是空的，要学会转换视角 如果要合并两个数组或者字符串，如果从前往后会重复移动多个数字，那么可以考虑从后往前进行合并 对于字符串的一些新的认识 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int main()&#123; char str1[] = "hello"; char str2[] = "hello"; char * str3 = "hello"; char * str4 = "hello"; if (str1 == str2) &#123; cout &lt;&lt; "yes" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "no" &lt;&lt;endl; &#125; if (str3 == str4) &#123; cout &lt;&lt; "yes" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "no" &lt;&lt;endl; &#125;// c++中为了节省内存，将常量字符串放在单独的一个内存区域，当几个指针赋值给相同的常量字符串，他们实际上会指向相同的内存地址// str1 str2是两个字符串数组，为他们分配了6个字节，注意每个字符串后面有\0结束标志，然后把hello赋值到数组中，这是两个初始地址不同的数组，所以str1和str2是两个不同的值 return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-二维数组中的查找]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路： 暴力查找，复杂度O(n*m) 数组在某种程度是有序的，可以从右上角或者左下角开始判断筛选，逐渐缩小范围，最坏的复杂度O(n + m) AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution&#123;public: // bool Find(int target, vector&lt;vector&lt;int&gt;&gt; array) &#123; // for (int i = 0;i &lt; array.size();i++) // &#123; // for (int j = 0;j &lt; array[i].size();j++) // &#123; // if (target == array[i][j]) // return true; // &#125; // &#125; // return false; // &#125; bool Find(int target, vector&lt;vector&lt;int&gt;&gt; array) &#123; int row = array.size(); //行数 int col = array[row-1].size(); //列数 注意这里求要将row-1 //cout &lt;&lt; row &lt;&lt; " " &lt;&lt; col &lt;&lt; endl; if (row &gt;0 &amp;&amp; col &gt;0) &#123; row = 0; col = col-1; while (row &lt;= array.size()-1 &amp;&amp; col &gt;= 0) &#123; if (array[row][col] == target) &#123; //cout &lt;&lt; "找到了e" &lt;&lt;endl; return true; &#125; else if (array[row][col] &gt; target) col--; else &#123; row++; &#125; &#125; &#125; //cout &lt;&lt; "没有" ; return false; &#125;&#125;; 总结： 好像没什么可以总结的，学到的就是vector定义一个二维数组，vector&lt;vector&lt;int&gt;&gt; array(4, vector&lt;int&gt;(4)); //定义一个二维数组4x4]]></content>
      <categories>
        <category>OJ</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++之vector的使用]]></title>
    <url>%2Fc%2B%2B%E4%B9%8Bvector%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[内置函数 at(size_type n)函数 返回对向量中为位置n处元素的引用,reference或者如果向量中元素为const，则返回const reference. 12345678910// vector的函数at返回一个容器内容对象的引用vector &lt;int&gt;a(8); for (int i = 0;i &lt; 8;i++)&#123; a.at(i) = i;&#125;for (int i = 0; i&lt; a.size();i++)&#123; cout &lt;&lt; a.at(i) &lt;&lt;endl;&#125; 初始化 用数组初始化 123456int Tree_pre[8] = &#123;1,2,4,7,3,5,6,8&#125;;int Tree_vin[8] = &#123;4,7,2,1,5,3,8,6&#125;;vector&lt;int&gt;pre(Tree_pre, Tree_pre+8); //用数组初始化向量vector&lt;int&gt;vin(Tree_vin, Tree_vin+8); 用vector初始化二维数组（以下方法是基于c++11标准，c++98不支持） 12345// vector&lt;vector&lt;int&gt;&gt;arr(3, vector&lt;int&gt;(3));// arr[0] = &#123;1,2,3&#125;;// arr[1] = &#123;4,5,6&#125;;// arr[2] = &#123;7,8,9&#125;;vector&lt;vector&lt;int&gt;&gt; arr = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;; 遍历vector 使用迭代器 12for (vector&lt;int&gt;::iterator it = res.begin(); it != res.end(); it++) cout &lt;&lt; *it &lt;&lt; " "; 判断某个元素是否在vector中 12if (find(res.begin(), res.end(), str) == res.end()) //判断重复 res.push_back(str); 对vector进行排序，需要注意的是，当vector中是自定义的类型，需要重载== 1sort(res.begin(), res.end());]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python网络爬虫之数据存储]]></title>
    <url>%2Fpython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[数据存储的两种方式 存储在文件中，包括TXT文件和CSV文件 存储在数据库中，包括MySQL关系型数据库和MongoDB数据库 文件打开方式 读写方式 可否读写 若文件不存在 写入方式 w 写入 创建 覆盖写入 w+ 读取+写入 创建 覆盖写入 a 写入 创建 追加写入 a+ 读取+写入 创建 追加写入 r 读取 报错 不可写入 r+ 读取+写入 报错 覆盖写入 12345678910111213141516171819202122232425262728293031323334353637# output = '\t'.join(['name', 'age', 'gender'])# print(output)# # name age genderimport csvdef txt(): with open('学习强国.txt', "r", encoding='utf-8') as f: result = f.read().splitlines(keepends=True) # keepends表示保留换行符，返回一个列表 # result = f.read() print(result) f.close()def Csv(): # with open('test.csv', 'r', encoding='utf-8') as f: with open('test.csv', newline='',encoding='utf-8-sig') as f: csv_read = csv.reader(f) for row in csv_read: print(row)"""在utf-8编码文件中BOM在文件头部，占用三个字节，用来标示该文件属于utf-8编码['\ufeff1', '2', '3', '4', '5']['11', '22', '33', '44', '55']['111', '222', '333', '444', '555']"""def Write_csv(): list_data = [1,2,4,5] with open('write_csv.csv', 'a+', encoding='utf-8') as f: csv_writer = csv.writer(f) csv_writer.writerow(list_data) # 将列表中的数组写入一行中 if __name__ == "__main__": # pass # Csv() Write_csv() 将数据存放在mysql数据库 创建数据库create database scraping; 切换数据库use scraping; 创建数据表create table 表名(column_name1 column_type1, column_name2 column_type2); 查看表的结构describe 表名; 在数据表中插入数据insert into urls (url, content) values (&quot;www.baidu.com&quot;, &quot;这是内容&quot;); 查看数据表 select * from urls; select url, content from urls where id =1; select * from urls where id=1 删除数据delete from urls where ulr=&quot;www.baidu.com&quot;;如果不加where子句，就会将整个数据表全部删除 插入数据insert into urls (url,content) values (&quot;www.baidu.com&quot;, &quot;陈晓健&quot;);因为之前创建的第一条数据被删除了，然后现在重新创建了新的一条，就默认从第二开始算起。 修改数据update urls set url=&quot;www.google.com&quot;,content=&quot;google&quot; where id =2; python操作mysql 安装pymysql库pip install pymysql 连接成功并操作数据库 1234567891011121314151617181920212223242526import pymysql# 打开数据库连接# db = pymysql.connect(host = "localhost", user = "root", password = 1234, db= "urls")config = &#123; "host": "localhost", "user": "root", "password": "1234", "db": "scraping"&#125;# **参数，表示用字典的形式导入参数， *参数则是默认以元组的方式db = pymysql.connect(**config)# cursor（）方法获取操作游标cursor = db.cursor()# 要注意sql语句的格式sql = "insert into urls (url, content) values ('www.baidu.com', '百度');" try: cursor.execute(sql) #提交到数据库 db.commit() print("写入成功")except: db.rollback()db.close() 爬取博客的文章链接和标题然后存储在mysql中 123456789101112131415161718192021222324252627282930313233343536373839404142434445import pymysqlimport requestsfrom bs4 import BeautifulSoup# 打开数据库连接# db = pymysql.connect(host = "localhost", user = "root", password = 1234, db= "urls")config = &#123; "host": "localhost", "user": "root", "password": "1234", "db": "scraping"&#125;# **参数，表示用字典的形式导入参数， *参数则是默认以元组的方式db = pymysql.connect(**config)# cursor（）方法获取操作游标cursor = db.cursor()"""# 要注意sql语句的格式sql = "insert into urls (url, content) values ('www.baidu.com', '百度');" try: cursor.execute(sql) #提交到数据库 db.commit() print("写入成功")except: db.rollback()db.close()"""link = "http://www.santostang.com"r = requests.get(link)soup = BeautifulSoup(r.text, 'lxml')title_list = soup.find_all('h1', class_="post-title")for eachone in title_list: url = eachone.a['href'] content = eachone.a.text.strip()# 注意values ('','')需要加引号表示字符串 sql = "insert into urls (url, content) values ('&#123;url&#125;', '&#123;content&#125;');".format(url= url, content= content) try: cursor.execute(sql) db.commit() print("插入成功") except: db.rollback()db.close() 存储到MongoDB数据库中 安装 data用来存放数据库， log用来存放数据库的操作记录 启动方式 使用MongoDB的程序启动方式 启动程序，先启动mongd.exe,在启动mongo.exe;当mongod.exe被关闭后，mongo.exe就无法连接数据库 show dbs查看数据库 ​ 以windows服务打开 切换到MongoDB安装目录的bin文件夹 cmd方式打开，输入mongod.exe --logpath &quot;log的路径&quot; --logappend--dbpath &quot;db的路径&quot; --serviceName &quot;MongoDB&quot; --install windows服务运行模式已经安装完成，启动服务net start MongDB MongoDB与SQL的区别和联系 SQL术语 MongoDB术语 解释 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table_joins MongoDB不支持表的连接 primary_key primary_key 主键，MongoDB自动将_id字段设置为主键 MongoDB的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型 使用python操作MongoDB 首先连接客户端 然后连接数据库 最后连接对应的集合（也就是表） pip install pymongo安装操作库 创建数据库 数据库只有在内容插入后才会创建，也就是说数据库创建后还要创建一个集合并插入一个文档，数据库才可以创建，也就是说，如果你现在去判断该数据库是否存在，答案是否定的 12345def db_created(db_name): client = MongoClient(host="localhost", port=27017) db_name = client[db_name] print("创建成功！") 判断数据库是否存在 123456def db_existed(db_name): client = MongoClient(host="localhost", port=27017) #返回所有的数据库名字的列表 db_list = client.list_database_names() if db_name in db_list: return True 创建集合 集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建。 12345678def collection_create(collection_name): # 连接客户端 client = MongoClient(host="localhost", port=27017) # 连接数据库 my_db = client['runoodbd'] # 连接数据库的集合 my_collection = my_db[collection_name] print("创建成功") 判断集合是否存在 123456def collection_existed(collection_name): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] collection_name_list = db.list_collection_names() if collection_name in collection_name_list: return True 插入文档 insert_one(dict)：插入一条文档，参数是字典对，返回一个InsertOneResult，该对象有inserted_id属性，表示插入文档的id值 1234567891011121314151617# 插入数据def insertone(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites'] data = &#123; "name": "runood", "alexa": "10000", "url": "https://www.runood.com" &#125; x = coll.insert_one(data) print(x) print(x.inserted_id) """ &lt;pymongo.results.InsertOneResult object at 0x0000026BFCBD1508&gt; 5e16d475e26935b6620008c9 """ insert_many(字典列表)：插入多个文档，参数是字典列表，返回一个InsertManyResult对象，该对象有inserted_ids属性 12345678910111213141516171819# 插入多条数据def insertmany(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites'] data = [ &#123; "name": "Taobao", "alexa": "100", "url": "https://www.taobao.com" &#125;, &#123; "name": "QQ", "alexa": "101", "url": "https://www.qq.com" &#125;, &#123; "name": "Facebook", "alexa": "10", "url": "https://www.facebook.com" &#125;, &#123; "name": "知乎", "alexa": "103", "url": "https://www.zhihu.com" &#125;, &#123; "name": "Github", "alexa": "109", "url": "https://www.github.com" &#125; ] x = coll.insert_many(data) print(x) print(x.inserted_ids) """ &lt;pymongo.results.InsertManyResult object at 0x00000174A8DD5488&gt; [ObjectId('5e16d7771b8e53410870a1f7'), ObjectId('5e16d7771b8e53410870a1f8'), ObjectId('5e16d7771b8e53410870a1f9'), ObjectId('5e16d7771b8e53410870a1fa'), ObjectId('5e16d7771b8e53410870a1fb')] """ 指定_id插入多个文档 12345678910111213141516171819def appoint_id_insert(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] data = [ &#123; "name": "Taobao", "alexa": "100", "url": "https://www.taobao.com", "_id": 1 &#125;, &#123; "name": "QQ", "alexa": "101", "url": "https://www.qq.com", "_id": 2 &#125;, &#123; "name": "Facebook", "alexa": "10", "url": "https://www.facebook.com", "_id": 3 &#125;, &#123; "name": "知乎", "alexa": "103", "url": "https://www.zhihu.com" , "_id": 4&#125;, &#123; "name": "Github", "alexa": "109", "url": "https://www.github.com", "_id":5 &#125; ] x = coll.insert_many(data) print(x) print(x.inserted_ids)"""&lt;pymongo.results.InsertManyResult object at 0x00000254D74F7748&gt;[1, 2, 3, 4, 5]""" 查询文档 查询一条数据find_one()，返回集合中第一条数据 1234567def findone(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] print(coll.find_one()) findone()# &#123;'_id': 1, 'name': 'Taobao', 'alexa': '100', 'url': 'https://www.taobao.com'&#125; 查询集合中所有数据find() 12345678910111213def findall(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] for eachone in coll.find(): print(eachone)"""&#123;'_id': 1, 'name': 'Taobao', 'alexa': '100', 'url': 'https://www.taobao.com'&#125;&#123;'_id': 2, 'name': 'QQ', 'alexa': '101', 'url': 'https://www.qq.com'&#125;&#123;'_id': 3, 'name': 'Facebook', 'alexa': '10', 'url': 'https://www.facebook.com'&#125;&#123;'_id': 4, 'name': '知乎', 'alexa': '103', 'url': 'https://www.zhihu.com'&#125;&#123;'_id': 5, 'name': 'Github', 'alexa': '109', 'url': 'https://www.github.com'&#125;""" 查询指定字段的数据，将要返回的字段对应值设置为1，除了_id字段外，其他字段同时指定为0， 1则会报错 12345678910111213def print_some_field(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] for eachone in coll.find(&#123;&#125;, &#123;'name': 1, "alexa":1, "_id":0&#125;): print(eachone)"""&#123;'name': 'Taobao', 'alexa': '100'&#125;&#123;'name': 'QQ', 'alexa': '101'&#125;&#123;'name': 'Facebook', 'alexa': '10'&#125;&#123;'name': '知乎', 'alexa': '103'&#125;&#123;'name': 'Github', 'alexa': '109'&#125;""" 根据指定条件查询 123456789def find_by_special_condition(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] special_condition = &#123;"name": "QQ"&#125; # print(coll.find(special_condition)) for x in coll.find(special_condition): print(x) # &#123;'_id': 2, 'name': 'QQ', 'alexa': '101', 'url': 'https://www.qq.com'&#125; 修饰符查询大于修饰符$gt 12345678910111213def higher_find(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] condition = &#123;"name": &#123;'$gt': 'H'&#125;&#125; for x in coll.find(condition): print(x) # 返回name字段第一个字母ASCii的值大于“H"数据，大于的修饰符为&#123;"$gt":"H"&#125;"""&#123;'_id': 1, 'name': 'Taobao', 'alexa': '100', 'url': 'https://www.taobao.com'&#125;&#123;'_id': 2, 'name': 'QQ', 'alexa': '101', 'url': 'https://www.qq.com'&#125;&#123;'_id': 4, 'name': '知乎', 'alexa': '103', 'url': 'https://www.zhihu.com'&#125;""" 使用正则表达式查询，只用于搜索字符串的字段，$regex 12345678def find_by_re(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] re_condition = &#123;"name" : &#123;"$regex" : "^G"&#125;&#125; for x in coll.find(re_condition): print(x) # &#123;'_id': 5, 'name': 'Github', 'alexa': '109', 'url': 'https://www.github.com'&#125; 返回指定条数记录， limit()方法 12345678910111213def find_limit(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] for x in coll.find().limit(3): print(x)"""find_limit()&#123;'_id': 1, 'name': 'Taobao', 'alexa': '100', 'url': 'https://www.taobao.com'&#125;&#123;'_id': 2, 'name': 'QQ', 'alexa': '101', 'url': 'https://www.qq.com'&#125;&#123;'_id': 3, 'name': 'Facebook', 'alexa': '10', 'url': 'https://www.facebook.com'&#125;""" 修改文档 update_one()方法：第一个参数为查询的条件，第二个参数为要修改的字段，如果查找到的匹配数据多于一条，则会修改第一条， 参数upsert=True表示当没有查询到符合的数据，就新数据插入 1234567891011121314151617181920def updateone(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] myquery = &#123;"alexa": "100"&#125; newvalue = &#123;"$set": &#123;"alexa": "99"&#125;&#125; # coll.update_one(myquery, newvalue) coll.update_one(myquery, newvalue) # 打印修改后的集合 for x in coll.find(): print(x)"""&#123;'_id': 1, 'name': 'Taobao', 'alexa': '99', 'url': 'https://www.taobao.com'&#125;&#123;'_id': 2, 'name': 'QQ', 'alexa': '101', 'url': 'https://www.qq.com'&#125;&#123;'_id': 3, 'name': 'Facebook', 'alexa': '10', 'url': 'https://www.facebook.com'&#125;&#123;'_id': 4, 'name': '知乎', 'alexa': '103', 'url': 'https://www.zhihu.com'&#125;&#123;'_id': 5, 'name': 'Github', 'alexa': '109', 'url': 'https://www.github.com'&#125;""" update_many()：修改所有匹配到的记录 12345678910111213141516171819202122232425262728293031323334353637383940def updatemany(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] one_data = &#123; "_id":6, "name": "QQ邮箱", "alexa": "111", "url": "http://www.xxxx.com" &#125; coll.insert_one(one_data) print("插入") for x in coll.find(): print(x) myquery = &#123;"name": &#123;"$regex": "^Q"&#125;&#125; new_data = &#123;"$set": &#123;"alexa": "999"&#125;&#125; x = coll.update_many(myquery, new_data) print(x.modified_count, "文档修改") for i in coll.find(): print(i)"""插入&#123;'_id': 1, 'name': 'Taobao', 'alexa': '99', 'url': 'https://www.taobao.com'&#125;&#123;'_id': 2, 'name': 'QQ', 'alexa': '101', 'url': 'https://www.qq.com'&#125;&#123;'_id': 3, 'name': 'Facebook', 'alexa': '10', 'url': 'https://www.facebook.com'&#125;&#123;'_id': 4, 'name': '知乎', 'alexa': '103', 'url': 'https://www.zhihu.com'&#125;&#123;'_id': 5, 'name': 'Github', 'alexa': '109', 'url': 'https://www.github.com'&#125;&#123;'_id': 6, 'name': 'QQ邮箱', 'alexa': '111', 'url': 'http://www.xxxx.com'&#125;2 文档修改&#123;'_id': 1, 'name': 'Taobao', 'alexa': '99', 'url': 'https://www.taobao.com'&#125;&#123;'_id': 2, 'name': 'QQ', 'alexa': '999', 'url': 'https://www.qq.com'&#125;&#123;'_id': 3, 'name': 'Facebook', 'alexa': '10', 'url': 'https://www.facebook.com'&#125;&#123;'_id': 4, 'name': '知乎', 'alexa': '103', 'url': 'https://www.zhihu.com'&#125;&#123;'_id': 5, 'name': 'Github', 'alexa': '109', 'url': 'https://www.github.com'&#125;&#123;'_id': 6, 'name': 'QQ邮箱', 'alexa': '999', 'url': 'http://www.xxxx.com'&#125;""" 排序sort方法，第一个字段指定要排序的字段，第二个字段指定排序的规则，1位升序，-1为降序，默认为升序 1234567891011121314def sort1(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] for x in coll.find().sort("alexa"): print(x)"""&#123;'_id': 3, 'name': 'Facebook', 'alexa': '10', 'url': 'https://www.facebook.com'&#125;&#123;'_id': 4, 'name': '知乎', 'alexa': '103', 'url': 'https://www.zhihu.com'&#125;&#123;'_id': 5, 'name': 'Github', 'alexa': '109', 'url': 'https://www.github.com'&#125;&#123;'_id': 1, 'name': 'Taobao', 'alexa': '99', 'url': 'https://www.taobao.com'&#125;&#123;'_id': 2, 'name': 'QQ', 'alexa': '999', 'url': 'https://www.qq.com'&#125;&#123;'_id': 6, 'name': 'QQ邮箱', 'alexa': '999', 'url': 'http://www.xxxx.com'&#125;""" 删除数据 删除单个文档delete_one 12345678910111213141516def deleteone(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] myquery = &#123;"name" : "知乎"&#125; coll.delete_one(myquery) for x in coll.find(): print(x)"""&#123;'_id': 1, 'name': 'Taobao', 'alexa': '99', 'url': 'https://www.taobao.com'&#125;&#123;'_id': 2, 'name': 'QQ', 'alexa': '999', 'url': 'https://www.qq.com'&#125;&#123;'_id': 3, 'name': 'Facebook', 'alexa': '10', 'url': 'https://www.facebook.com'&#125;&#123;'_id': 5, 'name': 'Github', 'alexa': '109', 'url': 'https://www.github.com'&#125;&#123;'_id': 6, 'name': 'QQ邮箱', 'alexa': '999', 'url': 'http://www.xxxx.com'&#125;""" 删除多个文档delete_many() 12345678910111213141516def deletemany(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] myquery = &#123;"name":&#123;"$regex":"^Q"&#125;&#125; x = coll.delete_many(myquery) print(x.deleted_count, "删除数量") for i in coll.find(): print(i)"""2 删除数量&#123;'_id': 1, 'name': 'Taobao', 'alexa': '99', 'url': 'https://www.taobao.com'&#125;&#123;'_id': 3, 'name': 'Facebook', 'alexa': '10', 'url': 'https://www.facebook.com'&#125;&#123;'_id': 5, 'name': 'Github', 'alexa': '109', 'url': 'https://www.github.com'&#125;""" 删除所有的文档当传入的参数是空对象，就会默认将集合中的文档全部删除{} 1234567def deleteall(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] x = coll.delete_many(&#123;&#125;) print("删除数量：", x.deleted_count) # 删除数量： 3 删除集合drop()方法, 删除成功返回True，否则返回false 12345def delete_collection(): client = MongoClient(host="localhost", port=27017) db = client['runoodbd'] coll = db['sites2'] print(coll.drop()) 查看是否删除成功show tables 将爬取博客的数据存放在MongoDB数据库中 12345678910111213141516171819202122232425262728from pymongo import MongoClientimport requestsfrom bs4 import BeautifulSoupimport datetime# 连接MongoDB的客户端client = MongoClient('localhost',27017)# 连接数据库blog_database，如果数据库不存在，就会创建一个数据库db = client.blog_database# 选择该数据库的集合blog,如果集合不存在，也会创建一个collection = db.bloglink = "http://www.santostang.com"r = requests.get(link)soup = BeautifulSoup(r.text, 'lxml')title_list = soup.find_all('h1', class_="post-title")for eachone in title_list: url = eachone.a['href'] content = eachone.a.text.strip() post = &#123; "url": url, "content": content, "date": datetime.datetime.utcnow() # 返回当前utc日期和时间 &#125; collection.insert_one(post)# 将获取到数据存入post这个字典中，然后insert_one插入到集合中 判断一个网站是不是gzip压缩的，就是一个服务端传递给浏览器的数据被压缩了，然后由浏览器自行解封装，自行渲染页面 用r.conten解封装，然后将utf-8编码装换为unicode]]></content>
      <categories>
        <category>python网络爬虫</category>
      </categories>
      <tags>
        <tag>python网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python网络爬虫之使用lxml解析网页]]></title>
    <url>%2Fpython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B9%8B%E4%BD%BF%E7%94%A8lxml%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[安装lxmlpip install lxml 提取网页源代码数据的三种方法 Xpath选择器 CSS选择器 BeautifuSoup的find方法 https://www.w3school.com.cn/xpath/xpath_syntax.asp]]></content>
      <categories>
        <category>python网络爬虫</category>
      </categories>
      <tags>
        <tag>python网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python网络爬虫之BeautifulSoup的使用]]></title>
    <url>%2Fpython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B9%8BBeautifulSoup%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[BeautifulSoup对象就是一个树形结构，他的每一个节点都是一个python对象，获取网页内容就是一个提取对象的过程 提取对象的三种方法 遍历文档树 搜索文档树 CSS选择器 实验字符串123456789101112131415161718html = """&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class="story"&gt; Once upon a time there were three little sisters; and their names were &lt;a href="http://example.com/elsie" class="sister" id="link1"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt;hellp &lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and &lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class="story"&gt;...&lt;/p&gt;""" 遍历文档树 例如我们想要获得标签的内容，获取第一个p标签下的内容，包括字符串，子标签，然后用列表的形式输出，注意，不能写成soup.body.p，可能是解析网页的时候，解析器就没有解析这个body标签 soup.p 12soup = BeautifulSoup(html, 'lxml')print(soup.p.contents) #把子节点以列表的方式输出 获取该节点下所有子子孙孙的节点 all_child = soup.p.descendants 获取父结点， p_tag = soup.p.a p_tag.parent 1234# 获取父结点p_tag = soup.p.aprint(p_tag.parent)# 返回的是父结点的所有内容 搜索文档树常用方法： find() find_all() 通常配合re正则使用soup.findall(re.comlile(&quot;^h&quot;)) CSS选择器https://www.w3school.com.cn/cssref/css_selectors.asp 12# 找出所有链接以http://www.baidu.com开始的a标签soup.select('a[href^="http://www.baidu.com"]')]]></content>
      <categories>
        <category>python网络爬虫</category>
      </categories>
      <tags>
        <tag>python网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二级文件系统的实现]]></title>
    <url>%2F%E4%BA%8C%E7%BA%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[实验内容： 为Linux系统设计一个简单的二级文件系统。要求做到以下几点： （1）可以实现下列几条命令 login 用户登录 dir 列文件目录 create 创建文件 delete 删除文件 open 打开文件 close 关闭文件 read 读文件 write 写文件 （2）列目录时要列出文件名、物理地址、保护码和文件长度； （3）源文件可以进行读写保护。 二级文件系统 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//假设一个磁盘的每个物理块大小为512个字节struct MFD // 16个用户&#123; string username; string password; //int pufd; //用户目录文件所在的物理块 struct USER_UFD * next; //指向用户目录&#125;;struct UFD //一个用户可以用16个文件夹，然后每个文件夹下可以有16个文件&#123; struct file_message &#123; string filename; int protect_code; //保护码 int length; //文件长度 int addr; //存放该文件的物理块的第一个的快号 &#125;ufd[16]; string directname; //用户目录名 int cur_file_size = 0; //不能在结构体内附初始值。好像不能成功&#125;;struct UOF //假设一个用户最多打开16个文件&#123; struct uof &#123; string filename; int pointer; //文件的读写指针,其实就是文件的大小 int protect_code; //2表示可读可写,1表示可读不可写， 0表示不可读不可写 int addr; //存放文件的第一个磁盘块号 &#125;uof[16]; int cur_openfilesize = 0;&#125;;struct fat //文件分配表 用一块物理块存放，那么最多可以记录64块数据块的信息。&#123; int next = -1; //下一个磁盘块号 int used = 0; //1表示被使用，// int self; //自己的快号&#125;fat[64];struct USER_UFD &#123; struct UFD direct[16]; //每个用户最多有16个目录 int cur_user_direct_size = 0; //当前用户的目录数&#125;;struct USER_UFD cur_user_all_direct_array[16]; //16个用户的所有目录的对象int max_usersize = 16;int max_userfilesize = 16;int max_openfilesize = 16;struct MFD cur_user; //当前用户//struct UFD cur_user_dirtect[16]; //用户目录struct UOF * cur_opentable; //当前文件打开表char *fdisk; //虚拟磁盘的起始位置struct UOF openfile[16]; //每一个用户对应一个文件打开表对象，只能设置为全局变量MFD mfd[16]; //16个用户int cur_user_size = 0; //记录当前用户的人数string path; //记录当前用户的路径//函数声明int open(string name);void register_user();void remove(string);int create(string);int open(string);int close(string);int del(string);int read(string);int write(string, char *, int);void dir();int login();void cd();void mkdir(string);void input_operation();void register_user();void remove(string name);int create(string name)&#123; //cout &lt;&lt; cur_user.next-&gt;cur_file_size &lt;&lt; endl; //system("pause"); int index; //标识当前目录在direct数组中第几个 for (index = 0; index &lt; cur_user.next-&gt;cur_user_direct_size; index++) &#123; if (path == cur_user.next-&gt;direct[index].directname) &#123; break; &#125; &#125; int i; for (i = 0; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++) //遍历当前目录，查看是否有文件重名 &#123; if (name == cur_user.next-&gt;direct[index].ufd[i].filename) break; &#125; if (i &lt; cur_user.next-&gt;direct[index].cur_file_size) //判断文件名是否重复 &#123; cout &lt;&lt; "文件名重复" &lt;&lt; endl; return -1; &#125; if (cur_user.next-&gt;direct[index].cur_file_size == 16) //判断当前目录的文件到达16个 &#123; cout &lt;&lt; "用户文件已经达到16个" &lt;&lt; endl; return -1; &#125; int j; for (j = 0; j &lt; 64; j++) //判断是否有空的空闲块。 &#123; if (fat[j].used == 0) break; &#125; if (j &gt;= 64) &#123; cout &lt;&lt; "磁盘没有空闲块了" &lt;&lt; endl; return -1; &#125; cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].filename = name; cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].addr = j; //文件起始盘块号 cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].length = 0; cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].protect_code = 2; //表示可读可写 cur_user.next-&gt;direct[index].cur_file_size++;//用户文件数量加1 fat[j].used = 1; //被使用 fat[j].next = -1; //只是个空文件,所有没有后序的块 //写入文件打开表中,就是调用open（） cout &lt;&lt; "文件创建成功" &lt;&lt; endl; int fd = open(name); return fd;&#125;int open(string name)&#123; int index; //标识当前目录在direct数组中第几个 for (index = 0; index &lt; cur_user.next-&gt;cur_user_direct_size; index++) &#123; if (path == cur_user.next-&gt;direct[index].directname) &#123; break; &#125; &#125; int i; for (i = 0; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++) //当前目录有没有这个文件，没有就自然不能打开 &#123; if (name == cur_user.next-&gt;direct[index].ufd[i].filename) break; &#125; if (i &gt; cur_user.next-&gt;direct[index].cur_file_size) &#123; cout &lt;&lt; "i的值为" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "该用户没有这个文件" &lt;&lt; endl; return -1; &#125; if (cur_opentable-&gt;cur_openfilesize == max_openfilesize) //如果打开文件的数量达到最大值，那么就无法打开 &#123; cout &lt;&lt; "文件打开数量已经达到最大值" &lt;&lt; endl; return -1; &#125; for (int j = 0; j &lt; cur_opentable-&gt;cur_openfilesize; j++) //如果文件已经打开，就无需打开 &#123; if (cur_opentable-&gt;uof[j].filename == name) &#123; cout &lt;&lt; "文件已经打开" &lt;&lt; endl; return -1; &#125; &#125; int k; for (k = 0; k &lt; cur_user.next-&gt;direct[index].cur_file_size; k++) //找到要打开的文件在文件数组中的第几个 &#123; if (cur_user.next-&gt;direct[index].ufd[k].filename == name) break; &#125; cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize].filename = name; cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize].protect_code = cur_user.next-&gt;direct[index].ufd[k].protect_code; cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize].pointer = cur_user.next-&gt;direct[index].ufd[k].length; cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize].addr = cur_user.next-&gt;direct[index].ufd[k].addr; cur_opentable-&gt;cur_openfilesize++; //文件打开数量加1 cout &lt;&lt; "文件打开成功" &lt;&lt; endl; return k; //返回文件在文件打开表中的第几项&#125;int close(string name)&#123; int fd; for (int i = 0; i &lt; cur_opentable-&gt;cur_openfilesize; i++) //找到要关闭的文件在表中的第几项 &#123; if (cur_opentable-&gt;uof[i].filename == name) &#123; fd = i; break; &#125; &#125; if (fd &gt;= cur_opentable-&gt;cur_openfilesize) &#123; cout &lt;&lt; "没有这个文件或者文件没有打开" &lt;&lt; endl; return -1; &#125; //将要删除的项目与最后一个项目交换,因为是数组存放，。。 cur_opentable-&gt;uof[fd].filename = cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize - 1].filename; cur_opentable-&gt;uof[fd].pointer = cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize - 1].pointer; cur_opentable-&gt;uof[fd].protect_code = cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize - 1].protect_code; cur_opentable-&gt;uof[fd].addr = cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize - 1].addr; //cur_opentable-&gt;cur_openfilesize--; cur_opentable-&gt;cur_openfilesize--; cout &lt;&lt; "文件关闭成功" &lt;&lt; endl; return 0;&#125;int del(string name) //删除文件打开表的文件数量不用减一，因为文件打开就不能删除文件&#123; int index; //标识当前目录在direct数组中第几个 for (index = 0; index &lt; cur_user.next-&gt;cur_user_direct_size; index++) &#123; if (path == cur_user.next-&gt;direct[index].directname) &#123; break; &#125; &#125; int i; for (i = 0; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++) //判断当前目录下有没有这个文件 &#123; if (cur_user.next-&gt;direct[index].ufd[i].filename == name) break; &#125; if (i &gt;= cur_user.next-&gt;direct[index].cur_file_size) &#123; cout &lt;&lt; "没有这个文件" &lt;&lt; endl; return -1; &#125; int j; for (j = 0; j &lt; cur_opentable-&gt;cur_openfilesize; j++) //判断该文件是否被打开 &#123; if (cur_opentable-&gt;uof[j].filename == name) break; &#125; if (j &lt; cur_opentable-&gt;cur_openfilesize) //说明文件被打开了 &#123; cout &lt;&lt; "这个文件被打开了，请先关闭" &lt;&lt; endl; return -1; &#125; //更新当前用户目录下文件数组信息,就是将最后一个文件的信息替换到要删除的文件的位置 fat[cur_user.next-&gt;direct[index].ufd[i].addr].used = 0; //没有使用 cur_user.next-&gt;direct[index].ufd[i].filename = cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - 1].filename; cur_user.next-&gt;direct[index].ufd[i].addr = cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - 1].addr; cur_user.next-&gt;direct[index].ufd[i].length = cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - 1].length; cur_user.next-&gt;direct[index].ufd[i].protect_code = cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - 1].protect_code; cur_user.next-&gt;direct[index].cur_file_size--; //用户文件数量减1 //回收磁盘 int temp = fat[cur_user.next-&gt;direct[index].ufd[i].addr].next; while (temp != -1) &#123; fat[temp].used = 0; temp = fat[temp].next; &#125; cout &lt;&lt; "删除文件成功" &lt;&lt; endl; return 0;&#125;int read(string name)&#123; int index1; //标识当前目录在direct数组中第几个 for (index1 = 0; index1 &lt; cur_user.next-&gt;cur_user_direct_size; index1++) &#123; if (path == cur_user.next-&gt;direct[index1].directname) &#123; break; &#125; &#125; int a; for (a = 0; a &lt; cur_user.next-&gt;direct[index1].cur_file_size; a++) //判断文件是否存在 &#123; if (cur_user.next-&gt;direct[index1].ufd[a].filename == name) break; &#125; if (a &gt;= cur_user.next-&gt;direct[index1].cur_file_size) &#123; cout &lt;&lt; "没有这个文件" &lt;&lt; endl; return -1; &#125; int i; //判读文件是否打开 for (i = 0; i &lt; cur_opentable-&gt;cur_openfilesize; i++) &#123; if (cur_opentable-&gt;uof[i].filename == name) break; &#125; if (i &gt;= cur_opentable-&gt;cur_openfilesize) &#123; cout &lt;&lt; "文件没有打开， 无法读取" &lt;&lt; endl; return -1; &#125; int fd = i; //获取文件描述字 //判断读文件的合法性 if (cur_opentable-&gt;uof[fd].protect_code == 0) //我们创建的文件都是默认可读可写的。。。 &#123; cout &lt;&lt; "文件不可读" &lt;&lt; endl; return -1; &#125; else &#123; int len = cur_opentable-&gt;uof[fd].pointer; //文件的长度 int block_size = len / 512; //磁盘的个数 int offset = len % 512; //偏移量 if (offset != 0) block_size++; //如果我用一个文件表示磁盘的引导块，用另一个文件表示磁盘的数据块，那么我们计算文件的起始位置就不用加上磁盘的引导块了吧。。 //关于文件的存放文件，我们char *fdisk表示一整个磁盘，然后不同文件的内容存放在这个指针所指向的不同字符段 char * first = fdisk + cur_opentable-&gt;uof[fd].addr * 512; //文件的起始地址 char * buf = (char *)malloc(512 * sizeof(char)); //缓冲区 cout &lt;&lt; "文件的内容为 :"; for (int k = 0; k &lt; block_size; k++) &#123; if (k == block_size - 1) //则是最后一个磁盘块 &#123; for (int j = 0; j &lt; len - k * 512; j++) //赋值文件剩余的字符，其实就是偏移量 &#123; buf[j + k * 512] = first[j]; &#125; for (int u = 0; u &lt; len - k * 512; u++) &#123; cout &lt;&lt; buf[u + k * 512]; //输出剩余长度，之所以这样输出，printf()，将整个buf的内容全部输出，如果没有读满就出现乱码啦。。 &#125; &#125; else //不在最后一个磁盘块，也就是在其他已经读满的磁盘块 &#123; for (int j = 0; j &lt; len - i * 512; j++) buf[j + k * 512] = first[j]; //缓冲区读满就输出内容 printf("%s\n", buf); //输出文件的内容 int next_block = fat[cur_opentable-&gt;uof[fd].addr].next; //读完一个磁盘块后，在接着读下一个磁盘块 first = fdisk + next_block * 512; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "文件读取成功" &lt;&lt; endl; free(buf); //释放缓冲区 return 0; &#125;&#125;//类似于文件拷贝实验，每次赋值缓冲区到虚拟磁盘中, //待完成问题：更新表的文件长度int write(string name, char * buf, int len)&#123; int index1; //标识当前目录在direct数组中第几个 for (index1 = 0; index1 &lt; cur_user.next-&gt;cur_user_direct_size; index1++) &#123; if (path == cur_user.next-&gt;direct[index1].directname) &#123; break; &#125; &#125; int i; //判读文件是否打开 for (i = 0; i &lt; cur_opentable-&gt;cur_openfilesize; i++) &#123; if (cur_opentable-&gt;uof[i].filename == name) break; &#125; if (i &gt;= cur_opentable-&gt;cur_openfilesize) &#123; cout &lt;&lt; "文件没有打开， 无法读取" &lt;&lt; endl; return -1; &#125; int fd = i; //获取文件描述字 //判断读文件的合法性 if (cur_opentable-&gt;uof[fd].protect_code != 2) &#123; cout &lt;&lt; "文件不可写" &lt;&lt; endl; return -1; &#125; else &#123; int temp; //保存当前所写的文件在用户文件目录表的第几项，为了后面修改文件的大小 int first_block = cur_opentable-&gt;uof[fd].addr; //用户文件存放的第一个磁盘块 for (int k = 0; k &lt; cur_user.next-&gt;direct[index1].cur_file_size; k++) &#123; if (cur_user.next-&gt;direct[index1].ufd[k].addr == first_block) &#123; temp = k; break; &#125; &#125; //追加写 //找到该文件存放的最后一个磁盘块 while (fat[first_block].next != -1) &#123; first_block = fat[first_block].next; &#125; //计算该文件存放的最后一个地址 char * first; first = fdisk + first_block * 512 + cur_opentable-&gt;uof[fd].pointer % 512; //如果最后一个文件剩下的空间大于要写入的长度 if (len &lt;= 512 - cur_opentable-&gt;uof[fd].pointer % 512) &#123; //strcpy(first, buf); 这句代码出现问题，可能是由于buf没有读满，后面的值被访问了，非法！ for (int i = 0; i &lt; len; i++) &#123; first[i] = buf[i];//将缓冲区的内容写入虚拟磁盘中 &#125; cur_opentable-&gt;uof[fd].pointer = cur_opentable-&gt;uof[fd].pointer + len; //更新文件打开表 cur_user.next-&gt;direct[index1].ufd[temp].length = cur_user.next-&gt;direct[index1].ufd[temp].length + len; //更新用户目录文件表 &#125; else //如果剩下的空间不足写入 &#123; for (i = 0; i &lt; 512 - cur_opentable-&gt;uof[fd].pointer % 512; i++) &#123; //写入一部分的内容到最后一个磁盘块的剩余空间 first[i] = buf[i]; &#125; //计算分配完最后一个磁盘的剩余空间后，还剩下多少字节没有存储 int last_size = len - (512 - cur_opentable-&gt;uof[fd].pointer % 512); int need_block_size = last_size / 512; int need_offset_size = last_size % 512; if (need_offset_size &gt; 0) need_block_size++; //总共需要这么磁盘块 int unused_block_size = 0; //记录没有使用过的磁盘块的个数 //int first_unused_block; //记录第一个没有被使用过的磁盘 int flag = 0; for (int i = 0; i &lt; 64; i++) &#123; if (fat[i].used == 0) &#123; unused_block_size++; &#125; &#125; if (unused_block_size &lt; need_block_size) &#123; cout &lt;&lt; "磁盘没有空间存放了-=-=" &lt;&lt; endl; return -1; &#125; else &#123; int item = cur_opentable-&gt;uof[fd].addr; for (int p = 0; p &lt; need_block_size; p++) //执行多次寻找空闲磁盘的操作， &#123; for (int i = 0; i &lt; 64; i++) &#123; if (fat[i].used == 0) //没有被使用 &#123; first = fdisk + i * 512; //当前要写入的磁盘块的起始地址 fat[i].used = 1; //标记被使用 fat[item].next = i; //标记下一个磁盘 item = i; break; &#125; &#125; if (p == need_block_size - 1) &#123; for (int k = 0; k &lt; need_offset_size; k++) //将文件的偏移量写入最后一个文件中 first[k] = buf[k]; //更新最后一个磁盘块的next值 fat[i].next = -1; &#125; else //如果不是最后一个空闲块 &#123; //待解决问题，就是如果更新fat的next值 for (int k = 0; k &lt; 512; k++) first[k] = buf[k]; &#125; &#125; cur_opentable-&gt;uof[fd].pointer = cur_opentable-&gt;uof[fd].pointer + last_size; //更新文件打开表 cur_user.next-&gt;direct[index1].ufd[temp].length = cur_user.next-&gt;direct[index1].ufd[temp].length + last_size; //更新用户目录文件表 &#125; &#125; cout &lt;&lt; "文件写入成功" &lt;&lt; endl; return 0; &#125;&#125;void dir()&#123; int index1; //标识当前目录在direct数组中第几个 for (index1 = 0; index1 &lt; cur_user.next-&gt;cur_user_direct_size; index1++) &#123; if (path == cur_user.next-&gt;direct[index1].directname) &#123; break; &#125; &#125; if (path == "") //表示此时路径在用户的目录表，显示文件目录 &#123; cout &lt;&lt; "\t" &lt;&lt; "目录名" &lt;&lt; endl; for (int i = 0; i &lt; cur_user.next-&gt;cur_user_direct_size; i++) &#123; cout &lt;&lt; "\t" &lt;&lt; cur_user.next-&gt;direct[i].directname &lt;&lt; endl; &#125; &#125; else //显示目录下的文件 &#123; cout &lt;&lt; "\t" &lt;&lt; "文件名" &lt;&lt; "\t" &lt;&lt; "文件保护码" &lt;&lt; "\t" &lt;&lt; "文件长度" &lt;&lt; "\t" &lt;&lt;"文件起始盘块号" &lt;&lt; endl; for (int i = 0; i &lt; cur_user.next-&gt;direct[index1].cur_file_size; i++) //输出文件的信息 &#123; cout &lt;&lt; "\t" &lt;&lt; cur_user.next-&gt;direct[index1].ufd[i].filename &lt;&lt; "\t" &lt;&lt; cur_user.next-&gt;direct[index1].ufd[i].protect_code &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; cur_user.next-&gt;direct[index1].ufd[i].length &lt;&lt;"\t" &lt;&lt; "\t" &lt;&lt; cur_user.next-&gt;direct[index1].ufd[i].addr &lt;&lt; endl; &#125; &#125;&#125;int login()&#123; string name; string password; //UFD user; cout &lt;&lt; "请输入你的姓名" &lt;&lt; endl; cin &gt;&gt; name; cout &lt;&lt; "请输入你的密码" &lt;&lt; endl; cin &gt;&gt; password; int i; for ( i = 0; i &lt; cur_user_size; i++) &#123; if (mfd[i].username == name &amp;&amp; mfd[i].password == password) &#123; break; &#125; &#125; if (i &gt;= cur_user_size) &#123; cout &lt;&lt; "没有这个用户或者用户名密码错误" &lt;&lt; endl; return -1; &#125; mfd[i].next = &amp; (cur_user_all_direct_array[i]); //用户指向自己的所有目录的结构 //初始化当前用户的信息 cur_user = mfd[i]; cur_user.next-&gt;cur_user_direct_size = mfd[i].next-&gt;cur_user_direct_size; // cur_user_size++; //用户人数++ cur_opentable = &amp;openfile[cur_user_size]; //指针指向文件打开表对象 cur_opentable-&gt;cur_openfilesize = 0; //设初始值 path = ""; //指定当前路径为用户的全部目录处 return 1;&#125;void cd()&#123; string temp_path; cin &gt;&gt; temp_path; if (temp_path == "..") &#123; path = ""; return; &#125; int i; for (i = 0; i &lt; cur_user.next-&gt;cur_user_direct_size; i++) //判断path是否存在 &#123; if (temp_path == cur_user.next-&gt;direct[i].directname) break; &#125; if (i &gt;= cur_user.next-&gt;cur_user_direct_size) &#123; cout &lt;&lt; "没有这个目录" &lt;&lt; endl; return; &#125; path = temp_path; return; &#125;void mkdir(string name)&#123; if (cur_user.next-&gt;cur_user_direct_size == 16) &#123; cout &lt;&lt; "用户目录已经达到最大值，不能在创建目录了" &lt;&lt; endl; return; &#125; int i; for (i = 0; i &lt; cur_user.next-&gt;cur_user_direct_size; i++) //判断创建的目录是否存在 &#123; if (cur_user.next-&gt;direct[i].directname == name) break; &#125; if (i &lt; cur_user.next-&gt;cur_user_direct_size) &#123; cout &lt;&lt; "该目录已经存在了" &lt;&lt; endl; return; &#125; cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size].directname = name; cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size].cur_file_size = 0; //新创建的目录里面的文件个数为0 cur_user.next-&gt;cur_user_direct_size++; //用户的目录数加1 cout &lt;&lt; "创建目录成功" &lt;&lt; endl; return; &#125;void input_operation() //用户输入命令&#123; if (cur_user.username == "") cout &lt;&lt; "localhost :"; else cout &lt;&lt; cur_user.username &lt;&lt; "@localhost home/" &lt;&lt;path &lt;&lt; "："; string operation; cin &gt;&gt; operation; if (operation == "login") &#123; login(); &#125; else if (operation == "dir") dir(); else if (operation == "create") &#123; string filename; cin &gt;&gt; filename; create(filename); &#125; else if (operation == "del") &#123; string filename; cin &gt;&gt; filename; del(filename); &#125; else if (operation == "open") &#123; string name; cin &gt;&gt; name; open(name); &#125; else if (operation == "close") &#123; string name; cin &gt;&gt; name; close(name); &#125; else if (operation == "read") &#123; string name; cin &gt;&gt; name; read(name); &#125; else if (operation == "write") &#123; string content; string name; cout &lt;&lt; "请输入要写入的文件："; cin &gt;&gt; name; cin.ignore(); //清空缓冲区的内容，不然getline读到上一个回车直接结束。。。 cout &lt;&lt; "请输入文件要写入的内容: " &lt;&lt; endl;; getline(cin, content); //读入一整行内容 //cout &lt;&lt; content &lt;&lt; endl; //system("pause"); //cin &gt;&gt; content; char buf[512]; int times = content.length() / 512; int offset = content.length() % 512; if (offset != 0) times++; for (int i = 0; i &lt; times; i++) &#123; if (i == times - 1) //注意这里不能写成times-- o.o!!! &#123; for (int j = 0; j &lt; offset; j++) buf[j] = content[j]; &#125; else &#123; for (int j = 0; j &lt; 512; j++) buf[j] = content[j]; &#125; write(name, buf, content.length()); &#125; &#125; else if (operation == "exit") &#123; exit(0); &#125; else if (operation == "cd") &#123; cd(); &#125; else if (operation == "mkdir") &#123; string name; cin &gt;&gt; name; mkdir(name); &#125; else if (operation == "register") &#123; register_user(); &#125; else if (operation == "remove") &#123; string name; cin &gt;&gt; name; remove(name); &#125; else &#123; cout &lt;&lt; "你的命令错误，重新输入" &lt;&lt; endl; &#125;&#125;void register_user() //注册用户&#123; cout &lt;&lt; "请输入用户名："; string username; cin &gt;&gt; username; cout &lt;&lt; "请输入密码："; string password; cin &gt;&gt; password; int i; for (i = 0; i &lt; 16; i++) &#123; if (mfd[i].username == username) &#123; break; &#125; &#125; if (i &lt; 16) &#123; cout &lt;&lt; "该用户已经存在" &lt;&lt; endl; return; &#125; mfd[cur_user_size].username = username; mfd[cur_user_size].password = password; cur_user_size++; //用户人数加1 cout &lt;&lt; "用户注册成功！" &lt;&lt; endl;&#125;void remove(string name) //删除目录&#123; int index; for (int i = 0; i &lt; cur_user.next-&gt;cur_user_direct_size; i++) &#123; if (name == cur_user.next-&gt;direct[i].directname) &#123; index = i; break; &#125; &#125; for (int i = 0; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++) //删除目录里面的文件 &#123;//直接释这些文件所占的磁盘块 fat[cur_user.next-&gt;direct[index].ufd[i].addr].used = 0; //没有使用 int temp = fat[cur_user.next-&gt;direct[index].ufd[i].addr].next; while (temp != -1) &#123; fat[temp].used = 0; temp = fat[temp].next; &#125; &#125; //删除目录项，就是将两个目录项的内容进行交换 cur_user.next-&gt;direct[index].cur_file_size = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size-1].cur_file_size; //注意这里需要减一，由于本身结构的限制 cur_user.next-&gt;direct[index].directname = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size-1].directname; for (int i = 0; i &lt; cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size-1].cur_file_size; i++) //注意这里的减一 &#123; cur_user.next-&gt;direct[index].ufd[i].addr = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size-1].ufd[i].addr; cur_user.next-&gt;direct[index].ufd[i].filename = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size-1].ufd[i].filename; cur_user.next-&gt;direct[index].ufd[i].length = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size-1].ufd[i].length; cur_user.next-&gt;direct[index].ufd[i].protect_code = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size-1].ufd[i].protect_code; &#125; cur_user.next-&gt;cur_user_direct_size--; //目录数量减1 cout &lt;&lt; "删除目录成功" &lt;&lt; endl; return;&#125;int main()&#123; cur_user.username = ""; //初始化当前用户的用户名为空 path = ""; //用内存模拟外存，申请内存空间 fdisk = (char *)malloc(1024 * 1024 * sizeof(char)); //初始换fdisk cout &lt;&lt; "***************欢迎来到二级文件系统******************" &lt;&lt; endl; cout &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "命令" &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "功能" &lt;&lt; endl; cout &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "register" &lt;&lt; "\t" &lt;&lt; "注册" &lt;&lt; endl; cout &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "login" &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "登录" &lt;&lt; endl; cout &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "create" &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "创建文件" &lt;&lt; endl; cout &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "mkdir" &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "创建目录" &lt;&lt; endl; cout &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "cd" &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "切换目录" &lt;&lt; endl; cout &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "open" &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "打开文件" &lt;&lt; endl; cout &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "close" &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "关闭文件" &lt;&lt; endl; cout &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "read" &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "读文件" &lt;&lt; endl; cout &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "write" &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "写文件" &lt;&lt; endl; cout &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "del" &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "删除文件" &lt;&lt; endl; cout &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "exit" &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "退出系统" &lt;&lt; endl; cout &lt;&lt; "*****************************************************" &lt;&lt; endl; while (true) input_operation();&#125;//有个问题，循环的界值要更新。--》》解决//出现问题：指向一些空指针的问题--&gt;解决]]></content>
      <categories>
        <category>操作系统</category>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读者写者问题]]></title>
    <url>%2F%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98-%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88%2F</url>
    <content type="text"><![CDATA[读者写者问题 进程互斥访问有限资源的同步问题 问题：允许多个进程同时读取文件， 但是如果有一个进程在写文件，那么就不允许其他进程写或者是读这个文件 读者优先 读者优先就是只有当所有的读者都完成了读文件的操作后，才能让写进程访问文件 实现方法： readcount:读者计数器，初值为0 rmutex：初值为1，因为读者计数器为多个读者共享的资源，是临界资源 wmutex:初值为1，互斥信号量，代表一个共享文件 伪代码：1234567891011121314151617181920212223242526272829303132333435void reader(void)&#123; while(true) &#123; p(rmutex); //抢占读者计算器这个资源 readercount++; //读者数量加1 //如果是第一个读者，要执行p操作抢占文件，为什么要抢占文件，就要先抢占，防止有写者进行写（读者优先），如果不是第一个读者，则表示已经有读者在安全地读这个文件 if (readercount == 1) p(wmutex); //抢占共享文件资源 v(rmutex); //释放读者计算器 read_file(); //读文件 p(rmutex); //读完文件后，读者数量减少1，所以需要再次抢占读者计算器这个资源，然后进行修改 readcount--;//读者数量减1 if (readcount == 0) //如果是最后一个读者，需要释放“共享文件”这个资源，这样才能让写者进程进行写 v(wmutex); //释放文件资源 v(rmutex);//释放读者计数器 &#125;&#125;void write(void)&#123; while(true) &#123; p(wmutex); //抢占文件资源 write_file(); //执行写文件操作 v(wmutex); //释放文件资源 &#125;&#125; 写者优先 只有当所有的写进程完成后才进行读进程的操作 读者与写者，写者与写者不能同时访问缓冲区 当没有写者进程的时候，多个读者进程可以同时访问缓冲区 当读者进程和写者进程同时等待的时候，写者进程优先于读者进程，也就是所有的读者进程进行活动都要建立在没有写者进程的前提下 实现方法： wcount：表示写者数量，初始值为0 rcount：表示读者数量， 初始值为0 rmutex：互斥修改读者数量，初始值为1 wmutex：互斥修改写者数量，初始值为1 file：互斥访问文件，初始值为1 read：阻塞读者进程，写者优先，当至少有一个写进程操作文件的时候，读进程就要阻塞 注意问题：当读者队列不为0的时候，写者进程会等待这些读者进程全部读文件完后然后释放文件资源，然后才进行写文件操作，假设当读者进程执行了很久，然后读者队列中有多个，也就是rcount &gt;=1，然后这时候写者进程1来申请写文件资源，那么他这个时候必须等待之前的读者队列内的全部读者完成操作后才行，至于写者优先的操作体现在当写者进程进行申请文件资源后，有读者进程1在他之后也申请文件资源，那么这个读者进程只能排到写者进程的后面，然后不幸的是这个时候再来一个写者进程2，那么读者进程1只能被挤掉，排在写者进程2后面，也就是此时的进程队列为写者进程1，写者进程2，读者进程1.。。。 读者进程是可以有多个的，也就是读者进程申请完后，可能他的释放比另一个读者进程的申请要慢，所以就可以产生多个读者进程 伪代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546void reader()&#123; while(true) &#123; p(read);//当前写者队列为空的时候，就可以申请读文件资源 p(rmutex); //抢占读者计数器 if(rcount == 0) //如果是第一个读者，那么就抢占文件资源，这样就可以保证读文件与写文件互斥 p(file); //抢占文件资源 rcount++; //读者数量+1 v(rmutex); //释放读者计数器 v(read); //这一步比较关键，如果不释放的话，那么你每次只有一个读者进程，而且写进程也不能抢占这个资源，就会发生死锁 //而且这也是写进程抢占写文件的时机，如果写进程抢占到这个read，他就会等到之前所有的读进程完成后释放文件，然后抢占文件，进而就可以开始写进程，这也就是写者优先 read_file(); //读取文件 p(rmutex);//抢占读者计数器 rcount--; if (rcount == 0) //如果是最后一个读者进程，释放文件资源 v(file); v(rmutex); //释放读者计数器 &#125;&#125;void writer(void)&#123; while(true) &#123; p(wmutex); //抢占写者计数器 if (wcount == 0) //如果当前写者队列为空，申请优先资源 p(read) wcount++; //写者数量加1 v(wmutex); //释放写者计数器 p(file); //申请文件资源，这时候写者会等待在他进程之前的所有读者进程完成后释放文件 write_file(); //写文件 v(file); //释放文件 p(wmutex); //抢占写者计数器 wcount--; // 写者数量减1 if (wcount == 0) //如果是最后一个写者 v(read); //释放优先资源 v(wmutex); //释放写者计数器 &#125;&#125; 读者写者（读写公平）–先来先服务实现方法 信号量 file 初始值为1， //用于实现对文件的互斥操作 readcount = 0; //记录读者个数 信号量 readmutex 初始值为1，对readcount 互斥访问 信号量 s 实现读写公平 伪代码123456789101112131415161718192021222324252627282930void reader()&#123; while (1) &#123; p(s); p(readmutex); if (readcount == 0) p(file); readcount++; v(readmutex); v(s); 读文件 p(readmutex); if (readcount==0) v(file); v(readmutex); &#125;&#125;void writer()&#123; while (1) &#123; p(s); p(file); 写文件； v(file); v(s); &#125;&#125; 测试并发情况 读者1 —读者2 写1 — 写2 读 1 –写1 写1 —读1 读1 —写1—读2]]></content>
      <categories>
        <category>操作系统</category>
        <category>进程管理</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题]]></title>
    <url>%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[定义 背包问题（Knapsack problem）是一种组合优化的NP完全问题，而NP完全问题暂时还看不懂。问题 可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。 01背包 特点是每种物品仅有一件，选择放或者不放 f[i][v]表示前i件物品放入容量为v的背包中可以获得的最大价值，则状态转移方程为：f[i][v] = max{ f[i-1][v] , f[i-1][v-w[i]] + v[i]} 空间优化 完全背包 就是现在所选的商品可以是0个，1个到无限个 三层循环dp[i][j] =MAX{ dp[i-1][j] , dp[i-1][j-k*w[i]] + k * v[i] }123456789101112void dp1()&#123; for (int i = 1; i&lt;= n;i++) for (int j = 1; j &lt;= money; j++) &#123; dp[i][j] = dp[i][j - 1]; for (int k = 0; k * w[i] &lt;= j; k++) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j - k * w[i]] + v[i]); &#125; &#125;&#125; 两层循环dp[i][j] = max{dp[i-1][j], dp[i-1][j-w[i]] + v[i]}12345678910void dp()&#123; for (int i = 1; i&lt;= n;i++) for (int j = 1; j &lt;= money; j++) //这里就跟01背包问题的顺序不一样 &#123; dp[i][j] = dp[i - 1][j]; if (j &gt;= w[i]) dp[i][j] = max(dp[i][j], dp[i - 1][j - w[i]] + v[i]); &#125;&#125; 一维数组空间优化：dp[j] = max(dp[j], dp[j-w[i]] + v[i])12345678910111213void dp_1()&#123; for (int i = 1; i &lt;= m; i++) &#123; for (int j = need_time[i]; j &lt;= time0; j++) //这里循环可以进行剪枝 &#123; int value1 = f[j - need_time[i]] + value[i]; if (value1 &gt; f[j]) f[j] = value1; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>背包问题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python网络爬虫之正则表达式]]></title>
    <url>%2Fpython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[常用的正则表达式符号 符号 含义 例子 匹配结果 * 匹配前面的字符，子表达式或者括号里的字符0次或者多次 a*b* aaaaaa, aaabbbb,bbbbb + 匹配前面的字符，子表达式或者括号里的字符至少一次 a+b+ aaaaaaaaaaabb,aaabbbbb,abbbbbb [] 匹配中括号内的任意一个字符（相当于任选一个） [A-Z]* APPLE, CAPITALS,QWERTY () 表达式编组（在正则表达式的规则中编辑组会优先运行） (a+b)* aaaabaab, abaaab, ababaaab {m,n} 匹配前面的字符，子表达式或者括号里的字符m到n次（包含m或者n次） {m}允许前一个字符只能出现m次 a{2,3}b{2,3} aabbb, aaabbb,aabb, aaabb [^] 匹配任意一个不在中括号的字符 [^A-Z] apple,lowercase | 匹配任意一个由竖线分割的字符，子表达式 b(a|i|e)d bad, bid, bed . 匹配任意单个字符（包括符号，数字和空格）除了换行符 b.d b d, bad, b&amp;d ^ 指字符串开始位置的字符或者子表达式 ^a apple, asdf, a \ 转义字符（把特殊含义的字符转换成字面形式） \.\ \\ $ 匹配字符串的末尾 ?! “不包含”，表示字符不能出现在目标字符串中，如果想要整个字符串中彻底排除某个字符，就加上^和$ ^((?![A-Z]).)$ no-caps-here 模式 描述 () 匹配括号内的表达式， 也表示一个组 \s 匹配空白字符 \S 匹配任何非空白字符 \d 匹配数字， 等价于[0-9] \D 匹配任何非数字，等价于[^0-9] \w 匹配字母数字，等价于[A-Za-z0-9] \W 匹配非字母数字，等价于[^A-za-z0-9] [] 用力表示一组字符 ? 匹配前一个字符0次或者1次 正则表达式的贪婪模式和非贪婪模式 贪婪模式：顾名思义，就是尽可能匹配多的字符，例如”baaaaac”, pattern = re.compile(‘ba+’)就是等于baaaaa 非贪婪模式：顾名思义，就是在匹配成功的前提下，匹配尽量少的字符， 实现的方法也很简单就是在正则表达式的量词后面加上? , 例如：“baaaaac”, pattern = re.compile(‘ba+?’)，那么pattern就是ba python正则表达式的3种用法官方文档：https://docs.python.org/zh-cn/3/library/re.html re.match() re.search() re.findall() re.match() 只能从字符串起始位置匹配一个模式，如果从起始位置匹配不了，就返回none，否则就返回一个匹配对象 re.match()的语法为：re.match(pattern, string, flags=0),其中pattern是正则表达式， string是要匹配的字符串， flags用来控制正则表达式的匹配方式，如是否区分大小写，多行匹配等 123456789101112import rem = re.match('www', 'www.baidu.com')print("匹配的结果为：",m)print("匹配的起点和终点：", m.span())print("起点为：", m.start())print("终点为：", m.end())"""匹配的结果为： &lt;re.Match object; span=(0, 3), match='www'&gt;匹配的起点和终点： (0, 3)起点为： 0终点为： 3请按任意键继续. . .""" 123456789101112line = "Fat cats are smarter than dogs, is it right?"m = re.match(r'(.*) are (.*?) ', line)print("匹配的整句话：", m.group(0))print("【匹配的第一个结果为：", m.group(1))print("匹配的第二个结果：", m.group(2))print("匹配结果的元组：", m.groups())"""匹配的整句话： Fat cats are smarter【匹配的第一个结果为： Fat cats匹配的第二个结果： smarter匹配结果的元组： ('Fat cats', 'smarter')""" 在match的模式前面加上r，r的意思表示的是raw string, 代表纯粹的字符串，使用它就不会对引号内的反斜杠进行特殊处理, 字符转义可以在前面加上r, 正则转义就得要在正则表达式内添加转义字符 \ 1234567print('hello\n world')print(r'hello\nworld')"""hello worldhello\nworld""" re.search() 扫描整个字符串并返回第一个成功的匹配 12345678m_match = re.match('com', 'www.baidu.com')m_search = re.search('com', 'www.baidu.com')print(m_match)print(m_search)"""None&lt;re.Match object; span=(10, 13), match='com'&gt;""" re.findall() match和search方法只能找到一个匹配所写的模式，findall可以找到所有的匹配， 返回匹配结果的列表 123456789101112re_string = '12345 is the first number, 23456 is the second number'm_match = re.match('[0-9]+', re_string)m_search = re.search('[0-9]+', re_string)m_findall = re.findall('[0-9]+', re_string)print(m_match.group())print(m_search.group())print(m_findall)"""1234512345['12345', '23456']""" re.compile() 返回一个匹配对象，通常与上述三种方法配合使用 123456789101112def main(): content = "hello hell to heatg othif" pattern = re.compile("\w*o\w*") re_content = pattern.findall(content) print(re_content)if __name__ == "__main__": main() """ ['hello', 'to', 'othif'] """ BeautifulSoup对象 BeautifulSoup对象 123html = urlopen('http://www.pythonscraping.com/pages/page3.html')bs = BeautifulSoup(html, 'html.parser')# BeautifulSoup对象 标签Tag对象 BeautifulSoup对象 通过find或者find_all 或者直接调用子标签获取一列对象或者单个对象：bs.div.h1 对于一个标签对象，可以获得他们的全部属性：tag.attrs 123images = bs.find_all('img', &#123;'src':re.compile('\.\.\/img\/gifts\/img.*\.jpg')&#125;) # 标签对象 由BeautifulSoup对象通过find或者find_all()函数获得# find_all()的第一个参数是标签，第二个attributes用一个python封装的属性和对应的属性值 NavigableString对象 用来表示标签里的文字，而不是标签本身 Comment对象 用来查找Html文档的注释标签, &lt;!--像这样--&gt;]]></content>
      <categories>
        <category>python网络爬虫</category>
      </categories>
      <tags>
        <tag>python网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷】P1316丢瓶盖]]></title>
    <url>%2F%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P1316%E4%B8%A2%E7%93%B6%E7%9B%96%2F</url>
    <content type="text"><![CDATA[题目描述陶陶是个贪玩的孩子，他在地上丢了A个瓶盖，为了简化问题，我们可以当作这A个瓶盖丢在一条直线上，现在他想从这些瓶盖里找出B个，使得距离最近的2个距离最大，他想知道，最大可以到多少呢？ 输入格式第一行，两个整数，A,B。（B&lt;=A&lt;=100000） 第二行，A个整数，分别为这A个瓶盖坐标。 输出格式仅一个整数，为所求答案。 输入输出样例输入 #1 125 31 2 3 4 5 输出 #1 12 说明/提示限时3秒 思路： 首先先了解一下二分答案，二分答案主要应用于求某某最小值中的最大值或者最大值中的最小值，我的个人理解是找到题目中的left和right,也就是我们搜索区间的上下界，然后假设mid为这个最优解，用check()函数进行判断。 针对于本次这道题，主要对check()函数的重写，我们先对数组进行排列，从第一个瓶盖开始，然后遍历这个数组，当下一个瓶盖arr[i] - arr[1] &gt;= mid，说明我们找到了瓶盖，然后times++,然后更新当前的起点的值，数组遍历完后进行判断瓶盖的次数即可。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[100005];int n, m;int check(int x)&#123; //int min = 0xffffffff; int times = 1; int temp = arr[1]; for (int i = 2; i &lt;= n; i++) &#123; if (arr[i] - temp &gt;= x) //注意这里要用等于号，因为确定一个瓶盖后，要从这个瓶盖开始做起点 &#123; times++; temp = arr[i]; &#125; &#125; if (times &gt;= m) //可选的瓶盖数大于m return 1; else return 0;&#125;int main()&#123; //int min, max; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; arr[i]; &#125; sort(arr+1, arr + n+1); //注意 例如我们排列一个a[10]的数组，sort(arr, arr+10)，所以依次类推，sort(arr+1, arr+10+1); /* for (int i = 1; i &lt;= n; i++) cout &lt;&lt; arr[i] &lt;&lt; " "; cout &lt;&lt; endl; */ //二分答案模板 int ans = 0; int left = 1; int right = arr[n] - arr[1]; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (check(mid)) &#123; left = mid + 1; if (mid &gt; ans) ans = mid; &#125; else right = mid - 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; system("pause"); return 0;&#125; 总结 这是一些模板题，主要是二分答案的模板 其次，对于二分答案，我的理解就是假设最优解在这个区间[left, right]中，然后用二分搜索找到这个mid最优解，所以就是确定上下区间 最后就是check()函数的问题]]></content>
      <categories>
        <category>OJ</category>
        <category>洛谷</category>
        <category>算法</category>
        <category>二分答案</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-pandas-常用方法]]></title>
    <url>%2Fpython-pandas-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[reindex重新索引12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import numpy as np import pandas as pd obj = pd.Series([1,2,3,4],index=['a','c','d','b'])print(obj)"""a 1c 2d 3b 4dtype: int64"""obj1 = obj.reindex(['a','b','c','d'])print(obj1)"""a 1b 4c 2d 3dtype: int64"""obj2 = obj.reindex(['a','b','c','d','fff'])print(obj2)"""a 1.0b 4.0c 2.0d 3.0fff NaNdtype: float64"""# reindex会根据新索引进行重排,如果某个索引值当期不存在,那么引入缺失值obj3 = pd.Series(['blue','yellow','black'],index=[0,2,4])obj3 = obj3.reindex(range(7), method='ffill')print(obj3)"""0 blue1 blue2 yellow3 yellow4 black5 blackdtype: object""""""0 blue1 blue2 yellow3 yellow4 black5 black6 blackdtype: object"""frame = pd.DataFrame(np.arange(9).reshape(3,3),index=['a','b','c'],columns=[11,22,33])print(frame)""" 11 22 33a 0 1 2b 3 4 5c 6 7 8"""frame = frame.reindex(['a','b','d','c']) # 只是传递一个序列,则只会重新索引行print(frame)columns_index = [11,22,33,'ddd']frame = frame.reindex(columns=columns_index,fill_value='hahah') #指定重新索引列,重新索引产生的缺失值由fill_value确定print(frame)""" 11 22 33 ddda 0.0 1.0 2.0 hahahb 3.0 4.0 5.0 hahahd NaN NaN NaN hahahc 6.0 7.0 8.0 hahah""" drop删除指定轴的值 drop函数返回的是一个新的对象，当然可以inplace=True进行指定，就是对原对象进行操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import numpy as np import pandas as pd obj = pd.Series(np.arange(5.), index=['a', 'b', 'c', 'd', 'e'])obj = obj.drop(['c']) #注意返回的是一个新的对象print(obj)obj = obj.drop(['a','b'])print(obj)"""a 0.0b 1.0d 3.0e 4.0dtype: float64d 3.0e 4.0dtype: float64"""obj.drop('e', inplace=True) #如果指定了inplace=True,那么drop函数就不会返回一个新的对象print(obj)"""d 3.0dtype: float64"""data = pd.DataFrame(np.arange(9).reshape(3,3), index=[1,2,3], columns=[7,8,9])print(data)data = data.drop(1) #如果不指定,默认删除的是0轴的index,行标签print(data)""" 7 8 92 3 4 53 6 7 8"""data = data.drop(7,axis = 1) #删除列标签print(data)""" 8 92 4 53 7 8""" 索引,选取，过滤 pandas的索引类似一个numpy，只不过是pandas的索引不只是数字 利⽤标签的切⽚运算与普通的Python切⽚运算不同，其末端是包含的 对于DataFrame对象，⽤⼀个值或序列对DataFrame进⾏索引其实就是获取⼀个或多个列, 使用切片,对行标签进行索引 通过布尔型数组索引进行过滤 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import pandas as pd import numpy as np data = pd.DataFrame(np.arange(9).reshape(3,3), index=list('abc'),columns=list('mnq'))print(data)""" m n qa 0 1 2b 3 4 5c 6 7 8"""# DataFrame使用[]默认时对列进行索引# ⽤⼀个值或序列对DataFrame进⾏索引其实就是获取⼀个或多个列# 使用列标签进行索引print(data['m'])"""a 0b 3c 6Name: m, dtype: int64"""# 使用序列对对列标签进行索引,注意索引多个列一定要用序列对进行索引print(data[['m','n']])""" m na 0 1b 3 4c 6 7"""# 使用切片对行标签进行索引# 使用默认行标签的序号进行索引,切片序号序列对索引,结果不包含末端索引print(data[0:2])""" m n qa 0 1 2b 3 4 5"""# 使用索引标签进行切片索引,末端索引有包含print(data['a':'c'])""" m n qa 0 1 2b 3 4 5c 6 7 8"""# 行列结合进行索引print(data[['m','n']]['a':'b'])""" m na 0 1b 3 4"""# 行列顺序不影响# 切片就是选择行,值或序列就是选择列print(data['a':'b']['m'])"""a 0b 3Name: m, dtype: int64"""# 存在问题:如果你的行便签是数字,,那么就会跟这个规则相互冲突# print(data[2][2])# print(data['a']['m'])# 记住规则:标签的切片运算和python的切片运算是不同,前者是包含末端的# 通过布尔型数组选取数据data1 = data &lt; 4print(data1)""" m n qa True True Trueb True False Falsec False False False"""print(data[data &lt; 4])""" m n qa 0.0 1.0 2.0b 3.0 NaN NaNc NaN NaN NaN"""print(data['n'] &gt; 3)"""a Falseb Truec TrueName: n, dtype: bool"""print(data[data['n']&gt;3])""" m n qb 3 4 5c 6 7 8""" ⽤loc和iloc进⾏选取 当处理一个DataFrame对象时，如果对象的行标签是一些整数，使用loc可以指定是标签索引，iloc是整数索引 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import pandas as pd import numpy as np data = pd.DataFrame(np.arange(16).reshape(4,4), index=list('abcd'), columns=list('qwer'))print(data)""" q w e ra 0 1 2 3b 4 5 6 7c 8 9 10 11"""print(data['q'])"""a 0b 4c 8d 12Name: q, dtype: int64"""print(data.loc['a':'c'])""" q w e ra 0 1 2 3b 4 5 6 7c 8 9 10 11"""print(data.loc[:, 'q'])"""a 0b 4c 8d 12Name: q, dtype: int64"""print(data.loc['a', 'w'])# 1print(data.loc['a':'c','q':'e']) #注意切片不用加中括号，只有在序列对的时候加""" q w ea 0 1 2b 4 5 6c 8 9 10"""print(data.loc[['a','c'],['q','e']]) #在序列对的时候加""" q ea 0 2c 8 10"""print(data.iloc[1])"""q 4w 5e 6r 7Name: b, dtype: int64"""print(data.iloc[0:2])""" q w e ra 0 1 2 3b 4 5 6 7"""print(data.iloc[1,2])# 6print(data.iloc[1:2, 1:2])""" wb 5"""# print(data.get_value('a', 'q'))"""get_value is deprecated and will be removed in a future release. Please use .at[] or .iat[] accessors instead"""print(data.at['a','q'])# 0print(data.iat[0,0])# 0 算术运算，数据对齐，数据填充123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import numpy as np import pandas as pd data1 = pd.DataFrame(np.arange(9).reshape(3,3), columns=list('abc'))data2 = pd.DataFrame(np.arange(12).reshape(3,4),columns=list('abde'))print(data1 + data2)# 两个对象相加，结果返回一个新的对象， index和columns为两个对象的并集，并且在缺失的地方引入缺失值NaNprint(data1.add(data2, fill_value=0))""" a b c d e0 0 2 NaN NaN NaN1 7 9 NaN NaN NaN2 14 16 NaN NaN NaN a b c d e0 0 2 2.0 2.0 3.01 7 9 5.0 6.0 7.02 14 16 8.0 10.0 11.0"""print(data1.add(data2, fill_value=1))# 由这个结果可以发现，算术运算的填充，有点类似于广播，首先广播使得两个DataFrame的形状相同，columns也相同，# 然后用fill_value填充，然后在进行算术运算""" a b c d e0 0 2 3.0 3.0 4.01 7 9 6.0 7.0 8.02 14 16 9.0 11.0 12.0"""# r表示翻z转参数print(data1.rdiv(1)) # 1/data1print(data1.div(1)) # data1 /1""" a b c0 inf 1.000000 0.5001 0.333333 0.250000 0.2002 0.166667 0.142857 0.125 a b c0 0.0 1.0 2.01 3.0 4.0 5.02 6.0 7.0 8.0"""]]></content>
      <categories>
        <category>Python数据分析</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷】P1025数的划分]]></title>
    <url>%2F%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P1025%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[题目描述将整数n分成k份，且每份不能为空，任意两个方案不相同(不考虑顺序)。 例如：n=7，k=3，下面三种分法被认为是相同的。 1,1,5 1,5,1 5,1,1 问有多少种不同的分法。 输入格式n,k (6&lt;n≤200，2≤k≤62 2≤k≤6) 输出格式1个整数，即不同的分法。 输入输出样例输入 #1 17 3 输出 #1 14 说明/提示四种分法为： 1,1,5 1,2,4 1,3,3 2,2,3 思路： dfs，剪枝 dp 把问题转换为n个球放在k个篮子的情况，所有的情况可以分为两种： 所有的篮子都有一个球及以上 至少有一个篮子只有一个球 因此，如果dp[n][k] 表示将n个小球放在k个篮子的不同放法：则dp[n][k] = dp[n-k][k] + dp[n-1][k-1]，然后递推起始条件当只有一个篮子的时候，只有一个方法，所以dp[n][1] = 1 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;/*int res = 0;void dfs(int times, int last, int sum) //sum表示剩下的数&#123; if (times == 1) &#123; res++; return; &#125; for (int i = last; i &lt;= sum / times; i++) dfs(times - 1, i, sum - i);&#125;int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; dfs(k, 1, n); cout &lt;&lt; res &lt;&lt; endl; //system("pause"); return 0;&#125;//递推法int solu(int n, int k)&#123; if (n &lt; k) return 0; if (n == k) return 1; if (k == 1) return 1; return solu(n - 1, k - 1) + solu(n - k, k);&#125;int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; int res = solu(n, k); cout &lt;&lt; res &lt;&lt; endl; //system("pause"); return 0;&#125;*///dp法int dp[300][10];int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; //预处理 for (int i = 0; i &lt;= 300; i++) &#123; dp[i][1] = 1; //dp[i][0] = 0; &#125; for (int i =1;i &lt;=n; i++) for (int j = 1; j &lt;= k &amp;&amp; j&lt;=i; j++) &#123; dp[i][j] = dp[i-j][j] + dp[i-1][j-1]; &#125; cout &lt;&lt; dp[n][k] &lt;&lt; endl;// system("pause"); return 0;&#125; 总结 dp太难了]]></content>
      <categories>
        <category>OJ</category>
        <category>洛谷</category>
        <category>算法</category>
        <category>递推与递归</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-pandas-常用数据对象]]></title>
    <url>%2Fpython-pandas-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[pandas常用数据对象Series 表示一维数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import pandas as pdimport numpy as np data = np.array([1,2,3])data1 = pd.Series(data=data,index=['guangzhou','shenzhen','shanghai'])print(data1)"""guangzhou 1shenzhen 2shanghai 3dtype: int64"""data2 = pd.Series(data=data)print(data2)"""0 11 22 3dtype: int64"""# data参数为一个数字或字符串data = 100data3 = pd.Series(data=data,index=['a','b'])print(data3)"""a 100b 100dtype: int64"""data = 'chenxiaojian'data4 = pd.Series(data=data,index=[1,2,3])print(data4)"""1 chenxiaojian2 chenxiaojian3 chenxiaojiandtype: object"""# data是字典# Series对象的标签索引由字典的Key来充任data = &#123;"chen":111,'xiao':222,'jian':333&#125;data5 = pd.Series(data=data)print(data5)"""chen 111xiao 222jian 333dtype: int64"""data6 = pd.Series(data=data,index=['chen','jian','xiao'])print(data6)"""chen 111jian 333xiao 222dtype: int64"""# 总结:也即是字典本来是无序的,但是index可以指定顺序,但是index的参数必须跟字典的key匹配# Series的对象属性print(data6.index)# Index(['chen', 'jian', 'xiao'], dtype='object')# print(data6.values)# [111 333 222]# 重新设置标签索引data6.index = ['CHEN','JIAN','XIAO']print(data6)"""CHEN 111JIAN 333XIAO 222dtype: int64"""# Series对象的name属性data6.name='我只测试一下'print(data6)"""CHEN 111JIAN 333XIAO 222Name: 我只测试一下, dtype: int64"""# 标签索引的namedata6.index.name='我是便签索引的Name'print(data6)"""我是便签索引的NameCHEN 111JIAN 333XIAO 222Name: 我只测试一下, dtype: int64""" DataFrame 存储二维数据 DataFrame对象的创建 数组创建DataFrame 嵌套字典创建DataFrame 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import numpy as npimport pandas as pd# 更新pandas ---== pip install --upgrade pandas# DataFrame存放二元数据# 数组创建DataFramearray_2 = np.arange(10, 20).reshape(5, 2)data = pd.DataFrame(data=array_2, columns=[1, 2], index=[2, 3, 4, 5, 6])# 设置里列号# index表示行索引标签,columns表示列索引标签print(data)""" 1 22 10 113 12 134 14 155 16 176 18 19"""# 字典作为datadata_dict = &#123;"city": ['beijing', 'huabei', 'hahha'], "marks": [1, 2, 3]&#125;data = pd.DataFrame(data=data_dict)print(data)""" city marks0 beijing 11 huabei 22 hahha 3"""# 总结:字典的key充当了列的标签索引# 数据格式转换# 字典转换为DataFramedict_data = &#123;"gdp": [111, 222, 333], "population": [999, 7777, 8888]&#125;dict_dataframe = pd.DataFrame.from_dict(dict_data)print(dict_dataframe)# 指定字典的Key作为lie的标签索引dict_dataframe = pd.DataFrame.from_dict(dict_data, orient='columns')print(dict_dataframe)""" gdp population0 111 9991 222 77772 333 8888"""# 指定字典的key作为行的标签索引dict_dataframe = pd.DataFrame.from_dict(dict_data, orient='index')print(dict_dataframe)""" 0 1 2gdp 111 222 333population 999 7777 8888"""# data : &#123;field:dict&#125;# 嵌套列表data_dict1 = &#123; "gdp": &#123; 'shanghai': 111, 'beijing': 222, 'guangzhou': '333' &#125;, "population": &#123; 'shanghai': 999, 'beijing': 888, 'guangzhou': 777 &#125;&#125;dict_dataframe_1 = pd.DataFrame.from_dict(data_dict1)print(dict_dataframe_1)""" gdp populationbeijing 222 888guangzhou 333 777shanghai 111 999"""# 如果嵌套中的列表的Key不相等的话就会如下""" gdp populationbeijing 222 888.0guanghzou 333 NaNguangzhou NaN 777.0shanghai 111 999.0"""dict_dataframe_2 = pd.DataFrame.from_dict(data_dict1, orient='index')print(dict_dataframe_2)""" shanghai beijing guangzhougdp 111 222 333population 999 888 777"""items = data_dict1.items()# 返回字典的key-values以元祖的形式print(items)# items_dataframe = pd.DataFrame.from_items(items)# 不推荐使用from_itemsitems_dataframe = pd.DataFrame.from_dict(dict(items))print(items_dataframe)data = np.arange(10).reshape(5, 2)index = ['上海', '深圳', '广州', '珠海', '汕头']columns = ['人口', 'GDP']gp = pd.DataFrame(data=data, index=index, columns=columns)# print(gp)gp.index.name = '城市名'gp.columns.name = '参数'print(gp)"""参数 人口 GDP城市名 上海 0 1深圳 2 3广州 4 5珠海 6 7汕头 8 9"""gp.to_csv("gp.csv",sep='|',columns=['人口'],header=1,index=0)# delimiter" must be a 1-character string 分隔符必须是一个字符# header表示是否显示列名# columns表示要显示的列# index表示是否显示索引列# gp.DataFrame.to_csv() 三维数据对象：Panel在0.25.0中被去除了…. Index对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import numpy as np import pandas as pd # s = pd.Series(np.random.randn)print(np.random.randn(5))# 从标准正太分布中返回样本s = pd.Series(np.random.randn(5))print(type(s))print(s)print(s.index)print(s.index[0])print(s.index[:3])"""[ 0.62266366 0.72416665 -0.86043632 -0.56794272 0.13975185]&lt;class 'pandas.core.series.Series'&gt;0 -1.2918721 0.7696222 -0.0599723 0.1284934 0.601371dtype: float64RangeIndex(start=0, stop=5, step=1)"""# 总结:Index对象有点类似于数组,可以直接索引访问,或者做数组切片,但是与数组的唯一不同点就是这个对象是不可变的# s.index[0] = 999 TypeError: Index does not support mutable operations# 通过类创建Index对象list_index = ['a','b','c','a']index = pd.Index(list_index)s = pd.Series([1,2,3,4],index=index)print(s)"""a 1b 2c 3a 4dtype: int64"""print(s['a'])"""a 1a 4dtype: int64"""# 对于Index对象,还可以把他看作为一个集合,但是不需要满足唯一性indexa = pd.Index([1,2,3,4])indexb = pd.Index([3,4,5,6])# 集合的运算print(indexa | indexb)print(indexa &amp; indexb)print(indexa ^ indexb)"""Int64Index([1, 2, 3, 4, 5, 6], dtype='int64')Int64Index([3, 4], dtype='int64')Int64Index([1, 2, 5, 6], dtype='int64')"""# 特殊情况indexc = pd.Index([1,2,1,5])print(indexc &amp; indexa)# Int64Index([1, 2, 1], dtype='int64')# # 结果不是像我们想象的集合的规则, MultIindex对象1234567891011121314151617181920212223242526272829303132333435363738import numpy as np import pandas as pdcities_index = ( ("china","beijing"),('china','shanghai'),('china','hongkong'),('usa','chicagp'),('usa','newyork'))cities = pd.MultiIndex.from_tuples(cities_index)# print(cities)data = pd.Series([1,2,3,4,5],index=cities)print(data)"""china beijing 1 shanghai 2 hongkong 3usa chicagp 4 newyork 5dtype: int64按任意键继续..."""print(data.unstack())""" beijing chicagp hongkong newyork shanghaichina 1.0 NaN 3.0 NaN 2.0usa NaN 4.0 NaN 5.0 NaN"""print(data.unstack().stack())"""china beijing 1.0 hongkong 3.0 shanghai 2.0usa chicagp 4.0 newyork 5.0dtype: float64"""]]></content>
      <categories>
        <category>Python数据分析</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-numpy基础04]]></title>
    <url>%2Fpython-numpy%E5%9F%BA%E7%A1%8004%2F</url>
    <content type="text"><![CDATA[矩阵创建矩阵的方式 字符串作为参数 矩阵作为参数 数组作为参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import numpy as np a = np.mat([1,2,3])print(a)print(a.shape)"""[[1 2 3]](1, 3)"""# 一个是矩阵,一个数组a = np.array([1,2,3])print(a)print(a.shape)"""[1 2 3](3,)"""# 创建矩阵# 字符串作为参数创建矩阵b = np.mat('1 2 3; 4 5 6; 7 8 9')print(b)print(b.shape)"""[[1 2 3] [4 5 6] [7 8 9]](3, 3)"""# 数组作为参数创建矩阵c = np.mat(a)print(c)print(c.shape)"""[[1 2 3]](1, 3)"""m1 = np.eye(2) #创建数组,对角线的值为1print(type(m1))m1 = np.mat(m1) #转换为数组print(type(m1)) """&lt;class 'numpy.ndarray'&gt;&lt;class 'numpy.matrixlib.defmatrix.matrix'&gt;"""m2 = 2 * m1print(m2)# 以矩阵作为参数创建矩阵d = np.bmat('m1 m2; m1 m2')print(d)"""[[1. 0. 2. 0.] [0. 1. 0. 2.] [1. 0. 2. 0.] [0. 1. 0. 2.]]""" 矩阵基本操作 相乘 转置矩阵 逆矩阵 123456789101112131415161718192021222324252627282930313233343536373839import numpy as np a = np.mat('1 2 3; 4 5 6; 7 8 9')print(a)#矩阵的转置print(a.T)print(a.getT())"""[[1 2 3] [4 5 6] [7 8 9]][[1 4 7] [2 5 8] [3 6 9]][[1 4 7] [2 5 8] [3 6 9]]"""# 逆矩阵print(a.I)"""[[ 3.15251974e+15 -6.30503948e+15 3.15251974e+15] [-6.30503948e+15 1.26100790e+16 -6.30503948e+15] [ 3.15251974e+15 -6.30503948e+15 3.15251974e+15]]"""# 单位矩阵a = np.mat(np.eye(4))print(a)"""[[1. 0. 0. 0.] [0. 1. 0. 0.] [0. 0. 1. 0.] [0. 0. 0. 1.]]""" 矢量运算标量积也称为数量积，点积（Dot Product)，内积（Inner Product） python的numpy提供的函数np.dot()和np.inner() numpy.dot() If both a and b are 1-D arrays, it is inner product of vectors (without complex conjugation). If both a and b are 2-D arrays, it is matrix multiplication, but using matmul or a @ b is preferred. If either a or b is 0-D (scalar), it is equivalent to multiply and using numpy.multiply(a, b) or a * b is preferred. If a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b. If a is an N-D array and b is an M-D array (where M&gt;=2), it is a sum product over the last axis of a and the second-to-last axis of b: 翻译： 两个数组的点积。 具体来说，如果a和b都是一维数组，则它是向量的内积（无复共轭）。 如果a和b均为二维数组，则为矩阵乘法，但最好使用matmul或a @ b。 如果a或b为0-D（标量），则等于乘以numpy.multiply（a，b）或a * b为首选。 如果a是N-D数组，b是1-D数组，则它是a和b的最后一个轴上的总和。 如果a是一个N-D数组而b是一个M-D数组（其中M&gt; = 2），则它是a的最后一个轴和b的倒数第二个轴的和积： numpy.inner() Ordinary inner product of vectors for 1-D arrays (without complex conjugation), in higher dimensions a sum product over the last axes. 翻译： 一维数组的向量的普通内积（无复共轭），在较高维度上，最后一个轴上的和积。 假设有两个矢量$\vec a = [a_1,a_2,a_3…a_n]$，$\vec b = [b_1,b_2,b_3…b_n]$，标量积的定义如下$$\vec a \cdot \vec b = \sum_1^na_ib_i = a_1b_1 + a_2b_2+…+a_nb_n$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 标量积# 一维向量a = np.array([1,2,3])b= np.array([4,5,6])print(np.dot(a,b))# 32print(np.inner(a,b))# 32# 总结:对于一维向量,这两个函数的作用相同# 二维向量c = np.array([[1,2],[3,4]])d = np.array([[5,6],[7,8]])print(np.dot(c,d)) # 类似矩阵的乘法运算"""[[19 22] [43 50]]"""print(np.inner(c,d))# 在较高维度上的和积# 1*5 + 2*6=17"""[[17 23] [39 53]]"""##三维数组a = np.arange(24).reshape((2,3,4))print(a)b = np.arange(4)print(b)"""[[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]][0 1 2 3]"""print(np.inner(a,b)) # Ordinary inner product of vectors for 1-D arrays (without complex conjugation), in higher dimensions a sum product over the last axes."""中文（简体）一维数组的向量的普通内积（无复共轭），在较高维度上，最后一个轴上的和积[[ 14 38 62] [ 86 110 134]] ==&gt; 0*0 + 1*1 + 2*2 + 3* 3 =14"""print(np.dot(a,b))# 根据官方文档：结果是3维数组的最后一维和1维数组的最后一维的和积"""[[ 14 38 62] [ 86 110 134]]""" 矢量积 vector Product，又可以称为叉积（cross Product），外积（outer Product），其运算结果是一个矢量，且矢量的方向与原来的两个矢量所构成的平面垂直 代数理解以三维坐标系中的两个矢量为例：$ \vec a=a_x\vec i+a_y\vec j + a_z\vec k$，和$ \vec b = b_x\vec i + b_y\vec j + b_z\vec k$，则(数学公式矩阵换行是3个”\\\“)$$\vec a \times \vec b = \begin{bmatrix} \vec i &amp; \vec j &amp; \vec k \\ a_x &amp; a_y &amp; a_z \\ b_x &amp; b_y &amp; b_z \end{bmatrix} = (a_yb_z - a_zb_y)\vec i + (a_zb_x-a_xb_z)\vec j + (a_xb_y-a_yb_x)\vec k$$注意：$\vec j的系数是a_zb_x-a_xb_z$， 几何理解平面直角坐标系的两个矢量$\vec a 和\vec b$，他们的夹角为$\theta$，那么这两个向量的矢量积的大小为$\vec a \times \vec b=\mid\vec a \mid \mid \vec b \mid \sin\theta$ numpy函数计算矢量积numpy.cross() 定义：The cross product of a and b in 三维坐标系 is a vector perpendicular to both a and b. If a and b are arrays of vectors, the vectors are defined by the last axis of a and b by default, and these axes can have dimensions 2 or 3. Where the dimension of either a or bis 2, the third component of the input vector is assumed to be zero and the cross product calculated accordingly. In cases where both input vectors have dimension 2, the z-component of the cross product is returned. 总结：向量的尺寸必须为2或3，如果a或b向量的尺寸为2，那么把这些向量的第三个分量当做0，如果a和b向量的尺寸都为2，那么返回第三个分量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import numpy as np # """a = np.array([1,2,3,4])# 向量的尺寸必须为2/3 a数组的尺寸为4b = np.array([5,6,7])print(np.cross(a,b))error: ValueErrorWhen the dimension of the vector(s) in a and/or b does not equal 2 or 3."""a = np.array([1,2,3])b = np.array([4,5,6])print(np.cross(a,b))# [-3 6 -3]# c = np.array([1,2])d = np.array([3,4])print(np.cross(c,d))# -2# 根据官方文档,当向量的尺寸为2时,当把第三个分量当作0,也就是[1,2,0]和[3,4,0],然后计算叉积,注意:如果这两个向量的尺寸都为2,则返回第三个分量c =np.array([1,2,0])d = np.array([3,4,5])print(np.cross(c,d))# [10 -5 -2]c = np.array([1,2])d = np.array([3,4,5])print(np.cross(c,d))# [10 -5 -2]x = [1,2,3]y = [4,5,6]print(np.cross(x,y))# [-3 6 -3]# 多维 x = np.array([[1,2,3], [4,5,6]])y = np.array([[4,5,6], [1,2,3]])print(np.cross(x, y))"""[[-3 6 -3] [ 3 -6 3]]"""x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])print(np.cross(x, y))"""[[ -6 12 -6] &lt;&lt;== [1 2 3] 和[7 8 9]做叉积 [ 0 0 0] [ 6 -12 6]]"""print(np.cross(x, y, axisa=0, axisb=0)) #改变向量的定义:axisa=-1表示第一个参数向量也即是x是横的表示也就是[1,2,3],axisa=0表示竖着读取,也就是[1,4,7] [2,5,6] [3,6,9]# axisb = -1表示表示第二个向量y是横着表示,同上"""[[-24 48 -24] &lt;&lt;== [1 4 7]和[7 4 1]做叉积 [-30 60 -30] [-36 72 -36]]"""print(np.cross(x,y,axisa=0,axisb=-1)) #第一个向量竖着看,第二个向量横着看"""[[-20 40 -20] [-10 20 -10] [ 0 0 0]]""" np.outer()这个函数名虽然看起来是外积，但是却是不等同于矢量积的别称外积 Given two vectors, a = [a0, a1, …, aM] and b = [b0, b1, …, bN], the outer product [1] is: 12345&gt; [[a0*b0 a0*b1 ... a0*bN ]&gt; [a1*b0 .&gt; [ ... .&gt; [aM*b0 aM*bN ]]&gt; 123456789a = [1,2,3]b =[4,5,6]print(np.outer(a,b))"""[[ 4 5 6] [ 8 10 12] [12 15 18]]""" 张量积numpy.tensordot()，这个函数就是可以指定一些特定的轴进行点乘 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import numpy as np a = np.random.randint(0,9,size=(2,4,5)) # random.randint(a,b) 返回[a,b)区间的整数print(a)"""[[[8 4 0 8 3] [1 5 2 0 5] [4 3 2 5 5] [4 0 7 1 3]] [[7 8 3 2 0] [8 4 4 2 4] [4 7 8 7 1] [1 5 0 4 3]]]"""b = np.random.randint(0,9,(4,5,2))print(b)"""[[[6 3] [7 5] [4 5] [4 7] [2 4]] [[3 0] [4 8] [7 3] [7 0] [0 4]] [[6 5] [6 2] [5 2] [1 7] [5 7]] [[2 8] [4 8] [6 5] [4 5] [5 0]]]"""print(np.tensordot(a,b,axes=((1,2),(0,1))).shape) #去除a的1轴和2轴,去除b的0轴和1轴,然后进行点乘# (2, 2)]]></content>
      <categories>
        <category>Python数据分析</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷】P1045麦森数]]></title>
    <url>%2F%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P1045%E9%BA%A6%E6%A3%AE%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述形如2P−12^{P}-12P−1的素数称为麦森数，这时PPP一定也是个素数。但反过来不一定，即如果PPP是个素数，2P−12^{P}-12P−1不一定也是素数。到1998年底，人们已找到了37个麦森数。最大的一个是P=3021377P=3021377P=3021377，它有909526位。麦森数有许多重要应用，它与完全数密切相关。 任务：从文件中输入PPP（1000&lt;P&lt;31000001000&lt;P&lt;31000001000&lt;P&lt;3100000），计算2P−12^{P}-12P−1的位数和最后500位数字（用十进制高精度数表示） 输入格式文件中只包含一个整数PPP（1000&lt;P&lt;31000001000&lt;P&lt;31000001000&lt;P&lt;3100000） 输出格式第一行：十进制高精度数2P−12^{P}-12P−1的位数。 第2-11行：十进制高精度数2P−12^{P}-12P−1的最后500位数字。（每行输出50位，共输出10行，不足500位时高位补0） 不必验证2P−12^{P}-12P−1与PPP是否为素数。 输入输出样例输入 #1 11279 输出 #1 123456789101138600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010407932194664399081925240327364085538615262247266704805319112350403608059673360298012239441732324184842421613954281007791383566248323464908139906605677320762924129509389220345773183349661583550472959420547689811211693677147548478866962501384438260291732348885311160828538416585028255604666224831890918801847068222203140521026698435488732958028878050869736186900714720710555703168729087 思路： 分为两个部分，首先输出位数，首先知道这个数的最后一个数不可能比1小，其次我们可以知道10^k的位数是k+1位，然后由下列等价公式可以得到这个数的位数 就是快速幂的高精度乘法 $$2^k-1 等价于 (10^{\log_{10}2})^k -1$$ 快速幂模板12345678int ans = 1;while (b)&#123; if (b &amp; 1) ans = ans * a; b &gt;&gt; = 1; a = a * a;&#125; AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// P1045 麦森数.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。#include "pch.h"#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;int res[1005];int a[1005];int temp[1005];void solution(int a[], int b[])&#123; memset(temp, 0, sizeof(temp)); temp[0] = a[0] + b[0]; if (temp[0] &gt;= 500) temp[0] = 500; for (int i = 1; i &lt;= temp[0]; i++) for (int j = 1; j &lt;= temp[0]; j++) &#123; temp[i + j - 1] += a[i] * b[j]; if (temp[i + j - 1] &gt;= 10) &#123; temp[i + j] += temp[i + j - 1] / 10; temp[i + j - 1] = temp[i + j - 1] % 10; &#125; &#125; for (int i = 0; i &lt;= 600; i++) a[i] = temp[i];&#125;int main()&#123; res[0] = res[1] = a[0] = 1; a[1] = 2; int n; cin &gt;&gt; n; cout &lt;&lt; int(log10(2) * n + 1) &lt;&lt; endl; while (n) &#123; if (n &amp; 1) solution(res, a); n &gt;&gt;= 1; solution(a, a); &#125; res[1]--; int times = 0; for (int i = 500; i &gt; 0; i--) &#123; cout &lt;&lt; res[i]; times++; if (times == 50) &#123; cout &lt;&lt; endl; times = 0; &#125; &#125; return 0;&#125; 总结： 数学问题，需要进一步熟悉高精度算法和快速幂算法]]></content>
      <categories>
        <category>OJ</category>
        <category>洛谷</category>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python网络爬虫]]></title>
    <url>%2Fpython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[请求头 accept:文本的格式 accept-coding:文本的编码格式 connection:长链接，短链接 cookie:做验证用的 host：域名 referer:表示从哪个网页跳转过来的 user-agent:浏览器和用户的信息]]></content>
      <categories>
        <category>python网络爬虫</category>
      </categories>
      <tags>
        <tag>python网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-numpy基础03]]></title>
    <url>%2Fpython-numpy%E5%9F%BA%E7%A1%8003%2F</url>
    <content type="text"><![CDATA[简单的统计函数 函数 说明 mean, average 计算平均值，加权平均值 var 计算方差 std 标准差 min,max 最小值，最大值 argmin,argmax 返回最小值，最大值的索引 ptp 计算全距，即最大值和最小值的差 percentile 计算百分位在统计对象中值 sum 计算统计对象的和 median 计算统计队形的中值 生成正态分布数据 np.random.normal () 标准正态分布：np.random.randn() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import numpy as np g = np.random.normal(loc=0,scale=1,size=50) # loc:浮点数,分布的平均值# scale:浮点数,分布的标准差# np.random.randn(size) 表示loc = 0.0,sclae=1.0的正态分布,称为标准正态分布print(g)g1 = np.random.randn(50)g = (g-g.min()) / 10phy = np.round(((100.1-20) * g + 20),1)g1 = (g1-g1.min()) / 10math = np.round(((100.1-20)*g1 + 20),1)print(np.mean(phy)) #平均值# 40.924print(np.min(phy), np.max(phy))# 20.0 49.3marks = np.vstack((phy, math))print(marks)"""[[54.7 41. 58.6 33.6 33.8 39.9 31.9 36. 51. 35.8 37.2 47.8 41.1 40.4 46.5 27.8 44.2 46. 48.6 36.4 39.2 37.3 43.8 37.1 45.3 20. 24.3 39.5 41.1 31.2 32.4 28. 46.1 30.8 40.5 43.8 52.6 41.6 40.2 39.7 32.3 45.6 28.6 48.8 39.8 35.9 44.9 23.9 42. 31.2] [47.1 41.5 20. 36.1 34.5 40.7 46.6 43.1 31.4 51.7 31.4 42.7 45.5 27.6 32.4 41.8 47.2 37.2 29.3 24.4 42. 21.3 39.5 41.6 35.3 36.5 39.6 35.6 53.4 40.5 37.3 47.6 37.8 37.9 43.9 54. 33. 50.8 38.7 35.3 29.8 31.2 40.1 56.7 34.1 51.6 34.9 33.9 45.4 39.5]]"""# 对统计函数指定轴进行计算print(np.mean(marks, axis = 1)) #会得到phy,math的平均值# [34.24 43.286]print(np.mean(marks,axis=0)) #两门学科的平均值"""[38.15 45.1 42.45 36.95 38.2 38.5 32.8 38.5 38.15 49. 39.4 45.05 41.15 44.05 44.95 47. 37.8 34.45 37.2 32. 39.25 48.4 41. 38. 37.05 38.75 31.5 45. 33.85 35.65 38.7 40.85 32.75 48.55 42.35 46.4 41.85 48.65 44.45 45.35 37.3 39. 45.05 51.9 38.2 39.6 26.7 46.5 40.4 37.15]"""]]></content>
      <categories>
        <category>Python数据分析</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python--numpy基础02]]></title>
    <url>%2Fpython-numpy%E5%9F%BA%E7%A1%8002%2F</url>
    <content type="text"><![CDATA[运算和通用函数算术运算 两个数组的shape相同时，可以进行算术运算，但是numpy中存在”广播“的机制，某些特殊情况也可以进行运算 12345678910111213141516171819202122232425262728293031import numpy as npdata = np.arange(10).reshape(2, 5)print(data)# [[0 1 2 3 4]# [5 6 7 8 9]]#数组支持算术运算，前提是这两个数组的形状相同，但是也是存在特殊情况 data1 = data * 3print(data1-data)# [[ 0 2 4 6 8]# [10 12 14 16 18]]print(data1 + data)# [[ 0 4 8 12 16]# [20 24 28 32 36]]print(data1 * data)# [[ 0 3 12 27 48]# [ 75 108 147 192 243]]data += 1print(data1 / data)# [[0. 1.5 2. 2.25 2.4 ]# [2.5 2.57142857 2.625 2.66666667 2.7 ]] 特殊的广播机制： 当两个数组的维数相同时，进行广播的A数组只能有一个轴上的元素个数与B数组上不同（例如：（1,2,3）和（1,2,3） 或者（1,2,3）和（1,1,3） 或者（1,2,3）和（1,2,1）），并且那个不同的轴上的元素个数必须为1 对于不同维数的数组，情况有些复杂，大致上是看尾维度，如果他们相等或者其中一个为1，例如 (2,3,4)和（3,4）他们的尾维度相同，可以进行广播 （2,3,4）和（1，）或者 （2,3,4）和（1,1） 特殊情况：不知道怎么解释（2,3,4）和（3,1）可以进行广播，但是（2,3,4）和（5,1）不可以，通过这个例子，我们从官方文档查阅得来的知识有时候是理解不了的，“其中一个为1到底指的是什么？=v=!!!” 此外：例如（2,3,4）和（3,4），广播就是将（3,4）在0轴上进行扩展 此外：对于一维数组的广播，例如：（2,3）和（3，），默认沿着0轴进行广播 总之，建议还是画图，(例如：将（2,3,4）和（3,1）写出来，你就发现他们可以进行广播[滑稽])将数据写出来，你就可以明白了吧，并且多做实验. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111data1 = np.array([[1,2,3],[2,3,4]])print(data1.shape) # (2,3)data2 = np.array([[1,2,3]])print(data2.shape) # (1,3)data1_data2 = data1 + data2 # (2,3)和(1,3)print(data1_data2)"""[[2 4 6] [3 5 7]] """data3 = np.array([1])print(data3.shape) # (1,) data1_data3 = data1 + data3 # (2,3)和(1,)print(data1_data3)"""[[2 3 4] [3 4 5]] """data3 = np.array([3])data1_data3 = data1 + data3 # (2,3)和(1,)print(data1_data3) """[[4 5 6] [5 6 7]] """data4 = np.array([10,10,10])print(data4.shape) # (3,)data1_data4 = data1 + data4 # (2,3)和(3,) 但是(2,3)和(4,)却不能进行广播,(2,3)和(2,)也不行print(data1_data4)"""[[11 12 13] [12 13 14]] """data5 = np.array([[3]])print(data5.shape) #(1,1)data1_data5 = data1 + data5 # (2,3)和(1,1)print(data1_data5)"""[[4 5 6] [5 6 7]] """data6 = np.array([[[1,2,3,4],[5,6,7,8],[9,10,11,12]],[[1,2,3,4],[5,6,7,8],[9,10,11,12]]])print(data6.shape) # (2,3,4)# data7 = np.array([[[1],[2]]])# print(data7.shape) #(1,2,1)data7 = np.arange(8).reshape(2,1,4)print(data7.shape) #(2, 1, 4)data6_data7 = data6 + data7 # (2,3,4)和（1,2,1）或者 (2,3,4)和(2,2,4)的数组不能进行广播,但是(2,3,4)和(2,1,4)能进行广播print(data6_data7)data8 = np.arange(4).reshape(2,2)# data1_data8 = data1 + data8 #(2,3)和(2,2)不能进行广播# print(data1_data8)data9 = np.arange(1,2,1).reshape(1,1) # (2,3,4)和(1,1)data6_data9 = data6 + data9print(data6_data9)"""[[[ 2 3 4 5] [ 6 7 8 9] [10 11 12 13]] [[ 2 3 4 5] [ 6 7 8 9] [10 11 12 13]]]"""data9 = np.arange(3).reshape(3,1) # (2,3,4)和(3,1)data6_data9 = data6 + data9print(data6_data9)"""原本的data6为：[[[1,2,3,4],[5,6,7,8],[9,10,11,12]], [[1,2,3,4],[5,6,7,8],[9,10,11,12] ] ]data9为： [ [0] , [1], [2]]广播后： [[[0,0,0,0],[1,1,1,1],[2,2,2,2]], [[0,0,0,0],[1,1,1,1],[2,2,2,2]]][[[ 1 2 3 4] [ 6 7 8 9] [11 12 13 14]] [[ 1 2 3 4] [ 6 7 8 9] [11 12 13 14]]]"""data9 = np.arange(5).reshape(5,1) # 不能执行(2,3,4)和(5,1)data6_data9 = data6 + data9print(data6_data9) 比较运算和逻辑运算 事实上，all（）操作就是对两个矩阵的比对结果再做一次与运算，而any则是做一次或运算 123456789101112131415161718192021222324252627282930313233# 比较运算和逻辑运算print (np.array([6,5,4]) &gt; np.array([1,5,6])) # 一一对应进行比较的# [ True False False]# # 逻辑运算符print(np.logical_or(np.array([True,False]), np.array([True, True])))# [ True True]a = np.array([3,6,9])b = np.array([4,5,8])print(np.any(a&gt;b) and np.any(a&lt;b)) # Trueprint(np.all(a&gt;b)) #False# 函数指定比较特定的轴a = np.array([[1],[2]])b = np.array([[3],[1]])print("============")print(np.any(a&gt;b))# Trueprint(np.all(a&gt;b))# False# 总结:np.any()函数运行过程:首先数组a和数组b进行比较运算,生成一个新的数组,然后在对这个数组的元素进行或运算# np.all(),:首先数组a和数组b进行比较运算,生成一个新的数组,然后在对这个数组的元素进行and运算 通用函数常用一元函数 函数 说明 np.sin,np.cos,np.tan 三角函数 np.arcsin,np.arccos,np.arctan 反三角函数 np.sinh,np.cosh,np.tanh 双曲三角函数 np.arcsinh,np.arccosh,np.arctanh 反双曲三角函数 np.sprt 平方根 np.exp 计算自然指数 np.log,np.log2,np.log10 计算对数（依次以e,2,10为底） 常用二元函数(以下函数省略np) 函数 说明 np.add, np.substract, np.multiply, np.divide 算术运算函数 equal , not_equal, less , less_equal , greater ,greater_equal 比较运算函数 power 指数运算 remainder 得到余数 reciprocal 返回倒数（不要使用整数型） real, imag, conj 返回复数的实部，虚部和完整的复数 sign, abs 得到对象符号和绝对值 floor , ceil , rint 结果得到整数 round 四舍五入 自定义函数 np.vectorize() np.frompyfunc()使用这两种函数可以将python函数转化为通用函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 自定义通用函数print(np.random.random_sample((4, 2)))"""[[0.95473307 0.36256674] [0.5869151 0.04447849] [0.25326141 0.23460101] [0.80424673 0.44243846]] """h = (2.2 - 1.4) * np.random.random_sample( (10, )) + 1.4 #表示随机生成10个[1.4,2.2]之间的数h = np.round(h, 2)print(h)# [2.2 1.58 1.75 1.59 2.05 1.61 1.81 1.84 2.17 2.04]w = (96 - 30) * np.random.random_sample((10, )) + 30w = np.round(w, 2)print(w)# [53.67 82.56 85.12 44.22 41.68 65.2 40.54 82.02 31.38 91.85]## 判断函数def mni(height, weight): bmi_index = weight / height ** 2 if bmi_index &gt; 18 and bmi_index &lt; 25: return 0 elif bmi_index &lt;= 18 : return -1 else: return 1# 列表解析print ([mni(h[i],w[i]) for i in range(len(h))])# [0, 0, -1, -1, -1, 0, 1, -1, 0, 1]bmi_ufunc = np.frompyfunc(mni, 2,1) #讲python函数转化为通用函数# np.frompyfunc(func,nin,nout):nin表示func函数所接收的参数个数,nout表示func函数返回的对象的个数print(bmi_ufunc(h,w))# [0 -1 0 -1 1 1 0 0 0 1]## np.vectorize()将Python函数转化为通用函数bmi_ufunc2 = np.vectorize(mni, otypes=[np.float]) #设置返回数组的元素类型print(bmi_ufunc2(h,w))# [ 1. -1. -1. 0. 0. 1. 1. -1. 0. -1.]]]></content>
      <categories>
        <category>Python数据分析</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中swap分区]]></title>
    <url>%2Flinux%E4%B8%ADswap%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[swap交换分区 Swap分区在系统的物理内存(这里应该是运行内存)不够用的时候，把物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中 ​ ——百度百科 创建swap分区 分区：fdisk命令，而parted命令（2T硬盘） 将分区格式化为swap分区 使用swap分区 free命令 查看系统内存使用情况和swap分区的使用情况 123456[root@chenxiaojian Desktop]# free -h total used free shared buffers cachedMem: 979M 911M 68M 14M 408K 316M-/+ buffers/cache: 594M 385MSwap: 0B 0B 0B[root@chenxiaojian Desktop]# buffers:表示缓冲区，例如我们用键盘打字时，就是先写入缓冲区，也就是说这个用于向文件中写数据时进行缓存的 cached：表示缓存区，当我们取数据时，我们可以不需要读取磁盘上的数据（磁盘读取太慢了），使用cached缓存更快的获得数据 创建swap分区的命令 分区：fdisk /dev/sdb 格式化分区：mkswap /dev/sdb1 启动分区：swapon /dev/sdb1 取消加入的分区：swapoff /dev/sdb1 设置开机自启：/dev/sdb1 swap swap defaults 0 0]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux中swap分区</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7_linux防火墙详解]]></title>
    <url>%2Fcentos7-linux%E9%98%B2%E7%81%AB%E5%A2%99%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[使用firewall-config进行配置 使用命令行进行配置（firewall-cmd） 常用命令：firewall-cmd –list-all / firewall-cmd –reload (重载） 使用firewall-cmd – + “tab键”进行查看命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[root@chenxiaojian ~]# firewall-cmd --add-service=http --permanent success[root@chenxiaojian ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 sources: services: ssh dhcpv6-client nfs ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@chenxiaojian ~]# firewall-cmd --list-all --permanent public target: default icmp-block-inversion: no interfaces: sources: services: ssh dhcpv6-client nfs http ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@chenxiaojian ~]# firewall-cmd --reload success[root@chenxiaojian ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 sources: services: ssh dhcpv6-client nfs http ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@chenxiaojian ~]# ^C[root@chenxiaojian ~]# 修改配置文件 /etc/firewalld (修改) /usr/lib/firewalld（默认配置文件） 123456789101112131415161718192021[root@chenxiaojian zones]# cd /etc/firewalld/[root@chenxiaojian firewalld]# ll总用量 8-rw-r--r--. 1 root root 2006 10月 31 2018 firewalld.confdrwxr-x---. 2 root root 6 10月 31 2018 helpersdrwxr-x---. 2 root root 6 10月 31 2018 icmptypesdrwxr-x---. 2 root root 6 10月 31 2018 ipsets-rw-r--r--. 1 root root 271 10月 31 2018 lockdown-whitelist.xmldrwxr-x---. 2 root root 6 10月 31 2018 servicesdrwxr-x---. 2 root root 46 9月 15 21:59 zones[root@chenxiaojian firewalld]# cat zones/public.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;zone&gt; &lt;short&gt;Public&lt;/short&gt; &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt; &lt;service name="ssh"/&gt; &lt;service name="dhcpv6-client"/&gt; &lt;service name="nfs"/&gt; &lt;service name="http"/&gt;&lt;/zone&gt;[root@chenxiaojian firewalld]# 1234567891011121314151617181920212223[root@chenxiaojian zones]# cd /usr/lib/alsa/ firmware/ java-1.6.0/ jvm-private/ modules-load.d/ sysctl.d/binfmt.d/ fontconfig/ java-1.7.0/ kbd/ mozilla/ systemd/crda/ games/ java-1.8.0/ kdump/ NetworkManager/ tmpfiles.d/cups/ gcc/ java-ext/ kernel/ polkit-1/ tuned/debug/ grub/ jvm/ locale/ python2.7/ udev/dracut/ java/ jvm-commmon/ modprobe.d/ rpm/ yum-plugins/firewalld/ java-1.5.0/ jvm-exports/ modules/ sse2/ [root@chenxiaojian zones]# cd /usr/lib/firewalld/[root@chenxiaojian firewalld]# lshelpers icmptypes ipsets services xmlschema zones[root@chenxiaojian firewalld]# ll zones/总用量 36-rw-r--r--. 1 root root 299 10月 31 2018 block.xml-rw-r--r--. 1 root root 293 10月 31 2018 dmz.xml-rw-r--r--. 1 root root 291 10月 31 2018 drop.xml-rw-r--r--. 1 root root 304 10月 31 2018 external.xml-rw-r--r--. 1 root root 369 10月 31 2018 home.xml-rw-r--r--. 1 root root 384 10月 31 2018 internal.xml-rw-r--r--. 1 root root 315 10月 31 2018 public.xml-rw-r--r--. 1 root root 162 10月 31 2018 trusted.xml-rw-r--r--. 1 root root 311 10月 31 2018 work.xml[root@chenxiaojian firewalld]# firewall的区域 123456789101112131415161718192021222324252627[root@chenxiaojian firewalld]# firewall-cmd --get-default-zone public# 网卡激活选择的区域是public[root@chenxiaojian firewalld]# firewall-cmd --get-active-zones public interfaces: ens33#查看特定区域的情况[root@chenxiaojian firewalld]# firewall-cmd --list-all --zone=public public (active) target: default icmp-block-inversion: no interfaces: ens33 sources: services: ssh dhcpv6-client nfs http ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: #查看区域[root@chenxiaojian firewalld]# firewall-cmd --get-zonesblock dmz drop external home internal public trusted work 检查排序(暂时不太能理解) 源地址关联区域 接口关联区域 默认区域 区域规则排序 端口转发和伪装 记录规则 允许规则 拒绝规则 默认规则 编写富规则建议还是用图形化界面进行配置吧！！ 富规则可以用在例如我们允许主机2登录主机1，但是不允许主机3登录主机1，这时我们可以先开发所有的主机访问主机1，然后设置富规则，拒绝主机3访问主机1 1234567891011121314151617181920#man手册查看富规则[chenxiaojian@chenxiaojian ~]$ man -k firewalldfirewall-cmd (1) - firewalld command line clientfirewall-config (1) - firewalld GUI configuration toolfirewall-offline-cmd (1) - firewalld offline command line clientfirewalld (1) - Dynamic Firewall Managerfirewalld.conf (5) - firewalld configuration filefirewalld.dbus (5) - firewalld D-Bus interface descriptionfirewalld.direct (5) - firewalld direct configuration filefirewalld.helper (5) - firewalld helper configuration filesfirewalld.icmptype (5) - firewalld icmptype configuration filesfirewalld.ipset (5) - firewalld ipset configuration filesfirewalld.lockdown-whitelist (5) - firewalld lockdown whitelist configuration filefirewalld.richlanguage (5) - Rich Language Documentationfirewalld.service (5) - firewalld service configuration filesfirewalld.zone (5) - firewalld zone configuration filesfirewalld.zones (5) - firewalld zones[chenxiaojian@chenxiaojian ~]$ man firewalld.richlanguage[chenxiaojian@chenxiaojian ~]$ 富规则语法 [source] [destination] 表示可选，如果省略，则代表所有主机 伪装 也就是说一个网卡跟外网连接，然后通过这个网卡传递数据到外网的ip地址都会转换为这个网卡的ip地址 直接开启网卡的伪装选项 进行富规则的编写实现伪装 端口转发forward-port 端口转发（Port forwarding），有时被叫做隧道，是安全壳(SSH) 为网络安全通信使用的一种方法。端口转发是转发一个网络端口从一个网络节点到另一个网络节点的行为，使得一个外部用户从外部经过一个被激活的NAT路由器到达一个在私有内部IP地址（局域网内部）上的一个端口。 也就是我们设置端口映射例如为80–》》8080，那么我们访问80，就自动访问到端口8080]]></content>
      <categories>
        <category>Linux</category>
        <category>firewall</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python——numpy基础01]]></title>
    <url>%2Fpython-numpy%E5%9F%BA%E7%A1%8001%2F</url>
    <content type="text"><![CDATA[数组对象常用属性 属性 说明 dtype 返回数组中元素的类型 shape 返回由整数组成的元组，元组中的每个整数依次对应数组的每个轴的元素个数 size 返回数组中元素的个数 ndim 返回数组的维度 函数创建数组array()1234567data = np.array([1,2,3,4],dtype=float)data#array([1., 2., 3., 4.])data=np.array([1,2,3,4],ndmin=2)data#array([[1, 2, 3, 4]]) 注意这里是代表二维 zeros()123456np.zeros((2,10))#(2,10)2表示0维度元素个数为2，1维度元素个数为10"""array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]])""" 123data = np.array([1,2,3,4])np.zeros_like(data) # 参数是一个数组，这个函数就能根据这个数组的维度创建数组，只不过元素的值变成0#array([0, 0, 0, 0]) 创建同一种元素的数组ones,ones_like/ zeors,zeros_like /empty,empty_like12345678910np.ones((2,5), dtype=int)"""array([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]])"""np.ones((2,5))"""array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]])""" 1234567891011121314151617data = np.array([[1,2,3,4],[2,2,3,4]])np.ones_like(data)"""array([[1, 1, 1, 1], [1, 1, 1, 1]]) """# 注意新建的数组会默认继承ones_like参数的类型data = np.array([[1,2.2,3,4],[2,2,3,4]])np.ones_like(data)"""array([[1., 1., 1., 1.], [1., 1., 1., 1.]])"""# 设置参数data = np.array([[1,2,3,4],[2,2,3,4]])np.ones_like(data,dtype=float) 创建其他数值的数组1234567891011121314da = np.array([[1,2,3,4],[5,5,5,5],[6,6,6,6]])df = 2 * np.ones_like(da)df"""array([[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]) """ np.full(da.shape, 3)"""array([[3, 3, 3, 3], [3, 3, 3, 3], [3, 3, 3, 3]]) """ 创建对角线数组 eys() identity() diag() 12345678910111213141516171819202122232425# eys()创建一个方阵，并且这个方阵的对角线可以调整np.eye(4,dtype=int)"""array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) """np.eye(4,dtype=int,k=1)"""array([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]]) """np.eye(4,dtype=int,k=-2)"""array([[0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0], [0, 1, 0, 0]]) """ 123456789101112131415#identity()不能移动对角线np.identity(4)"""array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) """np.identity(4,dtype=int)"""array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])""" 12345678910111213141516171819202122232425262728#对角线的元素的值可以有这个函数决定，也可以调整对角线的位置np.diag([1,2,3,4])"""array([[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]])"""np.diag((1,2,3,4))"""array([[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]) """#注意这里创建了一个5行5列的方阵np.diag([1,2,3,5],k=1)"""array([[0, 1, 0, 0, 0], [0, 0, 2, 0, 0], [0, 0, 0, 3, 0], [0, 0, 0, 0, 5], [0, 0, 0, 0, 0]]) """ 创建元素是等差等比数列12345678910111213# np.arange()创建一个类似于range()函数的数组np.arange(1,10,2)"""array([1, 3, 5, 7, 9])"""# np.linspace()函数，也就是说这个函数的第三个参数是这个数组的元素的个数#这个函数默认是包含右区间的，可以设置endpoint=false#Signature: np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)np.linspace(1,10,7)#array([ 1. , 2.5, 4. , 5.5, 7. , 8.5, 10. ]) 1234567# 创建的等比数列的函数# np.logspace()默认是以10为底的，start,end为指数#Signature: np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)np.logspace(2,5,4)#array([ 100., 1000., 10000., 100000.]) 数组的索引和切片数组的轴 123456789101112131415161718192021# 创建一个数组的结构为（2,3,4）a = np.arange(24).reshape((2,3,4))a"""array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]])""" a[1]"""array([[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]])"""a[1][1][2] #表示的是数组a的0轴方向索引为1的元素，1轴方向索引为1的元素，2轴方向索引为2的元素#18 根据索引取得数组的元素 跟列表的操作基本一致，可以根据数组的下标进行查看，修改 查看数组的元素的下标形式 array[1] / array[1,2] / array[(1,2)] / array[1][2] 1234567891011121314151617181920import numpy as npdata = np.arange(0,10,1).reshape(2,5)print(data)# [[0 1 2 3 4]# [5 6 7 8 9]]print(data[1])print(data[1][2])print(data[1,2])print(data[(1,2)])# 7# 7# 7# modify arraydata[1][2] = 9999print(data)# [[ 0 1 2 3 4]# [ 5 6 9999 8 9]] 通过下标是列表访问数组元素 1234567891011121314151617181920212223242526272829303132333435# 下标是列表获取数组元素import numpy as np data = np.arange(0,12,1).reshape(3,4)print(data)# [[ 0 1 2 3]# [ 4 5 6 7]# [ 8 9 10 11]]data1 = data[[0,1]]yuansuprint(data1)# [[0 1 2 3]# [4 5 6 7]]data2 = data[[0,1],[1,2]]print(data2)# [1 6]data3 = data[[1,2],[1,3]] print(data3)# [ 5 11]#一维数组a = np.arange(0,5,1)print(a)print(a[4])# [0 1 2 3 4]# 4# 总结：可以这么理解，#对于一个一维数组，访问元素就是根据c[a,b,v]列表中的元素进行索引，跟list一样#对于一个二维数组而言，若给出c[[a,b],[c,d]]那么就是去c[a,c]和c[b,d] 通过下标是数组访问数组元素12345678910111213data = np.arange(1,11)print(data)index = np.array([1,2,3,5])print("数组作为下标的：", data[index])# [1 2 3 4 5 6 7 8 9]# 数组作为下标的： [2 3 4 6]data1 = data.reshape(2,5)print(data1)print(data1[[1,1], [0,2]])data1 = data1[np.array([1,1]), np.array([0,2])] #等价于data1[[1,1],[0,2]]print(data1) 12345678910111213141516171819202122232425data1 = data.reshape(2,5)print(data1)print(data1[[1,1], [0,2]])data1 = data1[np.array([1,1]), np.array([0,2])] #等价于data1[[1,1],[0,2]]print(data1)t = data1 == 2p = data == 2print("t数组为：", t)print("p数组为：", p)# t数组为： [False False]# p数组为： [False True False False False False False False False False]data2 = data.reshape(2,5)print(data2)index1 = np.array([False, True])print("data2的数组：",data2[index1])# data2的数组： [[ 6 7 8 9 10]],# True取了0轴为真的一行print("数组中大于5的数字", data2[data2&gt;5])# 数组中大于5的数字 [ 6 7 8 9 10] 数组的切片需注意的是通过切片得到的数组与原数组共享一个内存空间 对于一维数组123456789101112131415161718192021222324252627import numpy as np# 数组真的切片# 一位数组a = np.arange(10, 20)print(a)b = a[2:8] #左开右闭print("b数组：", b)# [10 11 12 13 14 15 16 17 18 19]y# b数组： [12 13 14 15 16 17]b[0] = 9999print("b数组为：", b)print("a数组为：", a)# b数组为： [9999 13 14 15 16 17]# a数组为： [ 10 11 9999 13 14 15 16 17 18 19]print(a[::2])print(a[::-1])print(a[3:])# [ 10 9999 14 16 18]# [ 19 18 17 16 15 14 13 9999 11 10]# [13 14 15 16 17 18 19] 对于二维数组12345678910111213141516171819202122232425262728293031# 二维数组c = np.arange(0, 60, 10).reshape(-1, 1) + np.arange(0, 6)print(c)print(c[1:4])print(c[1:4, 2:5])print(c[:, 2])print(c[::2, ::2])print(c[:3, [0, 3]])"""[[10 11 12 13 14 15] [20 21 22 23 24 25] [30 31 32 33 34 35]][[12 13 14] [22 23 24] [32 33 34]][ 2 12 22 32 42 52][[ 0 2 4] [20 22 24] [40 42 44]] [[ 0 3] [10 13] [20 23]]""" 数组变形 np.narray.reshape()和np.reshape(array,(1,2))是返回一份拷贝，也就是说对其的操作不会影响到原来的数组本身 也可以用数组的属性array.shape = （1,10）进行变形 变为一维数组的函数： np.array.flatten() 返回的是一个拷贝 np.array.reval()与np.reval(array)返回的一份视图，对其操作会影响到原来的数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import numpy as npdata = np.arange(10)data1 = data.reshape(2, 5)print(data, data1)print(id(data), "hahahh", id(data1))# 139928707398352 hahahh 139928707398432#data2 = np.reshape(data, (2, 5)) print(data2)print(id(data2))# 140256722626560##一个是一维数组，一个是二维数组，只不过是0轴只有一个元素print(np.reshape(data, (10, )))print(np.reshape(data, (1, 10)))# [0 1 2 3 4 5 6 7 8 9]# [[0 1 2 3 4 5 6 7 8 9]]##numpy知道1轴上只有一个元素，然后就会自动推断0轴上有多少个元素data3 = np.reshape(data, (-1, 1))print(data3)# [[0]# [1]# [2]# [3]# [4]# [5]# [6]# [7]# [8]# [9]]# =============================data3.shape = (2, 5) #操作的是这个数组本身print(data3)# [[0 1 2 3 4]# [5 6 7 8 9]]# =============================#将数组设置为一维数组data4 = data1print(data4)p = data4.flatten() #生成一个新数组，并且相对原来数组不在同一个视图print(p)print(id(data4))print(id(p))"""[[0 1 2 3 4] [5 6 7 8 9]][0 1 2 3 4 5 6 7 8 9]140612501121984140612211456480"""data5 = np.ravel(data1) #与原数共享同一个视图print(data5)# [0 1 2 3 4 5 6 7 8 9]#data5[2] = 88888print("data5:", data5)print("data1:", data1)print(id(data5),id(data1))print(data5 is data1)# False# # data5: [ 0 1 88888 3 4 5 6 7 8 9]# data1: [[ 0 1 88888 3 4]# [ 5 6 7 8 9]] 常用方法astype() 能够根据指定的类型新生成一个数组 12345678910111213import numpy as npdata = np.array([[1,2,3],[2,3,4],[3,4,5]])new_data = data.astype(float)new_data, data"""(array([[1., 2., 3.], [2., 3., 4.], [3., 4., 5.]]), array([[1, 2, 3], [2, 3, 4], [3, 4, 5]]))""" np.expand_dims(array,axis) 增加数组的轴数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# =========================# # 对于这个函数，我们我们现在可以粗略地理解，就是增加一个轴，前提参数axis是合法的。然后数组的shape就是axis所在的轴变成为1，# 原先数组的轴往右移，例如：（1,2,3,4） axis=2 ==&gt;结果为：（1,2,1,3,4）# data6 = np.arange(0,9)print(data6)print(data6.shape)# [0 1 2 3 4 5 6 7 8]# (9,)data8 = np.expand_dims(data6,axis=0)print(data8)print(data8.shape)# [[0 1 2 3 4 5 6 7 8]]# (1, 9)data6 = np.expand_dims(data6, axis=1)print(data6)print(data6.shape)# [[0]# [1]# [2]# [3]# [4]# [5]# [6]# [7]# [8]]# (9, 1)# =========================data7 = np.array([[1,2,3],[4,5,6]])print(data7.shape)# (2,3)data7 = np.expand_dims(data7,axis=2)print(data7)print(data7.shape)# (2,3,1)# =========================data8 = np.array([[[1,2,3,4]]])print(data8.shape)print(data8)# (1, 1, 4)# [[[1 2 3 4]]]data8 = np.expand_dims(data8,axis=2)print(data8.shape)print(data8)# (1, 1, 1, 4)# [[[[1 2 3 4]]]]# =========================data9 = np.array([[[1,2,5],[3,4,6]]])print(data9.shape)print(data9)data9 = np.expand_dims(data9,axis=2)print(data9.shape)# [[[1 2 5]# [3 4 6]]]# (1, 2, 1, 3) np.concatenate((a,b),axis=0/1) 将数组a,b进行组合，当axis=0时表示垂直组合，当axis=1时表示水平组合 np.random.random_sample() 生成[0,1)之间随机数,np.random.random_sample((4,))表示生成一个4个元素的一维数组 np.random.random_sample((4,2))表示生成一个shape(4,2)的二维数组 12345678print(np.random.random_sample((4,2)))"""[[0.95473307 0.36256674] [0.5869151 0.04447849] [0.25326141 0.23460101] [0.80424673 0.44243846]] """ 数组的组合与分割水平组合–0轴方向形状一样 np.hstack(tuple)，参数为元组，包含被组合在一起的数组 1234567891011121314import numpy as np a = np.arange(9).reshape(3,3)b = np.arange(12).reshape(3,4)c = np.arange(15).reshape(3,5)# 水平组合:需要保证0轴上元素个数是相同的a_b = np.hstack((a,b))print(a_b)"""[[ 0 1 2 0 1 2 3] [ 3 4 5 4 5 6 7] [ 6 7 8 8 9 10 11]]""" 垂直组合–1轴方向形状一样 np.vstack(tuple) 1234567891011121314151617181920# 垂直组合：需要保证1轴上元素个数是相同的b1 = b.Tprint(b1)"""[[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] """ab1 = np.vstack((a,b1))print(ab1)# [[ 0 1 2]# [ 3 4 5]# [ 6 7 8]# [ 0 4 8]# [ 1 5 9]# [ 2 6 10]# [ 3 7 11]] 其他组合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#深度组合:可以想象为两个面平行，然后两个面对应的数进行组合a = np.arange(9).reshape(3,3)print(a)"""[[0 1 2] [3 4 5] [6 7 8]]"""b = a * 3print("array b ：",b)c = np.dstack((a,b))print ("数组c:",c)print(c.shape)"""数组c: [[[ 0 0] [ 1 3] [ 2 6]] [[ 3 9] [ 4 12] [ 5 15]] [[ 6 18] [ 7 21] [ 8 24]]](3, 3, 2)"""# 行组合data1 = np.arange(5)data2 = np.arange(5,10)data_column_add = np.column_stack((data1,data2))print("行组合为：", data_column_add)"""行组合为： [[0 5] [1 6] [2 7] [3 8] [4 9]] """print(data_column_add.shape) # (5,2)# 列组合data_row_add = np.row_stack((data1,data2))print("列组合为：",data_row_add)print(data_row_add.shape)"""列组合为： [[0 1 2 3 4] [5 6 7 8 9]](2, 5)""" 数组的分割1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 数组的分割data3 = np.arange(24).reshape(4, 6)print("data3为：", data3)"""data3为： [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23]]"""split_data3 = np.split(data3,2, axis=1) #对1轴进行分割print(split_data3)"""[array([[ 0, 1, 2], [ 6, 7, 8], [12, 13, 14], [18, 19, 20]]), array([[ 3, 4, 5], [ 9, 10, 11], [15, 16, 17], [21, 22, 23]])]"""split_data3_1 = np.split(data3, 2, axis=0) #对0轴进行分割print(split_data3_1)"""[array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]), array([[12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]])]"""# 专门针对某个方向的分割print(np.hsplit(data3,2))"""[array([[ 0, 1, 2], [ 6, 7, 8], [12, 13, 14], [18, 19, 20]]), array([[ 3, 4, 5], [ 9, 10, 11], [15, 16, 17], [21, 22, 23]])]"""print(np.vsplit(data3,2))"""[array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]]), array([[12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]])]""" 数组的改编（“增加”，“修改”，“删除”） np.append , np.delete, np.insert，这三种方法其实都是创建了一个新数组 12345678910111213141516171819202122232425262728293031323334353637383940414243# 数组的改编a = np.array([[2, 3, 4], [5, 6, 7]]) # shape (2,3)b = np.array([[7, 8, 9]])r = np.append(a, b, axis=0) #讲数组b追加到a的拷贝的0轴后面，对数组a没有任何影响print("数组r为：", r) # r的shape(3,3) --&gt;&gt;0轴多了一组元素"""数组r为： [[2 3 4] [5 6 7] [7 8 9]] """# append方法不声明轴，则意味着两个数组的元素创建一个新的一维数组r = np.append(a, b)print("r数组为:", r)# r数组为: [2 3 4 5 6 7 7 8 9]# 将某些元素插入到制定位置a1 = a.flatten()print("降维后：", a1)# 降维后： [2 3 4 5 6 7]r = np.insert(a1, 5, 99) #在索引为5的位置插入元素print("插入后数组为：", r)# 插入后数组为： [ 2 3 4 5 6 99 7]# 删除操作print("a数组为：", a)"""a数组为： [[2 3 4] [5 6 7]] """del_1 = np.delete(a, 1, axis=0) #删除0轴索引为1的print(del_1)# [[2 3 4]]del_2 = np.delete(a,0, axis=0)print(del_2)# [[5 6 7]]]]></content>
      <categories>
        <category>Python数据分析</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下jupyter_notebook的使用出现的问题]]></title>
    <url>%2Flinux%E4%B8%8Bjupyter-notebook%E7%9A%84%E4%BD%BF%E7%94%A8%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[针对鱼linux,首先这个jupyter ntebook新建一个python3的文件出现error,可能是由于防火墙的原因，关闭防火墙，或者开放8888端口 1systemctl stop firewall.service 啊啊啊啊啊啊啊啊]]></content>
      <categories>
        <category>Python数据分析</category>
        <category>配置问题</category>
      </categories>
      <tags>
        <tag>python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度算法]]></title>
    <url>%2F%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[高精度乘法（无符号） 算法的过程就是模拟我们手算乘法的过程 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//高精度乘法int main()&#123; string a, b; int arr[200]; int brr[200]; int crr[400]; cin &gt;&gt; a &gt;&gt; b; memset(arr, 0, sizeof(arr)); //赋值0 for (int i = 1; i &lt;= a.size(); i++) arr[i] = a[a.size() - i] - '0'; //将字符串a的高位(其实是数字的低位)存在数组arr的地位 for (int j = 1; j &lt;= b.size(); j++) brr[j] = b[b.size() - j] - '0'; memset(crr, 0, sizeof(crr)); for (int i = 1;i &lt;= a.size();i++) for (int j = 1; j &lt;= b.size(); j++) &#123; crr[i + j - 1] += arr[i] * brr[j]; //例如1234 X 23456 则存放类似 6*4=30 crr[i + j] += crr[i + j - 1] /10; //30大于10进位，--》》3 crr[i + j - 1] %= 10; //进完位，剩下的余数 &#125; //控制输出，清除高位的0，也就是确定这个积有多少位数 int result_length = a.size() + b.size(); while (crr[result_length] == 0) result_length--; for (int i = result_length; i &gt;0; i--) cout &lt;&lt; crr[i]; cout &lt;&lt; endl;&#125; 高精度加法（无符号） 模拟加法的过程 123456789101112131415161718192021222324252627282930313233343536int main()&#123; string a, b; cin &gt;&gt; a &gt;&gt; b; int arr[500]; int brr[500]; int crr[500]; memset(arr, 0, sizeof(arr)); memset(brr, 0, sizeof(brr)); memset(crr, 0, sizeof(crr)); for (int i = 1; i &lt;= a.size(); i++) arr[i] = a[a.size() - i] - '0'; for (int i = 1; i &lt;= b.size(); i++) brr[i] = b[b.size() - i] - '0'; int max_length = a.size() &gt; b.size() ? a.size() : b.size(); for (int i = 1; i &lt;= max_length; i++) &#123; crr[i] = arr[i] + brr[i]; crr[i + 1] += crr[i] / 10; crr[i] %= 10; &#125; max_length++; while (crr[max_length] == 0) &#123; max_length--; &#125; for (int i = max_length; i &gt; 0; i--) cout &lt;&lt; crr[i]; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>高精度</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux的http服务]]></title>
    <url>%2Flinux%E7%9A%84http%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[http服务 配置文件：/etc/httpd/conf/httpd.conf 配置文件内容： ServerRoot “/etc/httpd” 表示主要配置文件 DocumentRoot “/var/www/html” 表示访问主目录的路径 Listen 80 监听端口 &lt;Directory “/var/www/html”&gt; AllowOverride None # Allow open access: Require all granted&lt;/Directory&gt; 表示对这个/var/www文件的访问权限 Require all granted / denied &lt;RequireAll&gt; 设置特定主机名、ip地址不能访问 注意要加标签&lt;RequireAll&gt; require all granted require not ip/host &lt;内容&gt; &lt;/RequireAll&gt; 设置完成后记得重启服务，如果出现error systemctl status httpd -l，查看错误原因 ls -Z 查看文件的上下文]]></content>
      <categories>
        <category>Linux</category>
        <category>http</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程管理]]></title>
    <url>%2F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[进程管理进程是运行中的可执行程序，一个程序有一个或多个进程进程：内存地址空间，安全属性，一个或多个线程，状态父进程可以创建子进程 红帽7的第一个进程是systemd，所有进程都是第一个进程的后代，PID（进程id）,systemd的PID是1，PPID（父进程id） ps aux 查看所有终端，所有 用户，所有进程(静态的，查看某一个瞬间的信息) pstree查看进程树 进程有三种状态 R 运行状态 S 睡眠状态 T 暂时状态 ps aux 命令 查看所有终端，所有用户，所有用户的进程 tty表示终端，而pts是所谓的虚拟终端，具体表现为当你打开一个终端，这个终端就叫做pts/0，当你在打开另一个终端，这个终端就叫做pts/1 123456789101112# 查看当前终端的进程# tty1 表示当前终端# pts/0表示虚拟终端[root@chenxiaojian chenxiaojian]# ps a PID TTY STAT TIME COMMAND 8138 tty1 Ssl+ 0:13 /usr/bin/X :0 -background none -noreset -audit 4 -verbose -auth /run/gdm/aut 10434 pts/0 Ss 0:00 bash 11331 pts/0 S 0:00 su 11362 pts/0 S 0:00 bash 11922 pts/0 R+ 0:00 ps a[root@chenxiaojian chenxiaojian]# 12345678910111213# head默认是输出10行结果[root@chenxiaojian chenxiaojian]# ps aux | headUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.3 0.3 128560 7208 ? Ss 20:59 0:13 /usr/lib/systemd/systemd --switched-root --system --deserialize 22root 2 0.0 0.0 0 0 ? S 20:59 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? S 20:59 0:00 [ksoftirqd/0]root 5 0.0 0.0 0 0 ? S&lt; 20:59 0:00 [kworker/0:0H]root 7 0.0 0.0 0 0 ? S 20:59 0:00 [migration/0]root 8 0.0 0.0 0 0 ? S 20:59 0:00 [rcu_bh]root 9 0.0 0.0 0 0 ? R 20:59 0:02 [rcu_sched]root 10 0.0 0.0 0 0 ? S&lt; 20:59 0:00 [lru-add-drain]root 11 0.0 0.0 0 0 ? S 20:59 0:00 [watchdog/0] USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 1：代表这个进程是以什么用户进行执行 2：代表进程唯一标识ID 3：表示进程占用的CPU 4：表示进程占用的内存 5：VSZ表示虚拟内存 （虚拟内存，就是当物理内存不足时，将硬盘空间作为内存进行使用，Windows家族的“虚拟内存”；Linux的“交换空间“） 6：表示占用的物理内存 7：TTY表示进程用户登录的终端，如果是？，则表示是系统内部进程 8：表示进程的状态 （进程的状态参见https://blog.csdn.net/weixin_43116910/article/details/88544155） 9：进程开始的时间 10：进程执行了多少时间 11：表示进程的名称 top命令动态查看进程的状态 作业管理jobs查看 -l 可以查看进程的PID （ps j 可以查看） ctrl + c结束作业 ctrl + z暂停作业 fg % 进程号 —将进程调到前台进行运行 bg %进程号 —将进程调到后台进行运行 如果一个进程后面加个&amp; 表示在后台进行 [chenxiaojian@chenxiaojian ~]$ sleep 100&amp;[6] 19004[chenxiaojian@chenxiaojian ~]$ jobs[1]+ 已停止 sleep 1000[2] 已停止 sleep 1000[3] 已停止 sleep 1000[4] 已停止 sleep 1000[5]- 已停止 sleep 1000[6] 运行中 sleep 100 &amp;[chenxiaojian@chenxiaojian ~]$ kill命令 向进程发送信号，kill + PID 结束进程 （这个进程需是正在运行的） kill -l 查看所有的信号 15) SIGTERM（结束进程） 18) SIGCONT 19) SIGSTOP （暂时停止） 用法：kill -s 信号 进程ID 123456789101112131415161718192021[chenxiaojian@chenxiaojian ~]$ sleep 10000^Z[1]+ 已停止 sleep 10000[chenxiaojian@chenxiaojian ~]$ [chenxiaojian@chenxiaojian ~]$ [chenxiaojian@chenxiaojian ~]$ ps j PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 10412 10434 10434 10434 pts/0 20677 Ss 1000 0:00 bash 15446 15485 15485 15485 tty2 15485 Ss+ 1000 0:00 -bash 17494 17495 17495 10434 pts/0 20677 S 1000 0:00 bash 17495 20651 20651 10434 pts/0 20677 T 1000 0:00 sleep 10000 17495 20677 20677 10434 pts/0 20677 R+ 1000 0:00 ps j[chenxiaojian@chenxiaojian ~]$ kill -s 18 20651[chenxiaojian@chenxiaojian ~]$ ps j PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 10412 10434 10434 10434 pts/0 20703 Ss 1000 0:00 bash 15446 15485 15485 15485 tty2 15485 Ss+ 1000 0:00 -bash 17494 17495 17495 10434 pts/0 20703 S 1000 0:00 bash 17495 20651 20651 10434 pts/0 20703 S 1000 0:00 sleep 10000 17495 20703 20703 10434 pts/0 20703 R+ 1000 0:00 ps j[chenxiaojian@chenxiaojian ~]$ pkill命令 pkill + 进程名 pkill httpd killall命令 杀死一个进程所有的相关进程 nice 优先级 使用cpu，优先级越大（数值越小），使用CPU越优先 NI -20~19 nice -n &lt;优先级&gt; &lt;命令&gt; 指定命令运行的优先级 1234567891011121314151617[root@chenxiaojian chenxiaojian]# toptop - 22:11:20 up 18 min, 2 users, load average: 0.40, 0.29, 0.41Tasks: 290 total, 4 running, 286 sleeping, 0 stopped, 0 zombie%Cpu(s): 20.5 us, 10.4 sy, 0.0 ni, 68.7 id, 0.0 wa, 0.0 hi, 0.4 si, KiB Mem : 1863224 total, 166364 free, 775772 used, 921088 buff/caKiB Swap: 0 total, 0 free, 0 used. 836644 avail M PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ 9687 chenxia+ 20 0 3047484 194884 57180 S 14.1 10.5 0:12.69 8080 root 20 0 330764 56620 31216 R 9.5 3.0 0:04.84 11070 chenxia+ 20 0 840580 27216 15696 S 4.6 1.5 0:02.38 12472 root 20 0 162144 2440 1596 R 1.3 0.1 0:00.39 7054 root 20 0 320216 4504 3000 S 1.0 0.2 0:01.55 12331 root 20 0 0 0 0 S 1.0 0.0 0:00.03 1 root 20 0 128436 6664 3740 S 0.7 0.4 0:03.30 7846 root 20 0 1016748 10724 3624 S 0.3 0.6 0:01.01 renice 调整运行的程序的优先级 renice -n &lt;优先级&gt; -p SSH （安全外壳协议） 用来实现两台机器的远程登录和安全的数据传输，其保证数据安全的原理是非对称加密 传统的对称加密使用的是一个套秘匙，数据的加密以及解密用的都是这一套密匙，风险性较大 非对称加密就是为了解决这个问题，它包含两套密匙，公匙和私匙。公匙用来加密，私匙用来解密，公匙不能计算去私匙，所以公匙保存在客户端，也不会产生风险。 运行原理https://www.cnblogs.com/xz816111/p/9479139.html 实现免密登录 ssh-keygen命令 在客户端生成密钥对，输入ssh-keygen命令 ssh-copy-id &lt;服务器的ip地址&gt; （为第一次登录做准备） 下次直接登录就行啦！！！ 控制ssh /etc/ssh/sshd_config 配置文件 PasswordAuthentication yes 是否支持密码等录 PermitRootLogin yes 是否支持root用户登录 PubkeyAuthentication yes 是否支持公钥免密登 （记得重启ssd服务） scp 跨系统复制 文件 scp -r 192.168.18.132:/root/dir2 /root/ 从远端服务器拷贝到本机 -r表示拷贝目录 scp -r /root/dir1/ 192.168.18.132:/root/ 从本机拷贝文件/目录到远端服务器 SFTP &lt;服务器的ip&gt; 同步文件、rsync &lt;选项&gt; &lt;源文件&gt; &lt;目标文件&gt; -a 归档模式 -v 查看过程 -n表示空运行（就是执行这个选项后，会输出那些文件会同步，确认无误后就可以用-av进行同步了） 在两个系统间同步文件，只会同步不同的文件 123456789101112131415161718192021222324252627282930313233343536[root@chenxiaojian ~]# mkdir dir1 dir2[root@chenxiaojian ~]# ll总用量 8-rw-------. 1 root root 1694 9月 15 22:00 anaconda-ks.cfgdrwxr-xr-x. 2 root root 6 9月 27 11:27 dir1drwxr-xr-x. 2 root root 6 9月 27 11:27 dir2-rw-r--r--. 1 root root 1742 9月 15 22:03 initial-setup-ks.cfgdrwxr-xr-x. 2 root root 6 9月 20 21:37 公共drwxr-xr-x. 2 root root 6 9月 20 21:37 模板drwxr-xr-x. 2 root root 6 9月 20 21:37 视频drwxr-xr-x. 2 root root 6 9月 20 21:37 图片drwxr-xr-x. 2 root root 6 9月 20 21:37 文档drwxr-xr-x. 2 root root 6 9月 20 21:37 下载drwxr-xr-x. 2 root root 6 9月 20 21:37 音乐drwxr-xr-x. 2 root root 6 9月 20 21:37 桌面[root@chenxiaojian ~]# touch dir1/1.txt[root@chenxiaojian ~]# [root@chenxiaojian ~]# ls dir1 dir2dir1:1.txt[root@chenxiaojian ~]# rsync -av dir1 dir2sending incremental file listdir1/dir1/1.txtsent 119 bytes received 39 bytes 316.00 bytes/sectotal size is 0 speedup is 0.00[root@chenxiaojian ~]# ls dir1 dir2dir1:1.txtdir2:dir1[root@chenxiaojian ~]# 日志目录结构 systemctl status rsyslog 系统日志服务 systemctl status systemd-journal 收集日志服务 /var/log 日志目录 message 大部分日志 secure 安全 boot.log 系统启动的日志 配置文件/etc/rsyslog.conf 系统启动 graphical.target (图形化界面) muti-user.target 命令行 emergency.target 紧急模式 rescue.target 救援模式 systemctl set-default &lt;目标&gt; 永久 systemd.unit=&lt;目标&gt;，按ctrl + x 加载]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux红帽比赛需要注意的问题]]></title>
    <url>%2FLinux%E7%BA%A2%E5%B8%BD%E6%AF%94%E8%B5%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[查看本机的语言 echo $LANG，locale （查看本机安装的语言包）也可以设置ssh工具的语言编码第0道题 需要注意touch /.autorelabel的拼写 修改网卡的网络连接的配置信息，如果网卡的名字是system eth0,那么nmcli con modify时 要加双引号” connection的配置信息的文件为：/etc/sysconfig/network-scripts/ifcfg-ens33 （路径最后一个为网卡的名） 注意：修改配置文件时，添加ip为IPADDR1= 添加掩码为：PREFIX1= （需要注意的是IPADDR的1表示一个connection可以有多个Ip，那么PREFIX1后面的数字要对应），网关：GATEWAY1= DNS1= 记得重启网络 systemctl restart network 第一道题：设置selinux 永久生效 vim /etc/selinux/config 设置为enforcing 第二道题：yum源 /etc/yum.repo/*.repo yum-config-manager –add &lt;加源的地址&gt; 然后在往新生成的.repo文件中增加gpgcheck=0，执行yum clean all ,查看包数量–yum repolist 第三道题：扩容LVM 查看命令：lsblk df -Th pvs 、vgs lvs 首先查看vg是否有剩余空间，如果有，直接执行lvextend -L 700M /dev/vg1/lvm1 （这个路径可以查看） 创建好分区后，使用pvcreate /dev/sdb2，如果未找到设备，可以使用partprobe 可以使用fdisk -l /dev/sdb查看磁盘的信息，也可以进入fdisk /dev/sdb进入操作界面，p打印信息查看， fdisk -l查看所有磁盘的信息 问题：需要将分区的类型从默认的linux改为8e linux lvm 就能创建lvm吗 答案是不能：如果不修改分区的系统类型，重启就会进入紧急模式，可能是因为不能正确挂载然后出现错误 注意：lv + -L指定大小，-n指定名字 lvcreate -L 500M vg2 -n lvm2 lvextend -L 600M /dev/vg2/lvm2 重新识别文件大小resizeof 第四道题：用户与组 echo 123 | passwd –stdin user1 跟用户相关的三个文件 /etc/passwd /etc/group /etc/shadow 第五道题：文件权限 修改文件的所有者和所有组 chown : &lt;文件&gt; ACL特殊权限 第六道题：周期任务（分时日月周） crontab -e -u natasha -e表示编辑，u表示用户 第七到题：目录权限 记住UGOA 注意特殊权限 chomd g+s &lt;目录&gt; 该目录下的文件自动继承group名 第八道题：更新内核 注意wget命令，下载文件是下载到当前目录，如果没有指定-O，那么这个文件的默认命名就是网络链接的最后一个 / 后面的字符 然后安装，rpm -ivh &lt;包名&gt; uname -r 查看 rpm -ivh –force表示强制安装 第九题：LDAP第十题：autofs自动挂载第十一题：可能需要安装软件包yum -y install chrony 待完成任务：配置ssh https://wenku.baidu.com/view/6486caa384868762cbaed52e.html?sxts=1569289654410]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux需要注意的问题</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux网络配置]]></title>
    <url>%2FLinux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[网络配置device 设备：有物理设备（ens33） 虚拟设备 （virbr0）一个设备可以有多个connect（连接），但是同一个时间只能激活一个连接，相当于一个网卡可以切换不同的网络配置 网络管理 NetworkManager工具有nmcli , nmtui, nm-connection-editor使用这些工具的前提是NetworkManager这个服务有开着systemctl status NetworkManager 方便记忆：nm ==&gt; NetworkManager cli ==&gt; command line （命令行） tui ==&gt;text user interface （文本用户接口） nmcli命令行方式管理网络 nmcli connection 查看网络连接 nmcli device 查看网络设备 1234567891011[chenxiaojian@chenxiaojian ~]$ nmcli connection NAME UUID TYPE DEVICE ens33 fdb135ea-6548-47ca-9de3-f2d2fb390962 ethernet ens33 virbr0 7db188c9-a5ef-4000-ae38-925de7a46397 bridge virbr0 [chenxiaojian@chenxiaojian ~]$ nmcli deviceDEVICE TYPE STATE CONNECTION ens33 ethernet 连接的 ens33 virbr0 bridge 连接的 virbr0 lo loopback 未托管 -- virbr0-nic tun 未托管 -- [chenxiaojian@chenxiaojian ~]$ nmcli device show ens33 查看ens33这个网卡的网络配置 1234567891011121314151617181920[chenxiaojian@chenxiaojian ~]$ nmcli device show ens33GENERAL.DEVICE: ens33GENERAL.TYPE: ethernetGENERAL.HWADDR: 00:0C:29:21:50:C3GENERAL.MTU: 1500GENERAL.STATE: 100 (连接的)GENERAL.CONNECTION: ens33GENERAL.CON-PATH: /org/freedesktop/NetworkManager/ActiveConnection/1WIRED-PROPERTIES.CARRIER: 开IP4.ADDRESS[1]: 192.168.18.131/24IP4.GATEWAY: 192.168.18.2IP4.ROUTE[1]: dst = 0.0.0.0/0, nh = 192.168.18.2, mt = 100IP4.ROUTE[2]: dst = 192.168.18.0/24, nh = 0.0.0.0, mt = 100IP4.DNS[1]: 192.168.18.2IP4.DOMAIN[1]: localdomainIP6.ADDRESS[1]: fe80::f12e:225c:75ea:d0e4/64IP6.GATEWAY: --IP6.ROUTE[1]: dst = fe80::/64, nh = ::, mt = 100IP6.ROUTE[2]: dst = ff00::/8, nh = ::, mt = 256, table=255[chenxiaojian@chenxiaojian ~]$ \ add连接 （若忘记相关命令，按tab进行查看）con-name 表示连接名（自己设置） autoconnect 表示自动连接 ifname 表示接口名 （写网卡的名字） type ethernet （表示以太网） 123456789[chenxiaojian@chenxiaojian ~]$ nmcli connection add con-name ens33-con1 autoconnect yes ifname ens33 type ethernet ipv4.addresses 10.10.10.10/24 ipv4.gateway 10.10.10.254连接“ens33-con1”(fbd49c40-2e33-4fc7-87f5-1b06bc6a304d) 已成功添加。[chenxiaojian@chenxiaojian ~]$ nmcli connection NAME UUID TYPE DEVICE ens33 fdb135ea-6548-47ca-9de3-f2d2fb390962 ethernet ens33 virbr0 7db188c9-a5ef-4000-ae38-925de7a46397 bridge virbr0 ens33-con1 fbd49c40-2e33-4fc7-87f5-1b06bc6a304d ethernet -- [chenxiaojian@chenxiaojian ~]$ 123456789[chenxiaojian@chenxiaojian ~]$ ls /etc/sysconfig/network-scripts/ifcfg-ens33 ifdown-ippp ifdown-Team ifup-ib ifup-ppp init.ipv6-globalifcfg-ens33-con1 ifdown-ipv6 ifdown-TeamPort ifup-ippp ifup-routes network-functionsifcfg-lo ifdown-isdn ifdown-tunnel ifup-ipv6 ifup-sit network-functions-ipv6ifdown ifdown-post ifup ifup-isdn ifup-Team ifdown-bnep ifdown-ppp ifup-aliases ifup-plip ifup-TeamPort ifdown-eth ifdown-routes ifup-bnep ifup-plusb ifup-tunnel ifdown-ib ifdown-sit ifup-eth ifup-post ifup-wireless [chenxiaojian@chenxiaojian ~]$ ls /etc/sysconfig/network-scripts/ 可以发现，在/etc/sysconfig/network-scripts这个目录下创建了ifcfg-ens33-con1这个文件，这样如果我们想修改这个连接的配置，对这个文件进行修改就可以了 up 激活连接nmcli connection up &lt;连接名&gt; 12345678[chenxiaojian@chenxiaojian ~]$ nmcli connection up ens33-con1连接已成功激活（D-Bus 活动路径：/org/freedesktop/NetworkManager/ActiveConnection/4）[chenxiaojian@chenxiaojian ~]$ nmcli connection NAME UUID TYPE DEVICE ens33-con1 fbd49c40-2e33-4fc7-87f5-1b06bc6a304d ethernet ens33 virbr0 7db188c9-a5ef-4000-ae38-925de7a46397 bridge virbr0 ens33 fdb135ea-6548-47ca-9de3-f2d2fb390962 ethernet -- [chenxiaojian@chenxiaojian ~]$ 12345678910111213141516171819202122[chenxiaojian@chenxiaojian ~]$ ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:21:50:c3 brd ff:ff:ff:ff:ff:ff inet 192.168.18.131/24 brd 192.168.18.255 scope global noprefixroute dynamic ens33 valid_lft 1796sec preferred_lft 1796sec inet 10.10.10.10/24 brd 10.10.10.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::8e5a:83f1:7c40:6578/64 scope link noprefixroute valid_lft forever preferred_lft forever3: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000 link/ether 52:54:00:e1:6b:19 brd ff:ff:ff:ff:ff:ff inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0 valid_lft forever preferred_lft forever4: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN group default qlen 1000 link/ether 52:54:00:e1:6b:19 brd ff:ff:ff:ff:ff:ff[chenxiaojian@chenxiaojian ~]$ 可以看见ens33这个网卡多了个ip地址10.10.10.10/24 delete 删除连接nmcli connection delete &lt;连接名&gt; 1234567[chenxiaojian@chenxiaojian ~]$ nmcli connection delete ens33-con1成功删除连接 'ens33-con1'（fbd49c40-2e33-4fc7-87f5-1b06bc6a304d）。[chenxiaojian@chenxiaojian ~]$ nmcli connection NAME UUID TYPE DEVICE ens33 fdb135ea-6548-47ca-9de3-f2d2fb390962 ethernet ens33 virbr0 7db188c9-a5ef-4000-ae38-925de7a46397 bridge virbr0 [chenxiaojian@chenxiaojian ~]$ 相关技巧nmcli connection show ens33 | grep ipv4 查看ipv4的相关信息 ipv4.method – auto表示自动获取 –manual 表示人为设置 1234567891011121314151617181920212223[chenxiaojian@chenxiaojian ~]$ nmcli connection show ens33 | grep ipv4ipv4.method: autoipv4.dns: --ipv4.dns-search: --ipv4.dns-options: ""ipv4.dns-priority: 0ipv4.addresses: --ipv4.gateway: --ipv4.routes: --ipv4.route-metric: -1ipv4.route-table: 0 (unspec)ipv4.ignore-auto-routes: 否ipv4.ignore-auto-dns: 否ipv4.dhcp-client-id: --ipv4.dhcp-timeout: 0 (default)ipv4.dhcp-send-hostname: 是ipv4.dhcp-hostname: --ipv4.dhcp-fqdn: --ipv4.never-default: 否ipv4.may-fail: 是ipv4.dad-timeout: -1 (default)[chenxiaojian@chenxiaojian ~]$ 有关问题设置完静态ip后ip addr查看ip地址出现两个ip的原因cat /etc/sysconfig/network-scripts/ifcfg-ens33-con1中BOOTPROTO=HDCP，（引导协议）表示自动获取ip，所以当我们设置完成静态ip后，加上自动获取ip就会出现两个ip，这个也是允许的，也就是说一个connection可以设置多个ip 解决方法 如果有root用户权限，那么修改该连接的配置信息 vim /etc/sysconfig/network-scripts/ifcfg-ens33-con1 然后找到BOOTPROTO=HDCP将其改为none，表示手动设置，接着重载配置文件（修改完配置文件都要重载），三个步骤：nmcli connection reload ，nmcli connection down ens33-con1;nmcli connection up ens33-con1，至于最后一条命令为何要加分号，主要是当我们远程连接时，你down完后，网络也就断了 如果没有root权限，可以使用nmcli工具进行修改 nmcli connection modify ens33-con1 ipv4.method a 表示修改获取ipv4地址的方式为auto，如果设置为手动就设置为manual/m,然后进行同样的三个步骤 这个三个步骤，可以直接使用systemctl restart network （当NetworkManager不能使用的时候) 设置hostname （主机名的配置文件 /etc/hostname）12345678[chenxiaojian@chenxiaojian ~]$ hostnamectl set-hostname chen[chenxiaojian@chenxiaojian ~]$ [chenxiaojian@chenxiaojian ~]$ hostnamechen[chenxiaojian@chenxiaojian ~]$ cat /etc/hostnamechen[chenxiaojian@chenxiaojian ~]$ hostnamectl set-hostname chenxiaojian[chenxiaojian@chenxiaojian ~]$ 设置名字解析(校园网自家的DNS服务器的地址：192.168.18.2)hosts文件 /etc/hosts 这个文件其实没有多大的作用，但是如果你想Ping 主机名，一般来说，通常是不会Ping到的，因为DNS服务器没有你这个主机名对应的ip地址，如果想要实现这个ping chenxiaojian这个要求，可以在/etc/hosts进行编辑12345678910111213[root@chenxiaojian chenxiaojian]# cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 chenxiaojian::1 localhost localhost.localdomain localhost6 localhost6.localdomain6[root@chenxiaojian chenxiaojian]# ping chenxiaojianPING localhost (127.0.0.1) 56(84) bytes of data.64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.062 ms64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.149 ms64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.111 ms^C--- localhost ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2000msrtt min/avg/max/mdev = 0.062/0.107/0.149/0.036 ms[root@chenxiaojian chenxiaojian]# 通过DNS解析域名 cat /etc/resolv.conf DNS的配置文件不需要修改这个文件，对之前配置网路文件的修改会自动更新到这个文件 vim /etc/sysconfig/network-scripts/ifcfg-ens33 常用的网络测试工具 ip addr –ip地址 ip rout –路由表 ping ww.baidu,com ping -c2 www.baidu.com 接受两个包后结束 ip -s link show ens33 显示网卡接受包的详细信息 查看网卡是否连接 ethtool + &lt;网卡名&gt; 1234567[root@chenxiaojian chenxiaojian]# ip -s link show ens332: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether 00:0c:29:21:50:c3 brd ff:ff:ff:ff:ff:ff RX: bytes packets errors dropped overrun mcast 5696008 6763 0 0 0 0 TX: bytes packets errors dropped carrier collsns 459731 2879 0 0 0 0 123456789101112131415161718192021222324252627282930313233343536[root@chenxiaojian chenxiaojian]# ethtool ens33Settings for ens33: Supported ports: [ TP ] Supported link modes: 10baseT/Half 10baseT/Full 100baseT/Half 100baseT/Full 1000baseT/Full Supported pause frame use: No Supports auto-negotiation: Yes Supported FEC modes: Not reported Advertised link modes: 10baseT/Half 10baseT/Full 100baseT/Half 100baseT/Full 1000baseT/Full Advertised pause frame use: No Advertised auto-negotiation: Yes Advertised FEC modes: Not reported Speed: 1000Mb/s Duplex: Full Port: Twisted Pair PHYAD: 0 Transceiver: internal Auto-negotiation: on MDI-X: off (auto) Supports Wake-on: d Wake-on: d Current message level: 0x00000007 (7) drv probe link Link detected: yes[root@chenxiaojian chenxiaojian]# nmcli conNAME UUID TYPE DEVICE ens33 fdb135ea-6548-47ca-9de3-f2d2fb390962 ethernet ens33 virbr0 ba0275b4-23a5-4131-a3dc-412e0276bf5a bridge virbr0 有线连接 1 f496b294-a26f-3b0b-a738-6735c9b47f89 ethernet -- [root@chenxiaojian chenxiaojian]# ethtool virbr0Settings for virbr0: Link detected: no[root@chenxiaojian chenxiaojian]#]]></content>
      <categories>
        <category>Linux</category>
        <category>网络配置</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时钟同步和定时任务]]></title>
    <url>%2F%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[时钟同步日志，多系统协作，分布式 NTP（网络时钟协议）使用图形化连接到时钟服务器 安装软件包 yum -y install system-config-date 运行system-config-date system-config-date 使用命令行连接到时钟服务器 vim /etc/chrony.conf consider joining the pool (http://www.pool.ntp.org/join.html).server 0.centos.pool.ntp.org iburstserver 1.centos.pool.ntp.org iburstserver 2.centos.pool.ntp.org iburstserver 3.centos.pool.ntp.org iburst （centos7默认连接的时钟服务器，server + 服务器地址 + iburst） 重启服务 systemctl restart chrony timedatectl命令设置系统时间与日期 设置时区，可以先查看时区表是否有所设定的时区 12[chenxiaojian@chenxiaojian ~]$ timedatectl list-timezones | grep -i shangAsia/Shanghai 查看信息 123456789[chenxiaojian@chenxiaojian ~]$ timedatectl status Local time: 五 2019-09-20 17:28:43 CST Universal time: 五 2019-09-20 09:28:43 UTC RTC time: 五 2019-09-20 09:28:44 Time zone: Asia/Shanghai (CST, +0800) NTP enabled: noNTP synchronized: no RTC in local TZ: no DST active: n/a 设置 nfp timedatectl set-ntp true 计划任务计划一次性任务at &lt;时间&gt; at&gt; 命令 按ctrl + D结束 atq查看任务 atrm 删除任务 123456789[chenxiaojian@chenxiaojian ~]$ at 17.36at&gt; echo helloat&gt; &lt;EOT&gt;job 1 at Fri Sep 20 17:36:00 2019[chenxiaojian@chenxiaojian ~]$ atq1 Fri Sep 20 17:36:00 2019 a chenxiaojian[chenxiaojian@chenxiaojian ~]$ 您在 /var/spool/mail/chenxiaojian 中有新邮件[chenxiaojian@chenxiaojian ~]$ 计划周期任务crontab -e 编辑 -l 查看 -r 删除 -u root用户为其他用户设置任务 例子： crontab -e crontab -e -u chenxiaojian 格式： 分 时 日 月 星期 命令 * * * * * 代表每一分钟 N 设置数字 （0和7代表星期一和星期天） */N 表示每N的意思 n-N 表示从n到N这段时间 n, N 表示两个时间]]></content>
      <categories>
        <category>Linux</category>
        <category>时钟同步和定时任务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷】P1498南蛮图腾与杨辉三角的应用]]></title>
    <url>%2F%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P1498%E5%8D%97%E8%9B%AE%E5%9B%BE%E8%85%BE%E4%B8%8E%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[打印杨辉三角12345678910111213141516171819202122232425262728293031323334353637// P1498 南蛮图腾.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include "pch.h"#include &lt;iostream&gt;using namespace std;int yhsj[15][15];int main()&#123; int n; cin &gt;&gt; n; yhsj[1][1] = 1; for (int i = 2; i &lt;= pow(2, n); i++) &#123; for (int j = 1; j &lt;= pow(2, n); j++) &#123; yhsj[i][j] = yhsj[i-1][j-1] + yhsj[i-1][j]; &#125; &#125; int nums = 1; //代表每行要输出的个数 for (int i = 1; i &lt;= pow(2,n); i++) &#123; int space_times = pow(2,n) - nums; for (int k = 0; k &lt; space_times; k++) //输出空格 cout &lt;&lt; " "; for (int j = 1; j &lt;= nums; j++) &#123; cout &lt;&lt; yhsj[i][j] &lt;&lt; " "; &#125; nums++; cout &lt;&lt; endl; &#125; return 0;&#125; 题目描述自从到了南蛮之地，孔明不仅把孟获收拾的服服帖帖，而且还发现了不少少数民族的智慧，他发现少数民族的图腾往往有着一种分形的效果，在得到了酋长的传授后，孔明掌握了不少绘图技术，但唯独不会画他们的图腾，于是他找上了你的爷爷的爷爷的爷爷的爷爷……帮忙，作为一个好孙子的孙子的孙子的孙子……你能做到吗？ 输入格式每个数据一个数字，表示图腾的大小（此大小非彼大小） n&lt;=10 输出格式这个大小的图腾 输入输出样例输入 #1 12 输出 #1 1234 /\ /__\ /\ /\/__\/__\ 输入 #2 13 输出 #2 12345678 /\ /__\ /\ /\ /__\/__\ /\ /\ /__\ /__\ /\ /\ /\ /\/__\/__\/__\/__\ 第一种思路：可以用一个二维数组存放1024行的杨辉三角的值，然后让他们对2取模，然后输出杨辉三角的时如果碰到一个1，就是输出/\，如果碰到两个1，就是输出/__,如果碰到0就输出两个空格； 但是这种思路有个严重的bug,就是用long long存放不下杨辉三角1024行的数的值 Long long能够存放的十进制大概是19位 有bug的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// P1498 南蛮图腾.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include "pch.h"#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;long long yhsj[1050][1050]; //注意长度要大于2的10次方 需要注意的问题就是可能存不下=v=int main()&#123; int n; cin &gt;&gt; n; yhsj[1][1] = 1; for (int i = 2; i &lt;= pow(2, n); i++) &#123; for (int j = 1; j &lt;= pow(2, n); j++) &#123; yhsj[i][j] = yhsj[i-1][j-1] + yhsj[i-1][j]; &#125; &#125; //cout &lt;&lt; yhsj[1024][505] &lt;&lt; endl; //system("pause"); int nums = 1; for (int i = 1; i &lt;= pow(2,n); i++) &#123; int space_times = pow(2,n) - nums; for (int k = 0; k &lt; space_times; k++) cout &lt;&lt; " "; for (int j = 1; j &lt;= nums; j++) &#123; yhsj[i][j] %= 2; &#125; for (int j = 1; j &lt;= nums; j++) &#123; if (yhsj[i][j] == 1) &#123; if (yhsj[i][j + 1] == 1) &#123; cout &lt;&lt; "/__\\"; j++; &#125; else &#123; cout &lt;&lt; "/\\"; &#125; &#125; else if (yhsj[i][j] == 0) cout &lt;&lt; " "; &#125; nums++; cout &lt;&lt; endl; &#125; return 0;&#125; bug修改因为杨辉三角在递推的过程中值不断增大，但是我们只是对他们的值进行取模，如果一开始生成第一行数就进行取模，那么后面的数也就是不会能大了 123456789for (int i = 2; i &lt;= pow(2, n); i++) &#123; for (int j = 1; j &lt;= pow(2, n); j++) &#123; yhsj[i][j] = yhsj[i-1][j-1] + yhsj[i-1][j]; //因为这样递加下去，难免超过Long long,但是可以发现在这里进行取模，对后面生成的数没有任何影响， // 因为取模后值还是没有变化的 yhsj[i][j] %= 2; &#125; &#125; AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// P1498 南蛮图腾.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include "pch.h"#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;long long yhsj[1050][1050]; //注意长度要大于2的10次方 需要注意的问题就是可能存不下=v=int main()&#123; int n; cin &gt;&gt; n; yhsj[1][1] = 1; for (int i = 2; i &lt;= pow(2, n); i++) &#123; for (int j = 1; j &lt;= pow(2, n); j++) &#123; yhsj[i][j] = yhsj[i-1][j-1] + yhsj[i-1][j]; //因为这样递加下去，难免超过Long long,但是可以发现在这里进行取模，对后面生成的数没有任何影响， // 因为取模后值还是没有变化的 yhsj[i][j] %= 2; &#125; &#125; //cout &lt;&lt; yhsj[1024][505] &lt;&lt; endl; //system("pause"); int nums = 1; for (int i = 1; i &lt;= pow(2,n); i++) &#123; int space_times = pow(2,n) - nums; for (int k = 0; k &lt; space_times; k++) cout &lt;&lt; " "; // for (int j = 1; j &lt;= nums; j++) // &#123; // yhsj[i][j] %= 2; // &#125; for (int j = 1; j &lt;= nums; j++) &#123; if (yhsj[i][j] == 1) &#123; if (yhsj[i][j + 1] == 1) &#123; cout &lt;&lt; "/__\\"; j++; &#125; else &#123; cout &lt;&lt; "/\\"; &#125; &#125; else if (yhsj[i][j] == 0) cout &lt;&lt; " "; &#125; nums++; cout &lt;&lt; endl; &#125; return 0;&#125; 总结 需要注意值的最大范围 此外，这些输入题通常是找规律而言，倘若知道规律，那么对解题有很大的帮助 脑子依旧是个好东西，我还没有=v=]]></content>
      <categories>
        <category>OJ</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>杨辉三角</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序--逆序对]]></title>
    <url>%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[归并排序将两个或两个以上的有序表合并成一个有序表的过程 时间复杂度：O(nlog2n) 空间复杂度：需要一个辅助数组空间，复杂度为O(n) 题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 Update:数据已加强。 输入格式第一行，一个数n，表示序列中有n个数。 第二行n个数，表示给定的序列。序列中每个数字不超过10910^9109 输出格式给定序列中逆序对的数目。 输入输出样例输入 #1 1265 4 2 6 3 1 输出 #1 111 说明/提示对于25%的数据，n≤2500n \leq 2500n≤2500 对于50%的数据，n≤4×104n \leq 4 \times 10^4n≤4×104。 对于所有数据，n≤5×105n \leq 5 \times 10^5n≤5×105 请使用较快的输入输出 应该不会n方过50万吧 by chen_zhe 思路：暴力比较肯定会超时，需要进行n!次比较，可以使用归并排序，唯一需要处理的就是在归并比较判断大小排序时，可以对res（表示逆序对的个数）进行更新，例如：[5 4 ] [8 3 2 1]，因为每一个区间都是一个有序表，所以将这两个区间进行归并的时候，比较，如果5大于3后，那么5肯定也大小第二个区间后面的所有的数，所有这时候就可以进行更新res的值。、 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// P1908 逆序对.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include "pch.h"#include &lt;iostream&gt;using namespace std;int arr[500008];int temp[500008];long long n;int res = 0;void merge(int low,int high, int mid)&#123; int i = low; int j = mid+1; int k = low; while (i &lt;= mid &amp;&amp; j&lt;=high) &#123; if (arr[i] &gt; arr[j]) &#123; temp[k++] = arr[i++]; res += high - j+1; //加上剩下的个数 &#125; else temp[k++] = arr[j++]; &#125; while (i &lt;= mid) temp[k++] = arr[i++]; while (j &lt;= high) temp[k++] = arr[j++]; for (int i = low; i &lt;= high; i++) //更新arr数组 arr[i] = temp[i];&#125;void f(int low, int high)&#123; if (low &lt; high) &#123; int mid = (low + high) / 2; f(low, mid); f(mid + 1, high); merge(low, high, mid); &#125;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; arr[i]; f(1, n); cout &lt;&lt; res &lt;&lt; endl; &#125; 总结 认识到了如何用递归实现归并排序，且要注意，归并好两个区间的值后，要更新原来的数组，注意！！！ 待完成：用迭代实现归并排序]]></content>
      <categories>
        <category>OJ</category>
        <category>洛谷</category>
        <category>算法</category>
        <category>排序算法</category>
        <category>归并排序</category>
      </categories>
      <tags>
        <tag>归并</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NFS网络文件系统]]></title>
    <url>%2FNFS%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[NFS网络文件系统–文件共享–目录 配置NFS服务 安装软软件包 yum -y install nfs-utils 配置文件 vim /etc/exports 格式： 共享目录 客户端列表（选项） /nfs *(rw) 123[root@chenxiaojian chenxiaojian]# vim /etc/exports[root@chenxiaojian chenxiaojian]# cat /etc/exports/nfs *(rw) 创建共享目录 mkdir /nfs 重载配置文件 exportfs -rv 启动nfs服务 systemctl enable nfs 设置开机启动 systemctl start nfs systemctl status nfs 防火墙 firewall-cmd –add-service=nfs –permanent 查看是否成功： ip addr 查看ip地址 123t@chenxiaojian /]# showmount -e 192.168.18.131Export list for 192.168.18.131:/nfs * 客户端挂载 （vim /etc/fstab） 192.168.18.131:/nfs /mnt/nfs nfs defaults 0 0 查看信息 mount命令 12192.168.18.131:/nfs on /mnt/nfs type nfs4 (rw,relatime,vers=4.1,rsize=262144,wsize=262144,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.18.131,local_lock=none,addr=192.168.18.131)[root@chenxiaojian nfs]# 例如：hard表示就是请求nfs服务时，会等到响应才结束，可以设置soft （已解决） 123456789101112131415[root@chenxiaojian nfs]# cat /etc/fstab## /etc/fstab# Created by anaconda on Sun Sep 15 21:47:41 2019## Accessible filesystems, by reference, are maintained under '/dev/disk'# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#/dev/mapper/centos_chenxiaojian-root / xfs defaults 0 0UUID=cad510ce-5467-4544-89aa-efd687b4ac39 /boot xfs defaults 0 0/dev/mapper/cetos_chenxiaojian-swap swap swap defaults 0 0192.168.18.131:/nfs /mnt/nfs nfs rw,soft defaults 0 0# 对文件系统挂载表进行配置就可以了...# 此外，修改完成后，有些需要重启才能看得到效果 (注意加逗号，配置soft软挂载) 自动挂载 AutoFS自动挂载 通过脚本实现 优点：节省资源 样例1：通过AutoFS挂载本地镜像 安装软件包 yum -y install autofs 修改配置文件 vim /etc/auto.master 主配置文件 格式：挂载点父目录 辅助配置文件 首先要明白挂什么，然后挂在哪里，例如我们本次例子中，挂的是本地镜像，所以我们要挂的是/dev/sr0，然后我们打算挂在/mnt/autofs/sr0这个目录下 所以格式为：/mnt/autofs /etc/auto.sr0 然后创建/etc/auto/sr0文件并去编辑他（可以参考 cat /etc/auto.misc） 格式：挂载点的相对路径（相对于父目录） 选项 挂载设备 例子： sr0 -fstype=iso9660（表示文件的类型）:/dev/sr0 （冒号表示的是本地文件） vim /etc/auto.sr0 1sr0 -fstype=iso9660 :/dev/sr0 启动服务 systemctl enable autofs systemctl restart autofs 验证查看 首先我们先将之前挂载点卸载 umount /dev/sr0，然后你通过df-Th是查看不到本地镜像的挂载情况，但是当你去访问之前挂载点的目录时，就会自动挂载了cd /mnt/auto.sr0，然后在执行df-Th就会查看到这个光碟的挂载情况了，如果没有使用，他就会自动将它卸载了。 样例2：通过AutoFS挂载NFS 同样的操作，只不过要注意挂载点的父目录不要一样，因为挂载点的父目录会被锁定 样例3：通过AutoFS挂载LDAP用户的主目录]]></content>
      <categories>
        <category>Linux</category>
        <category>NFS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux软件包管理]]></title>
    <url>%2FLinux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[软件包管理 rpm是一个中软件包管理，同时一种软件包格式 RPM包管理器RPM的软件包查询 rpm -qa 查询已经安装的软件名称 rpm -q &lt;软件包&gt; 查询软件是否安装，安装过则输出该软件包的信息 1234567[chenxiaojian@chenxiaojian ~]$ rpm -q ssh未安装软件包 ssh [chenxiaojian@chenxiaojian ~]$ rpm -q sshd未安装软件包 sshd [chenxiaojian@chenxiaojian ~]$ rpm -q pythonpython-2.7.5-76.el7.x86_64[chenxiaojian@chenxiaojian ~]$ RPM的软件包的下载 yum -ivh &lt;软件包&gt; i：表示安装 v：表示更详细的安装信息页面 h：表示显示安装进度 例如;从镜像网站下载一个rpm包 可以先使用wget命令下载，wget -O （表示下下载到指定的目录，如果没有-O，则是下载到当前目录） yum软件包管理 相关命令：Linux uname命令用于显示系统信息，uname可显示电脑以及操作系统的相关信息 12chenxiaojian@ohenxiaojian:~$ uname -aLinux ohenxiaojian 5.0.0-27-generic #28~18.04.1-Ubuntu SMP Thu Aug 22 03:00:32 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 软件的类型 源码包 需要编译 二进制包 已编译 在ubantu系统上，在线包管理工具是apt,而在红帽中则为yum（在线工具）管理 使用yum管理RPM包安装 yum -y install &lt;包名&gt; yum -y reinstall &lt;包名&gt; yum -y update &lt;包名&gt; yum -y update 更新所有包 卸载 yum remove &lt;包名&gt; 查询 yum list &lt;包名&gt; yum info &lt;包名&gt; 可以查询包的信息（无论是否安装过） yum history info 2 、yum history 撤销yum history的动作，yum history undo yum search &lt;包名&gt; 搜索软件包 yum provides &lt;文件&gt; 查询命令提供的软件包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081root@chenxiaojian yum.repos.d]# yum history 已加载插件：fastestmirror, langpacksID | 登录用户 | 日期和时间 | 操作 | 变更数 ------------------------------------------------------------------------------- 2 | &lt;chenxiaojian&gt; | 2019-09-16 22:29 | Install | 3 1 | 系统 &lt;空&gt; | 2019-09-15 21:48 | Install | 1527 history list[root@chenxiaojian yum.repos.d]# yum history info 2已加载插件：fastestmirror, langpacks事务 ID： 2起始时间 ： Mon Sep 16 22:29:52 2019启动 RPM 数据库 ： 1527:8b2dcf21844ade1205674f58ecb3b0f2be946f78结束时间 ： 22:29:54 2019 （2 秒）结束 RPM 数据库 ： 1530:34cb8a59af417b144b21b6f139a91d27f8216274用户 ： chenxiaojian &lt;chenxiaojian&gt;返回码 ： 成功命令行 ： install httpd事务完成属主： 已安装 rpm-4.11.3-35.el7.x86_64 @anaconda 已安装 yum-3.4.3-161.el7.centos.noarch @anaconda 已安装 yum-plugin-fastestmirror-1.1.31-50.el7.noarch @anaconda已变更的包： 安装 httpd-2.4.6-89.el7.centos.1.x86_64 @updates 依赖安装 httpd-tools-2.4.6-89.el7.centos.1.x86_64 @updates 依赖安装 mailcap-2.1.41-2.el7.noarch @basehistory info[root@chenxiaojian yum.repos.d]# yum history undo 2已加载插件：fastestmirror, langpacksUndoing transaction 2, from Mon Sep 16 22:29:52 2019 安装 httpd-2.4.6-89.el7.centos.1.x86_64 @updates 依赖安装 httpd-tools-2.4.6-89.el7.centos.1.x86_64 @updates 依赖安装 mailcap-2.1.41-2.el7.noarch @base正在解决依赖关系--&gt; 正在检查事务---&gt; 软件包 httpd.x86_64.0.2.4.6-89.el7.centos.1 将被 删除---&gt; 软件包 httpd-tools.x86_64.0.2.4.6-89.el7.centos.1 将被 删除---&gt; 软件包 mailcap.noarch.0.2.1.41-2.el7 将被 删除--&gt; 解决依赖关系完成依赖关系解决===================================================================================== Package 架构 版本 源 大小=====================================================================================正在删除: httpd x86_64 2.4.6-89.el7.centos.1 @updates 9.4 M httpd-tools x86_64 2.4.6-89.el7.centos.1 @updates 169 k mailcap noarch 2.1.41-2.el7 @base 62 k事务概要=====================================================================================移除 3 软件包安装大小：9.6 M是否继续？[y/N]：yDownloading packages:Running transaction checkRunning transaction testTransaction test succeededRunning transaction 正在删除 : httpd-2.4.6-89.el7.centos.1.x86_64 1/3 正在删除 : mailcap-2.1.41-2.el7.noarch 2/3 正在删除 : httpd-tools-2.4.6-89.el7.centos.1.x86_64 3/3 验证中 : httpd-2.4.6-89.el7.centos.1.x86_64 1/3 验证中 : mailcap-2.1.41-2.el7.noarch 2/3 验证中 : httpd-tools-2.4.6-89.el7.centos.1.x86_64 3/3 删除: httpd.x86_64 0:2.4.6-89.el7.centos.1 httpd-tools.x86_64 0:2.4.6-89.el7.centos.1 mailcap.noarch 0:2.1.41-2.el7 完毕！[root@chenxiaojian yum.repos.d]# yum list httpd已加载插件：fastestmirror, langpacksLoading mirror speeds from cached hostfile * base: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com可安装的软件包httpd.x86_64 2.4.6-89.el7.centos.1 updates[root@chenxiaojian yum.repos.d]# 将源换成阿里云的源 https://opsx.alibaba.com/mirror?lang=zh-CN 查看不同的源的配置文件/etc/yum.repos.d/.. 安装epel扩展源https://opsx.alibaba.com/mirror 这样做，就可以安装类似于nginx的包 12345678910[root@chenxiaojian ~]# [root@chenxiaojian ~]# yum list nginx已加载插件：fastestmirror, langpacksLoading mirror speeds from cached hostfile * base: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com可安装的软件包nginx.x86_64 1:1.12.2-3.el7 epel[root@chenxiaojian ~]# 软件包管理相关命令 uname 12345678910111213141516171819202122232425[chenxiaojian@chenxiaojian ~]$ uname -mx86_64[chenxiaojian@chenxiaojian ~]$ uname Linux[chenxiaojian@chenxiaojian ~]$ uname --help用法：uname [选项]...输出一组系统信息。如果不跟随选项，则视为只附加-s 选项。 -a, --all 以如下次序输出所有信息。其中若-p 和 -i 的探测结果不可知则被省略： -s, --kernel-name 输出内核名称 -n, --nodename 输出网络节点上的主机名 -r, --kernel-release 输出内核发行号 -v, --kernel-version 输出内核版本 -m, --machine 输出主机的硬件架构名称 -p, --processor 输出处理器类型或"unknown" -i, --hardware-platform 输出硬件平台或"unknown" -o, --operating-system 输出操作系统名称 --help 显示此帮助信息并退出 --version 显示版本信息并退出GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;请向&lt;http://translationproject.org/team/zh_CN.html&gt; 报告uname 的翻译错误要获取完整文档，请运行：info coreutils 'uname invocation'[chenxiaojian@chenxiaojian ~]$ 12[chenxiaojian@chenxiaojian etc]$ cat /etc/redhat-releaseCentOS Linux release 7.6.1810 (Core) 123456789101112[chenxiaojian@chenxiaojian etc]$ yum repolist已加载插件：fastestmirror, langpacksDetermining fastest mirrors * base: ftp.sjtu.edu.cn * extras: mirrors.163.com * updates: mirrors.cn99.com源标识 源名称 状态!base/7/x86_64 CentOS-7 - Base 10,019!extras/7/x86_64 CentOS-7 - Extras 435!updates/7/x86_64 CentOS-7 - Updates 2,500repolist: 12,954# 默认的三个国外源 firewalld 防火墙服务systemctl status firewalld 查看防火墙守护进程 命令行方式操作防火墙 firewall-cmd 图形化界面操作操作防火墙 firewall-config 1234567891011121314151617[root@chenxiaojian chenxiaojian]# firewall-cmd --add-service=http --permanent Warning: ALREADY_ENABLED: httpsuccess[root@chenxiaojian chenxiaojian]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 sources: services: ssh dhcpv6-client http ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: 配置文件 /etc/firewalld/ 当前配置 12345678910111213141516171819[root@chenxiaojian etc]# cd firewalld[root@chenxiaojian firewalld]# ll总用量 8-rw-r--r--. 1 root root 2006 10月 31 2018 firewalld.confdrwxr-x---. 2 root root 6 10月 31 2018 helpersdrwxr-x---. 2 root root 6 10月 31 2018 icmptypesdrwxr-x---. 2 root root 6 10月 31 2018 ipsets-rw-r--r--. 1 root root 271 10月 31 2018 lockdown-whitelist.xmldrwxr-x---. 2 root root 6 10月 31 2018 servicesdrwxr-x---. 2 root root 46 9月 15 21:59 zones[root@chenxiaojian firewalld]# cat lockdown-whitelist.xml &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;whitelist&gt; &lt;command name="/usr/bin/python -Es /usr/bin/firewall-config"/&gt; &lt;selinux context="system_u:system_r:NetworkManager_t:s0"/&gt; &lt;selinux context="system_u:system_r:virtd_t:s0-s0:c0.c1023"/&gt; &lt;user id="0"/&gt;&lt;/whitelist&gt;[root@chenxiaojian firewalld]# SELinux基础SELinux可以给文件，目录，端口，进程打上标签，标签称为上下文 不同的标签就不能访问各自的上下文 httpd服务的进程上下文：httpd_t httpd服务的文件上下文：httpd_sys_content_t httpd服务的进程上下文：http_port_t 模式 enforcing （强制模式）启动SELinux，禁用违反策略的行为，并发送警告 permissive（允许模式）启用SELinux，不禁用违反策略的行为 disabled（禁用模式） 临时更改：setenforce 1 | 0 永久更改：/etc/selinux/config 12345678910111213[root@chenxiaojian /]# cat /etc/selinux/config # This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=enforcing# SELINUXTYPE= can take one of three values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.SELINUXTYPE=targeted 文件上下文查看文件上下文 ls -Z[d] 查看目录或文件的上下文 -Z 表示查看上下文，d表示查看文件，目录本身 12[root@chenxiaojian chenxiaojian]# semanage fcontext -l#查看所有文件的上下文 配置管道命令 | grep 添加文件上下文 semanage fcontext -a -t &lt;上下文&gt; &lt;目录文件&gt; a表示添加，-t表示上下文类型 restorecon -RFvv &lt;目录文件&gt; vv表示查看过程 修改文件上下文 semanage fcontext -m -t &lt;上下文&gt; &lt;目录文件&gt; m表示修改，-t表示上下文类型 restorecon -RFvv &lt;目录文件&gt; vv表示查看过程 临时修改上下文：chcon -t &lt;上下文类型&gt; &lt;文件目录&gt;，内核安全上下文列表（semanage fcontent -l）经过刷新后（restorecon -RFvv &lt; 文件&gt;）就会恢复之前的上下文 命令： chcon -t &lt;上下文类型&gt; &lt;文件、目录&gt; 临时修改 semanage fcontent -a -t &lt;上下文类型&gt; &lt;文件、目录&gt; 添加默认上下文 semanage fcontent -m -t &lt;上下文类型&gt; &lt;文件、目录&gt; 修改默认上下文 restorecon -RFvv &lt;文件。目录&gt; 当这个文件在策略里有定义是，可以恢复原来的 文件标签。 样例：123456789101112[root@chenxiaojian chenxiaojian]# mkdir dir3[root@chenxiaojian chenxiaojian]# ls1.sh dir1 dir3 test_file.txt 模板 图片 下载 桌面Anaconda3-2018.12-Linux-x86_64.sh dir2 fstab 公共 视频 文档 音乐[root@chenxiaojian chenxiaojian]# ls -Zd dir3drwxr-xr-x. root root unconfined_u:object_r:user_home_t:s0 dir3[root@chenxiaojian chenxiaojian]# semanage fcontext -a -t httpd_sys_content_t /home/chenxiaojian/dir3[root@chenxiaojian chenxiaojian]# restorecon -Rv dir3restorecon reset /home/chenxiaojian/dir3 context unconfined_u:object_r:user_home_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0[root@chenxiaojian chenxiaojian]# ls -Zd dir3drwxr-xr-x. root root unconfined_u:object_r:httpd_sys_content_t:s0 dir3[root@chenxiaojian chenxiaojian]# 总结： 文件或者目录要写成绝对路径，记得查看文件安全上下文列表，restorecon 就是重新加载这个列表 此外，要就注意移动文件和复制文件对于上下文的不同影响 1234567891011121314[root@chenxiaojian chenxiaojian]# echo hello &gt; file1[root@chenxiaojian chenxiaojian]# echo hello &gt; file2[root@chenxiaojian chenxiaojian]# ls -Z | grep file-rw-r--r--. root root unconfined_u:object_r:user_home_t:s0 file1-rw-r--r--. root root unconfined_u:object_r:user_home_t:s0 file2-rw-rw-r--. chenxiaojian chenxiaojian unconfined_u:object_r:user_home_t:s0 test_file.txt[root@chenxiaojian chenxiaojian]# cp file1 /var/www/html/[root@chenxiaojian chenxiaojian]# mv file2 /var/www/html/[root@chenxiaojian chenxiaojian]# ls -Z /var/www/html/ | grep file-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file1-rw-r--r--. root root unconfined_u:object_r:user_home_t:s0 file2 端口上下文查看123456[root@chenxiaojian chenxiaojian]# semanage port -l | grep httphttp_cache_port_t tcp 8080, 8118, 8123, 10001-10010http_cache_port_t udp 3130http_port_t tcp 80, 81, 443, 488, 8008, 8009, 8443, 9000pegasus_http_port_t tcp 5988pegasus_https_port_t tcp 5989 添加端口上下文 semanage port -a -t &lt;上下文&gt; -p &lt;tcp | udp&gt; &lt;端口&gt; 例如：semanage port -a -t httpd_port_t -p tcp 10000 删除端口上下文 semanage port -d -t &lt;上下文&gt; -p &lt;tcp | udp&gt; &lt;端口&gt; 例如：semanage port -d -t httpd_port_t -p tcp 10000 修改端口上下文 semanage port -m -t &lt;上下文&gt; -p &lt;tcp | udp&gt; &lt;端口&gt; 例如：semanage port -m -t httpd_port_t -p tcp 10000 布尔值 布尔值是selinux的策略开关 查看布尔值 getsebool -a 修改布尔值 setsebool -P （P表示永久修改） 例如：setsebool -P nfs_export_all_rw off 查看用户修改的布尔值 semanage boolean -l -C 1234567891011[root@chenxiaojian chenxiaojian]# setsebool -P nfs_export_all_rw off[root@chenxiaojian chenxiaojian]# semanage boolean -l -CSELinux 布尔值 状态 默认 描述nfs_export_all_rw (关 , 关) Allow nfs to export all rw[root@chenxiaojian chenxiaojian]# setsebool -P nfs_export_all_rw on[root@chenxiaojian chenxiaojian]# semanage boolean -l -CSELinux 布尔值 状态 默认 描述nfs_export_all_rw (开 , 开) Allow nfs to export all rw[root@chenxiaojian chenxiaojian]# LDAP用户集中管理，可以理解为将所有用户的信息存放在一个特定的服务器中，然后用户的信息存放在不同的目录下，这样我们可以在本机连接LDAP服务器，就可以共享该用户的信息 连接LDAP服务器 安装软件包 yum -y install authconfig-gtk sssd 执行authconfig-gtk 选择LDAP认证 输入域名 dc=xxx,dc=xxx 输入LDAP服务器的ip地址或主机名 √ TLS，下载证书 选择LDAP password 连接成功后，可以查看服务器内的用户数据 查看用户 id &lt;用户&gt; （该用户不是本地创建的，cat/etc/passwd查看）]]></content>
      <categories>
        <category>Linux</category>
        <category>软件包管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[putty连接ubantu]]></title>
    <url>%2Fputty%E8%BF%9E%E6%8E%A5ubantu%2F</url>
    <content type="text"><![CDATA[首先查看ssh的服务 123root@chenxiaojian:~# ps -e | grep ssh 5391 ? 00:00:00 ssh-agent 16936 ? 00:00:00 sshd ssh程序分为有客户端程序openssh-client和服务端程序openssh-server 如果需要ssh登陆到别的电脑，需要安装openssh-client，该程序Ubuntu是默认安装的。而如果需要从远程连接到本机，则需要安装openssh-server 安装openssh-server1sudo apt-get install openssh-server 查看是否安装成功 1ps -e | grep ssh 启动、停止和重启openssh-server 123/etc/init.d/ssh start/etc/init.d/ssh stop/etc/init.d/ssh restart 查看ip地址：apt install net-tools1ipconfig Ubuntu中SSH服务安装完成后查看是否允许root用户登陆，若不允许则无法远程登陆root用户，需要修改配置 首先，打开“/etc/ssh/sshd_config” 查看是否有“PermitRootLogin yes”，没有添加即可，完成后保存退出 然后需要重新载入这文件，不然用putty连接用root登录会超时，无法成功 1systemctl reload ssh 注意问题主机和虚拟机中ubantu的网段要一致 1234567891011121314151617C:\Users\陈小坚&gt;ipconfigWindows IP 配置无线局域网适配器 本地连接* 1: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . :以太网适配器 VMware Network Adapter VMnet1: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::dd9:6adc:aff4:2a8d%12 IPv4 地址 . . . . . . . . . . . . : 192.168.235.1 #ip地址 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : 123456789101112131415161718root@chenxiaojian:~# ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.18.129 netmask 255.255.255.0 broadcast 192.168.18.255 inet6 fe80::db1b:b0e6:2904:f468 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:52:d5:63 txqueuelen 1000 (以太网) RX packets 15579 bytes 17077036 (17.0 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 4466 bytes 360668 (360.6 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (本地环回) RX packets 556 bytes 48721 (48.7 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 556 bytes 48721 (48.7 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0]]></content>
      <categories>
        <category>Linux</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux--Systemctl]]></title>
    <url>%2FLinux-Systemctl%2F</url>
    <content type="text"><![CDATA[SystemCtl 一个程序有一个或多个进程 SystemCtl可以管理服务 服务就是守护进程（sshd, httpd） systemctl -t sevice (查看服务) systemctl start ssh systemctl stop ssh systemctl restart ssh systemctl reload ssh systemctl enable ssh systemctl disable ssh RHEL7网络 ip地址，掩码，网关，DNS，主机名 IPV4 192.168.1.1 点分十进制 32位 ip address 查看Ip信息 ip route 查看路由信息 ip -s link 查看接口统计信息 设置 图形化 nmtui，设置完成后记得重新启动网络，systemctl restart network 命令行 nmcli con mod help 查看帮助 nmcli con mod （不同的linux版本可能不同） nmcli con add nmcli con del nmcli con show 修改文件 不同版本的linux系统，网络配置文件可能不容 REHE的配置文件为：/etc/sysconfig/network-scripts/ifcfg DNS（域名系统） 提供ip地址和域名的映射关系 主机名 hostname查看 12345678910root@chenxiaojian:/etc/network# hostnamectl Static hostname: chenxiaojian Icon name: computer-vm Chassis: vm Machine ID: f71657539bed41b18d278ff8d76a60f7 Boot ID: 1c3e9e525f2348aa8412bed75c6a79bf Virtualization: vmware Operating System: Ubuntu 18.04.3 LTS Kernel: Linux 5.0.0-27-generic Architecture: x86-64 1234567root@chenxiaojian:/etc/network# hostnamectl set-hostname chenchenxiaojianroot@chenxiaojian:/etc/network#root@chenxiaojian:/etc/network# hostnamechenchenxiaojianroot@chenxiaojian:/etc/network# hostnamectl set-hostname chenxiaojianroot@chenxiaojian:/etc/network# hostnamechenxiaojian 12root@chenxiaojian:/etc/network# vim /etc/hostname# 修改hostname文件]]></content>
      <categories>
        <category>Linux</category>
        <category>Systemctl</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷P1118】数字三角形]]></title>
    <url>%2F%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题目描述FJ and his cows enjoy playing a mental game. They write down the numbers from 111 toN(1≤N≤10) N(1 \le N \le 10)N(1≤N≤10) in a certain order and then sum adjacent numbers to produce a new list with one fewer number. They repeat this until only a single number is left. For example, one instance of the game (when N=4N=4N=4) might go like this: 12343 1 2 4 4 3 6 7 9 16 Behind FJ‘s back, the cows have started playing a more difficult game, in which they try to determine the starting sequence from only the final total and the number NNN. Unfortunately, the game is a bit above FJ‘s mental arithmetic capabilities. Write a program to help FJ play the game and keep up with the cows. 有这么一个游戏： 写出一个111至NNN的排列aia_iai，然后每次将相邻两个数相加，构成新的序列，再对新序列进行这样的操作，显然每次构成的序列都比上一次的序列长度少111，直到只剩下一个数字位置。下面是一个例子： 3,1,2,43,1,2,43,1,2,4 4,3,64,3,64,3,6 7,97,97,9 161616 最后得到161616这样一个数字。 现在想要倒着玩这样一个游戏，如果知道NNN，知道最后得到的数字的大小sumsumsum，请你求出最初序列aia_iai，为111至NNN的一个排列。若答案有多种可能，则输出字典序最小的那一个。 [color=red]管理员注：本题描述有误，这里字典序指的是1,2,3,4,5,6,7,8,9,10,11,121,2,3,4,5,6,7,8,9,10,11,121,2,3,4,5,6,7,8,9,10,11,12 而不是1,10,11,12,2,3,4,5,6,7,8,91,10,11,12,2,3,4,5,6,7,8,91,10,11,12,2,3,4,5,6,7,8,9[/color] 输入格式两个正整数n,sumn,sumn,sum。 输出格式输出包括111行，为字典序最小的那个答案。 当无解的时候，请什么也不输出。（好奇葩啊） 输入输出样例输入 #1 14 16 输出 #1 13 1 2 4 说明/提示对于40%40%40%的数据，n≤7n≤7n≤7； 对于80%80%80%的数据，n≤10n≤10n≤10； 对于100%100%100%的数据，n≤12,sum≤12345n≤12,sum≤12345n≤12,sum≤12345。 思路：首先对n个数的最终值进行模拟可以发现一个规律，如图所示 因此，我们可以用一个二维数组保存杨辉三角的值—yhsj[i][j] 表示第i行第j个数字 ​ yhsj[i][j] = yhsj[i-1][j] + yhsj[i-1][j-1] 也就是说我们可以知道sum有n项组成。每一项的系数我们也都知道了，接下来对每一项进行枚举就行了 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdlib.h&gt;#include &lt;iostream&gt;using namespace std;int n;int sum;int yhsj[13][13]; //存放杨辉三角 全局变量默认为0int res[13];int vis[13];void dfs(int step, int temp_sum)&#123; if (temp_sum &gt; sum) return; if (step == n+1) &#123; if (temp_sum != sum) return; else &#123; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; res[i] &lt;&lt; " "; cout &lt;&lt; endl; exit(0); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (vis[i] == 0) &#123; vis[i] = 1; res[step] = i; dfs(step + 1, i*yhsj[n][step]+temp_sum); vis[i] = 0; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt;sum; yhsj[1][1] = 1; for (int i = 2; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) yhsj[i][j] = yhsj[i-1][j] + yhsj[i-1][j-1]; //生成杨辉三角 dfs(1, 0);&#125; 总结 脑子是个好东西，可惜我还在还没有=V= 此外，需要掌握杨辉三角的生成代码]]></content>
      <categories>
        <category>OJ</category>
        <category>洛谷</category>
        <category>算法</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>暴力枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户和组]]></title>
    <url>%2F%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%2F</url>
    <content type="text"><![CDATA[用户和组 linux是多用户系统 文件和目录是属于一个用户，进程是以一个用户的身份运行（查看进程的命令 ps aux） 用户可以加入一个或多个组，但是只有一个主要组，可以有多个附属组 /etc/passwd 保存用户信息 cat 查看文件 root​ : x:0:0:root:/root:/bin/bash root：用户名称 x: 密码，以前存放密码的位置 0：UID,标识用户 0固定分配给root；1-999分配给系统用户；1000及以上分配普通用户 0：GID，标识用户组 root：填充字段 /root：用户的主目录 /bin/bash :用户使用的登录shell /etc/group保存用户组信息 root​ ​：x:0: root: 用户组名称 x：密码，以前存放密码的位置 0：GID，标识用户组 : 用户列表 id +用户 12chenxiaojian@chenxiaojian:~$ id chenxiaojianuid=1000(chenxiaojian) gid=1000(chenxiaojian) 组=1000(chenxiaojian),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare) /etc/shadow保存用户密码 管理用户 (nologin –不可登录的shell) useradd 添加用户 会自动创建/home 目录和邮箱目录 用法：useradd [选项] &lt;用户&gt; -d 指定用户的主目录 -u 指定用户的UID -g 指定主要组 -G 指定附属组 -s 指定用户登录的shell 1234567root@chenxiaojian:~# useradd user1root@chenxiaojian:~# id user1uid=1001(user1) gid=1001(user1) 组=1001(user1)root@chenxiaojian:~# tail -1 /etc/passwd (查看文件的最后一行)user1:x:1001:1001::/home/user1:/bin/sh# 可以看出user1用户的主目录是/home/user1 (默认的) 1234567891011121314151617181920212223242526272829303132333435363738394041 #指定用户的主目录 root@chenxiaojian:/# useradd -d /test user2 root@chenxiaojian:/# id user2 uid=1002(user2) gid=1002(user2) 组=1002(user2) root@chenxiaojian:/# tail -1 /etc/passwduser2:x:1002:1002::/test:/bin/sh #指定用户的UID root@chenxiaojian:/# useradd -u 1500 user3 root@chenxiaojian:/# id user3 uid=1500(user3) gid=1500(user3) 组=1500(user3) root@chenxiaojian:/# tail -1 /etc/passwduser3:x:1500:1500::/home/user3:/bin/sh #指定用户的主要组 root@chenxiaojian:/# useradd -g chenxiaojian user4 root@chenxiaojian:/# id user4 uid=1501(user4) gid=1000(chenxiaojian) 组=1000(chenxiaojian) root@chenxiaojian:/# tail -1 /etc/passwduser4:x:1501:1000::/home/user4:/bin/sh #指定用户的附属组 root@chenxiaojian:/# useradd -G user1,user2,user3 user5 root@chenxiaojian:/# id user5 uid=1502(user5) gid=1502(user5) 组=1502(user5),1001(user1),1002(user2),1500(user3) root@chenxiaojian:/# tail /etc/group avahi:x:122: colord:x:123: geoclue:x:124: gdm:x:125: chenxiaojian:x:1000: sambashare:x:126:chenxiaojian user1:x:1001:user5 #（这里表示user5是user1的用户） user2:x:1002:user5 user3:x:1500:user5user5:x:1502: #指定用户登录的shell root@chenxiaojian:/# useradd -s /sbin/nologin webuser root@chenxiaojian:/# tail -1 /etc/passwd webuser:x:1503:1503::/home/webuser:/sbin/nologin usermod 修改用户 -g 修改用户的主要组 不建议使用这个，创建用户不指定这个，会自动创一个和本用户相同名字的组作为主要组 -a 添加附属组，与-G 配合使用 （如果只是usermod -G 修改附属组，那么会覆盖掉当前的组）-a表示追加的 12345root@chenxiaojian:/# id user2uid=1002(user2) gid=1002(user2) 组=1002(user2)root@chenxiaojian:/# usermod -aG user1 user2root@chenxiaojian:/# id user2uid=1002(user2) gid=1002(user2) 组=1002(user2),1001(user1) -m移动主目录，与-d配合使用 1234567891011121314root@chenxiaojian:/home# tail -5 /etc/passwduser2:x:1002:1002::/test:/bin/shuser3:x:1500:1500::/home/user3:/bin/shuser4:x:1501:1000::/home/user4:/bin/shuser5:x:1502:1502::/home/user5:/bin/shwebuser:x:1503:1503::/home/webuser:/sbin/nologinroot@chenxiaojian:/home# usermod -md /home/user2 user2root@chenxiaojian:/home# tail -5 /etc/passwduser2:x:1002:1002::/home/user2:/bin/shuser3:x:1500:1500::/home/user3:/bin/shuser4:x:1501:1000::/home/user4:/bin/shuser5:x:1502:1502::/home/user5:/bin/shwebuser:x:1503:1503::/home/webuser:/sbin/nologin userdel 删除用户 -r 删除 1root@chenxiaojian:/home# userdel webuser 管理用户组 groupadd 添加用户组 -g 指定GID groupmod groupdel 设置用户密码 passwd &lt;用户&gt; 注：root可以设置所有用户的密码，普通用户只能设置自身的密码、 echo &lt;密码&gt; | passwd –stdin &lt;用户&gt; 切换用户 su &lt;用户名&gt; 1234#修该用户登录的shellroot@chenxiaojian:/home# usermod -s /bin/bash user1root@chenxiaojian:/home# su user1user1@chenxiaojian:/home$ ^C 注意，使用sudo 提升权限的前提是你这个用户的组之中有root组 文件权限 UGO：用户、组、其他 r代表读取 w代表写入 x代表执行 权限 对文件的影响 对目录的影响 r读取 查看文件的内容 查看目录的内容（目录下的文件） w写入 修改文件的内容 创建或删除文件或子目录 x执行 执行文件 访问目录，修改目录下文件的内容（文件本身权限） 修改文件权限 （change + mod）（修改 + 权限） 符号法 （ugoa）–&gt;user,group,other, any(任何) chmod &lt;ugoa&gt;&lt;+-=&gt;&lt;rwx-&gt; chmod u=rw,g=rw,o=rw file1 注意，u=rw,g=rw之间不能有空格 chmod -R ==&gt;递归设置 drwxr-xr-x 其中，u代表文件所有者的权限，也就是第二到第四位（rwx） g代表的文件所属组的权限，也就是第五位到第七位的权限（r-x） o代表的其他用户的权限，也就是第八位到第10位（r-x） 而a则是代表全部。(也可以省略不写) 1234567891011drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-r--r-- 1 chenxiaojian chenxiaojian 0 9月 11 14:13 file1drwxr-xr-x 2 chenxiaojian chenxiaojian 4096 9月 11 14:13 test_dir/chenxiaojian@chenxiaojian:~/test$ chmod g+w file1chenxiaojian@chenxiaojian:~/test$ ll总用量 12drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-rw-r-- 1 chenxiaojian chenxiaojian 0 9月 11 14:13 file1drwxr-xr-x 2 chenxiaojian chenxiaojian 4096 9月 11 14:13 test_dir/ 1234567chenxiaojian@chenxiaojian:~/test$ chmod u=rw,g=rw,o=rw file1chenxiaojian@chenxiaojian:~/test$ ll总用量 12drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-rw-rw- 1 chenxiaojian chenxiaojian 0 9月 11 14:13 file1drwxr-xr-x 2 chenxiaojian chenxiaojian 4096 9月 11 14:13 test_dir/ 数值法 chmod NNN &lt;文件&gt; r = 4, w = 2 ,x = 1, -= 0 chmod 640 file1 就是设置file1的所有者的权限为r + w = 6 所属组的权限为r = 4 其他用户没有权限 0 = - 修改文件的所有者和所属组 注意：默认的所有者是创建该文件的用户，所属组是创建该文件的用户的主要组 chown &lt;所有者&gt;:&lt;所属组&gt; &lt;文件&gt; 用法 12345678910111213141516171819202122232425262728293031root@chenxiaojian:/home/chenxiaojian/test# ll总用量 12drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-rw-rw- 1 chenxiaojian chenxiaojian 0 9月 11 14:13 file1drwxrwxrwx 3 chenxiaojian chenxiaojian 4096 9月 11 14:35 test_dir/root@chenxiaojian:/home/chenxiaojian/test# chown root:root file1root@chenxiaojian:/home/chenxiaojian/test# ll总用量 12drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-rw-rw- 1 root root 0 9月 11 14:13 file1drwxrwxrwx 3 chenxiaojian chenxiaojian 4096 9月 11 14:35 test_dir/root@chenxiaojian:/home/chenxiaojian/test# root@chenxiaojian:/home/chenxiaojian/test# root@chenxiaojian:/home/chenxiaojian/test# chown chenxiaojian file1root@chenxiaojian:/home/chenxiaojian/test# ll总用量 12drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-rw-rw- 1 chenxiaojian root 0 9月 11 14:13 file1drwxrwxrwx 3 chenxiaojian chenxiaojian 4096 9月 11 14:35 test_dir/root@chenxiaojian:/home/chenxiaojian/test# root@chenxiaojian:/home/chenxiaojian/test# root@chenxiaojian:/home/chenxiaojian/test# chown :chenxiaojian file1root@chenxiaojian:/home/chenxiaojian/test# ll总用量 12drwxr-xr-x 3 chenxiaojian chenxiaojian 4096 9月 11 14:13 ./drwxr-xr-x 19 chenxiaojian chenxiaojian 4096 9月 11 14:13 ../-rw-rw-rw- 1 chenxiaojian chenxiaojian 0 9月 11 14:13 file1drwxrwxrwx 3 chenxiaojian chenxiaojian 4096 9月 11 14:35 test_dir/ 文件的特殊权限 权限 对文件的影响 对目录的影响 u+s 4 以文件所有者的身份运行，而不是运行该命令的用户身份运行 无 g+s 2 以文件所属组的身份运行 目录文件或子目录会继承组关系 o+t 1 无 只有root和文件的所有者才能删除这个目录 123# u+s表示在user的权限中有个s,那么例如passwd,这个命令，我们在chenxiaojian的身份下运行，实际上是由该命令的所有者也就是root执行root@chenxiaojian:/home/chenxiaojian/test# ll /usr/bin/passwd-rwsr-xr-x 1 root root 59640 3月 23 03:05 /usr/bin/passwd* 设置特殊权限 符号法 chmod u+s &lt;文件&gt; chmod g+s &lt;文件 | 目录&gt; chmod o+t &lt;目录&gt; 数值法 chmod NNNN &lt;文件/目录&gt; 第一个N就是表示特殊权限 ACL(访问控制列表) UGO权限不能满足精细设置权限的要求 ACL可以针对用户或组设置单独的权限 setfacl -m u:&lt;用户&gt;:&lt;权限&gt; &lt;文件&gt;（其中u代表的就是用户，如果是g,则表示为组） setfacl -x u:&lt;用户&gt; &lt;文件&gt; 删出用户对文件的权限 setfacl -b &lt;文件&gt; 删出所有的设置权限 查看设置文件权限的结果：getfacl &lt;文件&gt; 问题：设用户chenxiaojian对file1没有任何权限，而用户user1对file1有读写的操作 12 chenxiaojian@chenxiaojian:~/test$ setfacl -m u:chenxiaojian:- file1chenxiaojian@chenxiaojian:~/test$ setfacl -m u:user1:rw file1 结果： file: file1 owner: chenxiaojian group: chenxiaojian user::rw-user:chenxiaojian:—user:user1:rw-group::rw-mask::rw-other::rw-]]></content>
      <categories>
        <category>Linux</category>
        <category>用户和组</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVM]]></title>
    <url>%2FLVM%2F</url>
    <content type="text"><![CDATA[逻辑卷管理器LVM MBR磁盘分区方式的局限性 LVM的原理 LVM机制的基本概念 PV –物理卷 默认包括许多大小为4MB的PE块 VG –卷组 一个或多个物理卷组合而成的整体 LV –逻辑卷 从卷组汇总分割出的一块空间，用于建立文件系统 LVM的管理命令 功能 物理卷管理 卷组管理 逻辑卷管理 Scan 扫描 pvscan vgscan lvscan Create 建立 pvcreate vgcreate lvcreate Display 显示 pvdisplay vgdisplay lvdisplay Remove 删除 pvremove vgremove lvremove Exttend 扩展 vgextend lvextend 创建LVM逻辑卷的过程 分区–》pv–》vg–》lv–》格式化–》挂载文件系统 转化物理卷 使用fdisk命令规划两个分区，类型设置为“8e”（也就是说，如果我们新加入两个盘，我们可以在这两个盘上各自新建一个分区，然后再对两个分区进行操作） 如果设置为“8e”， fdisk进入命令，输入“t”改变分区id类型，输入“8e”，代表逻辑卷类型，输入p打印，确认无误输入w保存退出 pvcreate创建物理卷 可以先用pvscan扫描是否有pv物理卷 使用pvcreate命令进行创建 pvcreate /dev/sdc1 pvcreate /dev/sdd1 创建卷组 使用vgcreate命令（可以使用vgscan扫描一遍） vgcreate mail_store /dev/sdc1 /dev/sdd1 mail_store表示的卷组名，后面两个就是刚才新建的分区 创建逻辑卷 使用lvcreate命令创建逻辑卷 例如：mail,分配3G lvcreate -L 3G -n mail mail_store 创建文件系统 mkfs -t ext4 /dev/mail_store/mail 挂载 mount -t ext4 /dev/mail_store/mail /testLvm 挂载到文件夹testLvm df -Th查看 文件系统添加完后会自动添加一个别名 /dev/mapper/mail_store/mail LVM的扩容 VG卷组还有剩余空间 执行 lvextend -L +3G /dev/mail_store/mail (扩展lvm逻辑卷mail的大小) 更新文件系统大小 resize2fs /dev/mail_store/mail 如果文件系统为 xfs 则用 xfs_growfs 来扩容文件系统， 如果为ext4，则使用resize2fs 更新文件系统的大小 VG卷组没有剩余空间 解决方案：新找一块分区/dev/sd* 转化为pv，加到VG中 pvcreate /dev/sdc2 vgextend mail_store /dev/sdc2（将新建的pv加到mail_store卷组上） 将之前创建的lv（本来是3G，现在扩展到6G） lvextend -L +3G /dev/mail_store/mail （如果不加“+”,表示加到3G） 使用resize2fs命令更新系统识别的文件系统大小 resize2fs /dev/mail_store/mail LVM的缩减操作 前提是不影响数据 脱机状态下的缩减（之前创建的文件系统ext4不支持online状态进行缩减） 先卸载挂载点 umount /testLvm 重新识别缩减的文件大小 resize2fs /dev/mail_store/mail 3G （表示缩减到3G） lvreduce -L 3G /dev/mail_store/mail 重新挂载 mount -t ext4/ /dev/mail-store/mail /test/Lvm 注意注意！！！需要注意的是，mount命令进行挂载只是暂时的，永久挂载需要到/etc/fstab这个配置文件进行挂载]]></content>
      <categories>
        <category>Linux</category>
        <category>LVM逻辑卷</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全排列]]></title>
    <url>%2F%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[全排列的思想 对于一串序列，首先确定第一个数，也就是第一个数与其他数进行交换（包括他本身） 例如1 2 3 —》 1 2 3 、 2 1 3、3 2 1 然后确定第二个数 例如1 2 3 已经确定第一个数为1，那么第二个数为 1 2 3 –&gt; 1 2 3 、1 3 2 对于多位数，以此类推=v= 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 全排序问题.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;using namespace std;int arr[500];void swap(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp;&#125;void permutations(int n, int m)&#123; if (n == m) &#123; for (int k = 0; k &lt; m; k++) cout &lt;&lt; arr[k] &lt;&lt; " "; cout &lt;&lt; endl; &#125; else &#123; for (int k = n; k &lt; m; k++) &#123; swap(arr[k], arr[n]); permutations(n + 1, m); swap(arr[k], arr[n]); &#125; &#125;&#125;int main()&#123; for (int i = 0; i &lt; 3; i++) cin &gt;&gt; arr[i]; permutations(0, 3); return 0;&#125;//这个代码的执行顺序是第一个数需要与其他数（包括他本身）进行交换，这样就确定了第一个数//然后第二个数也是同样的原理，第二个数与第二个数，还有后面也就是第三个数...进行交换，这样也就是确定了第二个数//例如：1,2,3 //首先执行的是1和1进行交换，然后递归，2与2进行交换，然后递归，3与3进行交换，这样确定了3个数，然后就可以输出来//然后第3个递归不能再继续了，所以结束，之前交换的值重新交换回来，也就是2与2进行交换，然后第二个递归的//进行的是2与第二个数进行交换，也就是2，在for()循环的下一步，2与2后面的3进行交换，然后进入下一个递归，第三个数的确定3与3进行交换，//三个数确定，输出1 ， 3，2，依次类推.....=v=/*1 2 3 全排列的序列1 2 31 3 22 1 32 3 13 2 13 1 2*/ 但是这种方法不能正确地输出字典序，可以在每次交换进行递归的前面将后面未确定的数进行排序1234567891011121314151617181920212223242526272829void permutations(int n, int m)&#123; if (n == m) &#123; for (int k = 0; k &lt; m; k++) cout &lt;&lt; arr[k] &lt;&lt; " "; cout &lt;&lt; endl; &#125; else &#123; for (int k = n; k &lt; m; k++) &#123; sort(arr + k, arr + m); //加上这个就行了 swap(arr[k], arr[n]); permutations(n + 1, m); swap(arr[k], arr[n]); &#125; &#125;&#125;/*2 1 3 带排列的序列1 2 31 3 22 1 32 3 13 1 23 2 1*/ C++ stl的函数next_permutation函数，prev_permutation函数12345678910111213141516171819202122int main()&#123; int arr[10]; for (int i = 0; i &lt; 3; i++) cin &gt;&gt; arr[i]; sort(arr, arr + 3); //必不可少的，因为是要按照字典序输出 do &#123; cout &lt;&lt; arr[0] &lt;&lt; " " &lt;&lt; arr[1] &lt;&lt; " " &lt;&lt; arr[2] &lt;&lt; endl; &#125; while (next_permutation(arr, arr + 3)); return 0;&#125;/*2 1 31 2 31 3 22 1 32 3 13 1 23 2 1*/ 1234567891011121314151617181920212223242526bool cmp(int a, int b)&#123; return a &gt; b;&#125;int main()&#123; int arr[10]; for (int i = 0; i &lt; 3; i++) cin &gt;&gt; arr[i]; sort(arr, arr + 3,cmp); //需要从大到小排序 do &#123; cout &lt;&lt; arr[0] &lt;&lt; " " &lt;&lt; arr[1] &lt;&lt; " " &lt;&lt; arr[2] &lt;&lt; endl; &#125; while (prev_permutation(arr, arr+3)); return 0;&#125;/*1 2 33 2 13 1 22 3 12 1 31 3 21 2 3*/]]></content>
      <categories>
        <category>算法</category>
        <category>全排列</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVM逻辑卷]]></title>
    <url>%2FLVM%E9%80%BB%E8%BE%91%E5%8D%B7%2F</url>
    <content type="text"><![CDATA[逻辑卷管理器LVM MBR磁盘分区方式的局限性 LVM的原理 LVM机制的基本概念 PV –物理卷 默认包括许多大小为4MB的PE块 VG –卷组 一个或多个物理卷组合而成的整体 LV –逻辑卷 从卷组汇总分割出的一块空间，用于建立文件系统 LVM的管理命令 功能 物理卷管理 卷组管理 逻辑卷管理 Scan 扫描 pvscan vgscan lvscan Create 建立 pvcreate vgcreate lvcreate Display 显示 pvdisplay vgdisplay lvdisplay Remove 删除 pvremove vgremove lvremove Exttend 扩展 vgextend lvextend 创建LVM逻辑卷的过程 分区–》pv–》vg–》lv–》格式化–》挂载文件系统 转化物理卷 使用fdisk命令规划两个分区，类型设置为“8e”（也就是说，如果我们新加入两个盘，我们可以在这两个盘上各自新建一个分区，然后再对两个分区进行操作） 如果设置为“8e”， fdisk进入命令，输入“t”改变分区id类型，输入“8e”，代表逻辑卷类型，输入p打印，确认无误输入w保存退出 pvcreate创建物理卷 可以先用pvscan扫描是否有pv物理卷 使用pvcreate命令进行创建 pvcreate /dev/sdc1 pvcreate /dev/sdd1 创建卷组 使用vgcreate命令（可以使用vgscan扫描一遍） vgcreate mail_store /dev/sdc1 /dev/sdd1 mail_store表示的卷组名，后面两个就是刚才新建的分区 创建逻辑卷 使用lvcreate命令创建逻辑卷 例如：mail,分配3G lvcreate -L 3G -n mail mail_store 创建文件系统 mkfs -t ext4 /dev/mail_store/mail 挂载 mount -t ext4 /dev/mail_store/mail /testLvm 挂载到文件夹testLvm df -Th查看 文件系统添加完后会自动添加一个别名 /dev/mapper/mail_store/mail LVM的扩容 VG卷组还有剩余空间 VG卷组没有剩余空间 解决方案：新找一块分区/dev/sd* 转化为pv，加到VG中 pvcreate /dev/sdc2 vgextend mail_store /dev/sdc2（将新建的pv加到mail_store卷组上） 将之前创建的lv（本来是3G，现在扩展到6G） lvextend -L +3G /dev/mail_store/mail （如果不加“+”,表示加到3G） 使用resize2fs命令更新系统识别的文件系统大小 resize2fs /dev/mail_store/mail LVM的缩减操作 前提是不影响数据 脱机状态下的缩减（之前创建的文件系统ext4不支持online状态进行缩减） 先卸载挂载点 umount /testLvm 重新识别缩减的文件大小 resize2fs /dev/mail_store/mail 3G （表示缩减到3G） lvreduce -L 3G /dev/mail_store/mail 重新挂载 mount -t ext4/ /dev/mail-store/mail /test/Lvm]]></content>
      <categories>
        <category>Linux</category>
        <category>LVM逻辑卷</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘管理与文件系统]]></title>
    <url>%2F%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[磁盘管理硬盘接口 SATA/SAS 硬盘命名 sd[a..z] vd[a..z] //半虚拟化 分区方式 MBR 最多支持4个主分区（如果想创建多个分区），可以创建3个主分区，1个扩展分区，在扩展分区的基础上进行逻辑分区，就可以创建多个分区 操作软件 mdish GPT 可以创建128个分区 MBR方式进行分区—》磁盘–》分区–》格式化–》挂载 /dev/sdb 20G p1 /dev/sdb1 5G p2 /dev/sdb2 5G E /dev/sdb3 10G L1 /dev/sdb5 3G （注意，逻辑分区是从5开始的） L2 /dev/sdb6 3G L3 /dev/sdb7 4G fdish 进行分区 mkfs 在分区中创建文件系统（格式化） mkfs -t ext4 /dev/sdb1 挂载使用（df -hl查看挂载情况） mount 命令 / umount 卸载==&gt;&gt;重启后就会失效 自动挂载 进入/etc/fstab配置文件 追加 ：分区设备名 挂载点 文件系统格式 defaults 0 0 /dev/sdb1 /test ext4 defaults 0 0 （保存） 保存后执行mount /dev/sdb1 /test （test是你要挂载到的目录） 知识点 win 的盘的格式 NTFS/FAT32 dev/sr0 代表光驱 UUID ：硬件唯一标识符 光驱的文件系统格式：iso9660 swap:用于linux磁盘交换分区的特殊文件系统格式 linux支持的文件系统格式ext2/ext3/ext4 （xfs：RHEL7.0支持的文件系统） 查看文件系统情况：lsblk 磁盘的分区 /dev/sda / /boot 启动引导目录 /swap 交换目录]]></content>
      <categories>
        <category>Linux</category>
        <category>磁盘管理与文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim操作]]></title>
    <url>%2Fvim%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[vim 文本编辑器 三种模式 命令模式：默认进入的模式，复制，粘贴，删除等操作 插入模式：由命令模式进入，进行文本编辑，按ESC键退回命令模式 底行模式：在命名模式下按：键进入。进行文本的保存，退出，按ESC键退回命令模式 gg 和G 将光标跳转到首行和尾行 yy复制一行 nyy （n为数字）复制多行 p粘贴 u撤销 支持多次\ x删除一个字符 dd删除一行字符 进入插入模式 i 在光标前插入 a在光标后插入 I(大写i)在行首插入 A 在行尾插入 o在下方另起一行插入 O在上方另起一行插入 :q退出 :q！强制退出 :w 保存 :wq 保存并退出 :x 如果文件更改了，相当于wq，如果文件没有更改，相当于q :shell 暂时进入shell命令，找到相关的信息，然后按ctrl + d :set number 设置行号 :set nonumber 不设置行号 /关键字 搜索关键字 ，按n/N跳转到上/下一个关键字 :nohlsearch 取消搜索高亮 搜索与替换 :%s/搜索的字符/替换的字符/&lt;选项&gt; %代表全部的意思， s代表搜索的意思，进入搜索模式 1,9s/chenxiaojian/student/g 表示从1到9行进行搜索，g的意思代表全部替换，如果不加，则只是替换每一行的第一个字符 9s/chenxiaojian/student/g 表示在第9行进行搜索与替换]]></content>
      <categories>
        <category>Linux</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理]]></title>
    <url>%2FLinux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[linux的文件结构 目录 作用 /sbin 存放系统命令 /bin 存放用户命令 例如：ls /usr/bin/ls /root 存放启动信息和内核信息 /dev 存放设备 /home 普通用户的主目录，存放普通用户的信息和配置信息 /mnt 用于挂载设备的目录 /proc 系统运行的文件，占用内存 例如：/proc/cpuinfo /proc/meminfo /root root用户的主目录，存放root用户的信息和配置信息 /tmp 临时目录 /usr 安装软件的默认目录 /var 存放可变 大文件 /etc 存放系统配置文件 文件路径 文件类型 /var/log 日志文件 /usr/bin 普通执行程序文件 /usr/sbin 服务器执行程序文件和管理程序文件 /etc 应用程序配置文件 /usr/share/doc 应用程序文档文件 /usr/share/man 应用程序手册页文件 dev目录 存放的东西,也就是设备，我们不能直接访问这个目录的设备，Linux有挂载的概念，也就是提供一个目录，然后访问这些不能直接访问的东西 ls /dev/sda 查看你有第一块硬盘（首字母s代表着这个硬盘是SATA接口） ls /dev/sdb 查看你的第二块硬盘 (不同系统的硬盘结构可能不同，可能是以v开头的) ls /dev/sda1 代表的是第一块硬盘的第一个分区 ls /dev/sda2 代表的是第一块硬盘的第二个分区 ls /dev/sdb1 代表的是第二块硬盘的第一个分区 ls /dev/sr0 存放着光驱，也就是光碟 man 命令 1 –代表用户命令 5 –代表文件格式 8 –代表系统命令 文件（目录）处理查看文件 cat命令 用法 cat &lt;文件名&gt;注意之间有一个空格 查看cat命令的用法 cat –help 例如 ： cat -n /ect/passwd 就会给文件每一行进行编号 head 可以用于查看文件的前十行信息 tail 可以查看文件的后面10行信息 less 可以以翻页的形式查看文件 上下键，PaUp PaDn键 /关键字 –》》搜索 查看目录 ls 查看目录 -a 查看所有文件，包括隐藏文件 隐藏文件或者目录是 . 开头 . 代表当前目录， ..代表上一级目录 -l 查看详细信息 ls -l ==&gt;&gt; ll dr-xr-x—. 5 root root 205 8月 7 10:47 root 第一个字母表示文件类型 d :代表目录 -：代表文件 l : 代表链接 b: 代表块设备 第二，第三，第四r-x：所有者文件权限 r : 表示读取 w：表示写入 x：表示执行 -：表示无权限 第五，第六，第七r-x：所属组文件权限 第八，第九，第十r-x：其他用户的文件权限 第十一位 ：点代表没有配置ACL，+代表有配置ACL 第二段 “5” ：如果是目录表示目录下有几个子目录，如果是文件表示文件的链接数量 第三，四段：分别表示文件的所有者，文件所属（主要）组 第五段“205”：大小 第六七八段：代表文件的修改时间 第九段：文件、目录的名字 -d：查看目录本身的信息，通常与 -l 一起使用 ls -ld -R：以递归方式查看文件目录 -h：人性化的，就是将文件的字节转换成兆，千兆 创建目录 mkdir：创建目录 选项：-p 递归创建 创建文件 touch 创建空文件或更新文件时间戳（用于修改文件的时间属性，如果文件不存在，就创建一个新的文件） 复制 文件/目录 cp 复制文件 cp /root/file1 /home/student cp file1 file2 dir/ (复制多个文件) 复制目录 cp -r 递归复制目录，将目录的子目录和文件复制 cp -d link复制链接 cp -a == cp -rd cp -r &lt;源&gt;… &lt;目标&gt; 移动或重命名 mv 移动或重命名文件或目录（如果文件或者目录的位置没有改变，就是重命名） 用法： mv &lt;源&gt;… &lt;目标&gt; 例子 mv file1 file2 (重命名文件) mv file1 dir （将file1移动到dir的目录下） mv file1 dir2 dir （将dir2和file移动到dir） 删除文件、目录 rm 删除文件或目录（没有回收站）（如果是root用户，则会提示是否删除，需要输入y） rm -f 强制删除 删除目录，rm -r 递归删除 rm -rf （rm -rf /） 路径扩展 通配符 （用于shell命令行中匹配路径名） ”*****“ 匹配0个或多个字符 [abc123] 匹配括号任意一个字符 ？匹配任意一个字符 如果将aaa bbb复制到dir, cp ??? dir/ {} 大括号扩展 mkdir dir{1..4}{a..c} mkdir dir{a, d,1,9} 转义字符 \ 取消 \后一个字符的含义 mkdir a\ b ‘’ “” –取消引号中字符的含义 $ mkdir file$(date +%c) —-》》 file2019年09月07日 （命令输出代替命令本身） 文件归档与压缩 文件归档：将多个文件打包成一个文件的过程（并没有缩小文件的体积） 文件压缩：缩小文件体积的过程 tar 文件归档与压缩 用法： tar [选项] c(创建) t(查看) x(压缩) f(必选) v(可选) 查看详细 创建归档 用法：tar cvf &lt;归档后文件&gt;.tar &lt;需要归档的文件&gt; tar cvf dir.tar dir 归档目录 tar cvf dir.tar file？ 归档文件 查看归档 tar tvf dir.tar 提取归档 创建目录，并在新目录下提取归档 tar xvf &lt;归档文件&gt; 文件压缩 tar命名本身不支持压缩，但是可以调用压缩 压缩方式 特点 选项 标准格式 gzip 速度快，历史久，使用最广泛 z &lt;名字&gt;.tar.gz , &lt;名字&gt;.tar.tgz bzip 压缩率较小，速度最快 j &lt;名字&gt;.tar.bz2 xz 最新，压缩率最小 J &lt;名字&gt;.tar.xz 例如 tar cvf etc.tar /etc tar czvf etc.tar.gz /etc tar cjvf etc.tar.bz2 /etc tar cJvf etc.tar.xz /etc 文件查找 locate在locate数据库中按名称查找文件或目录 updatedb 手动更新locate数据库（每日更新一次） locate chenxiaojian find 在文件系统中查找文件 find &lt;查找范围&gt; &lt;选项&gt; &lt;参数&gt; 如果不指定目录，则在当前目录中查找 -name 按名称查找文件 -iname 按名称查找文件，不区分大小写 find / -name chenxiaojian -user 按用户查找文件 -group 按用户组查找文件 -size 按大小查找文件 大小： k，M, G +代表大于，-代表小于，没有指定代表等于（是向上取整的） find / -size -100M -exec find的二次处理 用法：find &lt;查找范围&gt; &lt;选项&gt; &lt;参数&gt; -exec &lt;处理动作&gt; 要求：在整个操作系统中查找admin用户的文件和目录，并将查找的结果复制到/root/dir目录下 find / -user admin -exec cp -r {} /root/dir \; find / -name “1.txt” -exec rm -rvf {} ; {}表示查找的结果； 分号代表结束；前面的\表示转义 重定向与管道每个进程都有三个通道，分别是标准输入，标准输出，标准错误 标准输入 stdin 0 键盘 标准输出 stdout 1显示 标准错误 stderr 2显示 重定向：将输出的默认位置替换为文件或其他设备 进程 1 &gt; 文件 作用：将进程1的标准输出写到文件里，覆盖文件内容 echo hello &gt; file1 将hello写入文件file1中，注意覆盖写(echo hello 1&gt;file1,通常1是可以省略的) 进程1 &gt;&gt; 文件 作用：将进程1的标准输出写入文件中，追加写 echo hello &gt;&gt; file1 进程1 2&gt; 文件 作用：将进程1的标准错误写到文件中，覆盖文件内容 ll /sdf 2&gt; file1 作用：将错误信息写入文件中 进程1 2&gt;&gt; 文件 作用：将进程1的标准错误写到文件中，追加写 ll /sdf 2 &gt;&gt; file1 如果一条进程，也就是一条命令既有正确也有错误，都写入文件中 ll file1 /dfs &amp;&gt; file1 ll file1 /dfs &amp;&gt;&gt; file1 如果将标准错误和标准输出写入不同的文件 ll file1 /dfs &gt;&gt; log1 2&gt;&gt; log2 管道：是指将进程1 的输出作为输入传递给进程2 进程1 | 进程2 ll /etc | less 文本处理 grep 进行文本处理，参数文件例如/etc/passwd，查找关键字是否在这个文件中 用法： grep &lt;关键字&gt; &lt;文件&gt; （注意grep匹配的是文件里面的信息） grep chenxiaojian /etc/passwd 跟管道配合使用 cat /etc/passwd | grep chenxiaojian 正则表达式 –模式匹配，数据匹配 *匹配0个或多个字符 ^ 行首定位符 $行尾定位符 -v 反选 -e 支持多个关键字 -E 支持更复杂的匹配模式 ^$ 匹配空行 常用命令 cd 切换路径 pwd 查看当前目录的绝对路径 常见错误 如果当前路径为/home/chenxiaojian，然后这个chenxiaojian的目录下有许多文件例如file1，那么进入/操作都是 cd / ll file1（前提是当前目录是/home/chenxiaojian）]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux文件管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中str和repr方法]]></title>
    <url>%2Fpython%E4%B8%ADstr%E5%92%8Crepr%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[str()方法面向用户 repr()方法面向程序员 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Item: def __init__(self,name): self.name = name def __str__(self): print("我在调用重写的str方法") return self.name def __repr__(self): print("我正在调用重写的repr方法") return 'Item(&#123;!r&#125;)'.format(self.name)a = Item("陈小坚")print(repr(a)) # 调用重写的repr方法,print("\n我是分割线-----------------------------\n")b = Item(repr('陈小坚')) # repr函数，这里其实是object的repr方法，也就是默认的repr方法print(b)print("\n我是分割线-----------------------------\n")c = repr('陈小坚') # repr函数，这里其实是object的repr方法，也就是默认的repr方法print(c)print("\n我是分割线-----------------------------\n")d = Item('陈小坚') """ 这里d是一个类对象，print输出时就会d这个对象时，相当于就是对d进行渲染，就会调用str方法， 然后这个对象是类对象，就查看这个类有没有重写的str方法，有就会调用重写的str方法，没有就会调用object的str方法 """print(d)print("\n我是分割线-----------------------------\n")"""我正在调用重写的repr方法Item('陈小坚')我是分割线-----------------------------我在调用重写的str方法'陈小坚'我是分割线-----------------------------'陈小坚'我是分割线-----------------------------我在调用重写的str方法陈小坚请按任意键继续. . ."""class test: def __repr__(self): print("我是str方法") return "hahahah"e = test()print(e) # print方法默认会调用str方法，然后str方法默认就会调用repr方法"""我是str方法hahahah""" 总结 print函数默认会调用str方法，然后str方法如果没有定义，内部默认是调用repr方法 然就对于类对象来说，print方法首先查看内部有没有重写的str方法，如果有调用该方法，如果没有就会 看看有没有重写的repr方法，如果有就会调用该方法，如果也没有repr方法，就会调用object类的str方法 因为所有的类都会继承这个object类 此外，str方法默认就是调用repr方法，此外，对于repr方法和str方法，都要return字符串]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python堆队列算法]]></title>
    <url>%2Fpython%E5%A0%86%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[heapq模块 – 堆队列算法堆：堆是个一个二叉树，他的每个父结点的值都大于或者小于所有孩子节点的值]]></content>
      <categories>
        <category>Python数据结构</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷】P1019 单词接龙]]></title>
    <url>%2F%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P1019%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%2F</url>
    <content type="text"><![CDATA[题目描述单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beastbeastbeast和astonishastonishastonish，如果接成一条龙则变为beastonishbeastonishbeastonish，另外相邻的两部分不能存在包含关系，例如atatat 和 atideatideatide 间不能相连。 输入格式输入的第一行为一个单独的整数nnn (n≤20n \le 20n≤20)表示单词数，以下nnn 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在. 输出格式只需输出以此字母开头的最长的“龙”的长度 输入输出样例输入 #1 12345675attouchcheatchoosetacta 输出 #1 123 说明/提示（连成的“龙”为atoucheatactactouchoose） NOIp2000提高组第三题 思路： 首先采用一个string数组，存取输入的单词，然后根据输入的字母，也就是龙的头，找到数组中每一个能够与这个字母进行相接的单词，从这些单词开始，进行DFS。 然后，每一个单词可以出现最多两次，可以设置一个visited数组进行标记 需要判断两个单词能否相接，设置一个处理函数，传入两个参数，也就是两个要处理的单词，如果这两个单词能够相接，并且对原来的单词的长度产生影响，也就是变长了，那么返回这个这两个单词相接的结果。如果不能相连接，那么返回第一个参数；注意特殊情况，如果能够相接，并且a包含b,或者b包含a,那么他们相接后的结果，即是长度跟原来相比，没有增加，所以还是返回第一个参数。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// P1019 单词接龙.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//// P1019 单词接龙.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int visited[30];string arr[30];string first;string res_str = "";int n;int res = 0;string deal(string a, string b) //分成两种情况进行判断&#123; //大佬说ddababab 和 abab，这个可以连成 ddabababab,不过，这个两个不是包含关系吗=-= //我持保留意见 if (a.size() &gt; b.size()) //判断包含，因为存在特殊情况 XXXtact tact &#123; string temp = a.substr(a.size() - b.size()); if (temp == b) return a; &#125; if (a.size() &lt; b.size()) &#123; string temp = b.substr(0, a.size()); if (temp == a) return a; &#125; int i = 1; while (i &lt; a.size() &amp;&amp; i &lt; b.size()) &#123; string c = a.substr(a.size() - i); string d = b.substr(0, i); // cout &lt;&lt; "hahah " &lt;&lt; d &lt;&lt; endl; if (c == d) break; else i++; &#125; if (i &lt; a.size() &amp;&amp; i &lt; b.size()) return a + b.substr(i); else return a;&#125;void dfs(string temp)&#123; if (res &lt; temp.size()) res = temp.size(); for (int i = 0; i &lt; n; i++) &#123; if (visited[i] &gt;= 2) continue; else &#123; string temp1 = deal(temp, arr[i]); //cout &lt;&lt; "temp:" &lt;&lt; temp &lt;&lt; " " &lt;&lt; "temp1:" &lt;&lt; temp1 &lt;&lt; endl; if (temp1.size() == temp.size()) continue; else &#123; visited[i]++; dfs(temp1); visited[i]--; &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; cin &gt;&gt; first; for (int i = 0; i &lt; n; i++) &#123; if (arr[i][0] == first[0]) &#123; visited[i]++; dfs(arr[i]); visited[i]--; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; //cout &lt;&lt; deal("", "penv11") &lt;&lt; endl;&#125;//判断重复部分出现问题//规则理解错误。。。算了/*1envelopee15*/ 总结 对于DFS和回溯的理解还是太浅了=-=，看别人的代码又懒得看下去，只能自己写，然后有点丑陋=-= 不过，通过这道题，我想我对DFS和回溯的思想更深了，毕竟代码调试了很久=-= 此外对于一些结果条件的判断，还是能冷静，静下心来=-=（被一个小失误耽误了很久=-=）]]></content>
      <categories>
        <category>OJ</category>
        <category>洛谷</category>
        <category>算法</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中深拷贝和浅拷贝解析]]></title>
    <url>%2Fpython%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[直接赋值，浅拷贝和深拷贝的区别直接赋值1234567# 直接赋值，其实就是对对象的引用a = [1,2,[3,4,5]]b = aprint(id(a)," ", id(b))# 1568089149128 1568089149128# 因为a b 都是[1,2,[3,4,5]]这个对象的引用，a和b指向同一块的内存地址 浅拷贝：拷贝父对象，不会拷贝对象内部的子对象 12345678910111213141516171819# 浅靠别拷贝import copya = [1,2,3,4,[99,88]]b = copy.copy(a)print(b)print(id(a), id(b))# [1, 2, 3, 4, [99, 88]]# 1781465341832 1781465338504# 可以看出a，b指向不同的对象# 修改a的子对象a[4][1] = 100000print("a的值", a)print("b的值", b)# a的值 [1, 2, 3, 4, [99, 100000]]# b的值 [1, 2, 3, 4, [99, 100000]]# 可以看出，a,b的对象内部的子对象还是同一个、 深拷贝： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。 12345678910111213141516171819# 深拷贝import copya = [1,2,3,4,[99,88]]b = copy.deepcopy(a)print("id a:",id(a))print("id b:",id(b))# id a: 2207231741768# id b: 2207226938760# 修改a对象的子对象a[4][1] = 100000print('a的值',a)print('b的值',b)# a的值 [1, 2, 3, 4, [99, 100000]]# b的值 [1, 2, 3, 4, [99, 88]]# 可以看出这次修改a的子对象并不会对b造成影响,说明这两个对象的子对象不是同一个]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python双向队列deque]]></title>
    <url>%2Fpython%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97deque%2F</url>
    <content type="text"><![CDATA[deque:返回一个双向队列的对象、 deque([iterable, [maxlen]])，从左到右初始化，（用方法append()），从iterable可迭代对象创建数据，如果没有指定，则这个双向队列为空。 从队列两端添加或者弹出元素的复杂度是O(1)，这个跟列表不同，列表的头部插入和移除元素的复杂度为O(n) maxlen如果没有指定或者为None，那么deque可以增长到任意长度，否则，deque就限定到最大长度。当指定长度的deque满了之后，当新项加入时，就从另一端弹出元素。 123456789101112from collections import dequeq = deque('123',maxlen=3)print(q)# deque(['1', '2', '3'], maxlen=3)q.append('5') # 队列右端插入,如果满了，就将左端的第一个元素弹出print(q)q.appendleft('99')print(q)# deque(['1', '2', '3'], maxlen=3)# deque(['2', '3', '5'], maxlen=3)# deque(['99', '2', '3'], maxlen=3) 方法append(x)–添加x到右端appendleft(x)–添加x到左端clear()–移除所有元素，使其长度为0copy()–创建一份浅拷贝count(x)–计算deque中个数等于x的元素123456789101112131415161718from collections import dequeq = deque('1234')q.append(55)# deque(['1', '2', '3', '4', 55])q.appendleft(88)# deque([88, '1', '2', '3', '4', 55])q.append('1')print(q.count('1'))# 2q.clear()# deque([])print(q) extend(iterable)–扩展deque的右侧，通过添加iterable参数中的元素extendleft(iterable)–扩展deque的左侧。注意可迭代对象中的元素顺序被反着过来添加index(x)–返回x在deque中的下标123456789101112from collections import dequeq = deque('123')q.extendleft([4,5,6])# deque([6, 5, 4, '1', '2', '3'])q.extend([7,8,9])# deque([6, 5, 4, '1', '2', '3', 7, 8, 9])print(q)print(q.index('1'))# 3 insert(i,x)–在位置i插入x,如果插入会超过最大长度，则会返回一个IndexErrorpop()–移除并且返回一个元素，队列最右端的那一个，如果没有，就返回IndexErrorpopleft()–移除返回最左的一个元素remove(value)–移除找到的第一个value,没有返回ValueErrorreverse()–将队列逆序排序，返回Nonerotate(n)–向右循环移动N步，如果是负数，就向左循环1234567891011121314151617181920212223242526272829303132# from collections import dequeq = deque('123', maxlen=3)# q.insert(0, 55)# print(q)# 发生异常: IndexError# deque already at its maximum sizeprint(q.popleft())# 1q.appendleft('2')# deque(['2', '2', '3'], maxlen=3)q.remove('2')# deque(['2', '3'], maxlen=3)print(q.reverse())# Noneprint( q)# deque(['3', '2'], maxlen=3)q1 = deque([1,2,3,4])print(q1)q1.rotate(2)print(q1)# deque([1, 2, 3, 4])# deque([3, 4, 1, 2]) 应用限长的deque提供一个过滤功能打开文件的坑：可能是由于vscode的配置的python环境问题，在本次例子中，cwd的路径应该是 d:\python学习\python数据结构，导致文本文件的相对路径问题。本来在同一个目录的py文件和文本文件，文件名的相对路径直接写上文件名就好了。 1234567# 注意一个问题，就是启动python进程的当前路径，要根据这个路径进行写文件的相对路径f = open('python数据结构/1.txt')import oscwd = os.getcwd()print(cwd)# d:\python学习print(os.path.dirname(__file__)) #当前脚本所在目录的绝对路径 1234567891011121314from collections import dequedef tail(filename, n=10): 'Return the last n lines of a file' with open(filename) as f: return deque(f, n)a = tail('python数据结构/1.txt')print(a)"""结果：返回了文件的最后10行，我想应该是相当于是因为由于限长，相当于append方法的原理deque(['444\n', '5555\n', '666666\n', '77777\n', '88888\n', '9999999\n', 'AAAAAAAAAAA\n', 'BBBBBBBBBBBBBBB\n', 'CCCCCCCCCCCCCCCCCC\n', 'DDDDDDDDDDDDDDDDDDDD'], maxlen=10)请按任意键继续. . ."""]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python生成器与迭代器]]></title>
    <url>%2Fpython%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[生成器 定义：调用一次，只生成一个值的特殊函数； 如果一个函数中含有yiled关键字，这个函数就成了生成器，只会在next方法的调用下执行，遇到yelid结束函数，并返回yiled后面所跟的值 产生生成器的方法_next_()，send()，都是启动生成器，但是send会yield返回一个值，即是yield=send的参数，而__next__方法则不会传值，或者传None; 注意yield在一个函数中，那么这个函数就是一个生成器，例如a = f()，这时a是一个生成器对象的实例，需要a.__next__()或者a.send(args)，启动生成器，第一次启动，send的参数应为None 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 列表生成式a = [i*2 for i in range(10)]print(a)# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]# 产生一个生成器可以将列表生成式的[]改成（）# 调用这个生成器,生成的数据并不是一次存放在内存中的，# 只有当这个数据循环或者__next__()到这个数据时才会生成b = (i*2 for i in range(10))print(b)# &lt;generator object &lt;genexpr&gt; at 0x000001D667CF3840&gt;print(next(b))print(b.__next__())print("begin loop\n")for i in b: print(i) # 0# 2# begin loop# 4# 6# 8# 10# 12# 14# 16# 18# 生成器实现裴波那契s数列# yield的作用就是一个函数变成一个生成器，调用fo(10)不会执行fo函数，而是返回一个可迭代对象# 每次执行到yield语句时，就会返回一个可迭代值，然后程序运行就会停留在yield语句这里，然后退出这个fo函数，下次# 用__next__()方法调用这个可迭代值，就会回到yield的下一句语句，然后继续执行fo函数，直到遇到下一个yield语句# 当函数执行结束时，generator 自动抛出 StopIteration 异常，表示迭代完成。# 在 for 循环里，无需处理 StopIteration 异常，循环会正常结束。"""def fo(number): i,a,b=0, 0, 1 while i &lt; number: yield b a,b=b,a+b i = i+1 return "我是fo函数的返回值"c = fo(10)print(c)# &lt;generator object fo at 0x0000023382C33750&gt;while True: try: print(c.__next__(), end=" ") except StopIteration as e: # as定义异常实例 print("已经10个数了", e.value) break# 1 1 2 3 5 8 13 21 34 55 已经10个数了 我是fo函数的返回值""" 迭代器 可迭代对象 iterable —可以进行for循环的对象，例如列表，元组。。。 迭代器 iterator —可以被next()函数调用并不断返回下一个值的对象 1234567891011# 导入模块，可能是版本问题，collections加上.abcfrom collections.abc import Iterable,Iteratorprint(isinstance([], Iterable))# True# 内置方法，将可迭代对象转成迭代器 iter()print(isinstance(iter([]), Iterator))# True#]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数参数]]></title>
    <url>%2Fpython%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数参数的类型 必需参数 关键字参数 默认参数 不定长参数 必需参数调用时传入的参数的个数须和声明时的参数个数一样，并且传入的顺序需要一致，一一对应。 123456789101112def f(a,b): print("函数参数的值为&#123;&#125;,&#123;&#125;".format(a,b))f(1,5)list1 = [2,3]f(*list1) # 在调用函数时在参数中加个*是将列表、元组转成多个参数# 执行结果：# 函数参数的值为1,5# 函数参数的值为2,3# 请按任意键继续. . . 关键字参数使用关键字参数允许传入参数的顺序与声明时不一致，因为python解释器能够根据参数名匹配参数值 12345678910# 关键字参数def f1(name, age): print("我的名字：&#123;&#125;，我的年龄：&#123;&#125;".format(name,age))f1(age=18, name="陈小坚")# 执行结果：# 我的名字：陈小坚，我的年龄：18# 请按任意键继续. . . 默认参数调用函数时，如果函数没有没有传递参数，就会使用默认参数 总结：带默认值的参数必须放在没有默认值的参数后面，如果不这样做，可能会产生歧义，程序error 123456789101112131415161718192021222324# 默认参数# error code"""def f2(name='陈小坚', age): print("我的名字：&#123;&#125;我的年龄：&#123;&#125;")f2("晨晨陈",20)"""def f2(age,name='陈小坚'): print("我的名字：&#123;&#125;\n我的年龄：&#123;&#125;".format(name,age))f2(20, "陈陈陈")print("----------------")f2(20)# 程序结果：# 我的名字：陈陈陈# 我的年龄：20# ----------------# 我的名字：陈小坚# 我的年龄：20 不定长参数函数调用时传入的参数比声明时的参数多，两个基本语法 带*星号的参数会以元组的形式导入，存放一些多的，没有命名的参数 带**的参数则会以字典的形式处理 123456789101112131415161718192021222324252627282930313233343536# 不定长参数def f3(a, b, *c): print(a) print(b) print(c)list2=[1,2,3,4,5,6,7,8]f3(1,3,1,2,3,4,5)print("\n")f3(1,4) # 如果不传入第3个参数，则默认传入一个空元组print("\n")f3(1,2,list1)print("\n")f3(1,2,*list1) # 将列表转成多个参数传入# 执行结果：# 1# 3# (1, 2, 3, 4, 5)# 1# 4# ()# 1# 2# ([2, 3],)# 1# 2# (2, 3)# 请按任意键继续. . 123456789101112131415# 总结：以字典传入参数时，如果实参没有key=Value这个形式的参数例如：f4(1,2,3)，会默认将这些实参传给# 例子中的a,然后出现错误,因为a接受了多个参数def f4(a, **arg): print(a) #不指定参数的话，就是一个空字典 print(arg)print("执行结果：")f4(1)f4(1,a1=4, b=9, c="陈小坚")# 执行结果：# 1# &#123;&#125;# 1# &#123;'a1': 4, 'b': 9, 'c': '陈小坚'&#125;# 请按任意键继续. . . 声明函数时，可以单独出现，但是在传入参数的时候，后面的参数需要以关键字参数的形式传入 1234567# 特殊情况：def f5(a,b,*,d): return a+b+dprint(f5(1,2,d=4))# 7 对*和**的使用方法的总结： 形参加*，在调用函数时可以将传入的多个参数转换成一个元组；实参加*，可以将传入的列表或者元组转换成多个参数 123456789101112131415161718192021222324def f1(a,b,*c): print(a) print(b) print(c)f1(99,88,77,66,55,44,33)# 99# 88# (77, 66, 55, 44, 33)# 请按任意键继续. . .def f2(a,b,c,d): print(a) print(b) print(c) print(d)list1 = [2,3,4]f2(0,*list1)# 0# 2# 3# 4# 请按任意键继续. . . 形参加**，在调用函数时可以将传入的多个键值对转换成一个字典；实参将**，可以将传入的字典转成多个键值对，相当于以关键字参数传给形参 123456789101112131415161718192021def f3(a,b,**c): print(a) print(b) print(c)f3(1,2,d=3,f=4,m="陈小坚")# 1# 2# &#123;'d': 3, 'f': 4, 'm': '陈小坚'&#125;def f4(name, age, sex): print("我的名字:&#123;&#125;\n我的年龄：&#123;&#125;\n我的性别：&#123;&#125;".format(name,age,sex))dict1= dict(name="陈小坚", age=18,sex="男")f4(**dict1)# 我的名字:陈小坚# 我的年龄：18# 我的性别：男# 请按任意键继续. . .]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python装饰器]]></title>
    <url>%2Fpython%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器：本质就是一个函数 不会修改被装饰函数的源代码 不会修改被装饰函数的调用方式 实现装饰器的前提知识 函数即是”变量“，变量名其实相当于门牌号，其实就是对对象的引用，然后去内存中根据变量名找到对象； 而python的内存回收机制就是当一个对象没有没用被引用时，python就会自动地释放这个对象的内存空间；所以当我们用del删除一个变量，例如x,只是删除x对1这个对象的引用，当1没有被引用时，就会释放1啦； 此外，需要注意的是打印一个函数名，结果是这个函数在内存的地址 12345678910111213141516def f(): print("这个是f函数") f1()def f1(): print("这是个f1函数")f()# 这个是f函数# 这是个f1函数# 请按任意键继续. . .# 总结：f()函数被调用时，首先执行Print语句，然后执行f1()，就去内存中找“门牌号"为f1的”变量“# 即是：只要f1()只要已经被定义，存在内存中，在f()函数调用之前# 这个跟c/c++有所不同 高阶函数： 把一个函数名当做实参传给另外一个函数 返回值中包含函数名 123456789101112131415161718192021222324252627282930# 高阶函数# 做函数参数def f1(fune): print(fune) fune()def f2(): print("hahah")f1(f2)# 结果：# &lt;function f2 at 0x000001316AB9B9D8&gt;# hahah# 总结：函数名其实也是一个变量，也是可以作为参数进行传递的，打印函数名的结果就是这个函数的内存地址# 做返回值def f3(): print("这个是函数f3") return f3a = f3()a()# 结果：# 这个是函数f3# 这个是函数f3 嵌套函数——在一个函数的函数体内用def声明一个函数 需要注意局部作用域和全局作用域 函数体的内容只有在调用时才会被执行 123456789101112131415161718192021222324252627282930# 嵌套函数def f4(): def f5(): print("我是f5函数") return f5 f5() return f5b = f4()b()print(b)# 执行结果：# 我是f5函数# 我是f5函数# &lt;function f4.&lt;locals&gt;.f5 at 0x000002576940CBF8&gt;##################################################def f6(): print("这个是f6") def f7(): print("这个是f7")f6()# 执行结果：# 这个是f6# 请按任意键继续. . .# 总结：需要注意局部作用域，f7这个函数它只在f6这个函数的函数体内存在作用 装饰器实现样例：12345678910111213141516171819202122232425262728293031323334353637# 问题：给f()函数增加程序执行时间计算的功能。import timedef deco(fune): def count_time(): start_time = time.time() fune() end_time = time.time() print("函数执行的时间为&#123;&#125;".format(end_time-start_time)) return count_time @decodef f(): time.sleep(3) print("我是f函数")@decodef f1(): time.sleep(3) print("我是f1函数")# f = deco(f) #可以改成“@装饰器”f()f1()# 执行结果# 我是f函数# 函数执行的时间为3.0018532276153564# 我是f1函数# 函数执行的时间为3.0000414848327637# 请按任意键继续. . .# 总结：需要注意装饰器函数需要声明在被装饰函数的前面，因为@deco就是相当于f = deco(f),# 如果不这样做的话，python解释器运行到@deco,就会起调用这个deco函数，你得保证内存中已经定义好# 这个deco函数 实现样例存在问题：函数返回值的问题与不同函数会有不同的参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 存在问题，如果装饰的函数存在不同的函数参数的个数，import timedef deco(fune): def calculater_time(*args1, **args2): start_time = time.time() funtion_return_values = fune(*args1, **args2) # 新增代码，解决加上装饰器函数的返回值问题 end_time = time.time() print("程序运行的时间为%s" %(end_time-start_time)) return funtion_return_values # 新增代码，解决加上装饰器函数的返回值问题 return calculater_time@decodef test1(): time.sleep(2) print("程序执行test1") return "我是test1的返回值"@decodef test2(a): time.sleep(2) print("程序执行test1,并且传入一个参数为&#123;&#125;".format(a))@decodef test3(name, age): time.sleep(2) print("名字：&#123;&#125;, 年龄：&#123;&#125;".format(name,age))# 调用：res = test1()test2("陈小坚")test3(1, age=18) #装饰器不影响原来的调用方式print("表面调用test1的返回值：&#123;&#125;".format(res)) # 表面调用test1的返回值：None# 本来应当返回 "我是test1的返回值",但是却返回None，因为这个test1在调用时其实已经不是test1,# calculater_time函数的函数体内其实已经test1已经返回"我是test1的返回值"，但是却没有人接受，所以装饰器还可以在修改# 程序执行test1# 程序运行的时间为2.002197504043579# 程序执行test1,并且传入一个参数为陈小坚# 程序运行的时间为2.004718065261841# 名字：1, 年龄：18# 程序运行的时间为2.0046701431274414# 表面调用test1的返回值：我是test1的返回值# 请按任意键继续. . . 存在需求：根据装饰器的参数的不同，选择不同的执行方式解决：在上面的基础上在外层加上一个函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 存在需求，如果根据装饰器的不同参数，执行不同的代码,例如登录系统中，不同的认证方式# 事先设置用户名username="陈小坚"password="123"def deco(auth_type): def deco_inside(func): def auth_funtion(*agrs1, **agrs2): if auth_type=="local": username1 = input("input your name:").strip() password1 = input("input your password:").strip() if username==username1 and password==password1: print("welcome &#123;&#125;,login in sucessfully!!".format(username1)) func() else: print("error: valiavd username or password") else: print("你不是在本地登录的！！！") return auth_funtion return deco_inside@deco(auth_type="local")def home(): print("welcome to home page!!")@deco(auth_type="foreign")def about(): print("welcome to about page!!")# 其实就是在加了一层，只不过执行顺序还是要注意home()#运行顺序，首先将local传递给auth_type，然后返回return deco_inside,这样就会去执行deco_inside(func)---&gt;&gt;相# 当于home=deco_inside(home),home--&gt;func,而这个deco_inside函数返回auth_funtion给home赋值，# 于是home()--&gt;auth_funtion()about()# 程序执行结果：# input your name:陈小坚# input your password:123# welcome 陈小坚,login in sucessfully!!# welcome to home page!!# 你不是在本地登录的！！！# 请按任意键继续. . .]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块]]></title>
    <url>%2Fpython%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[前言对python模块的理解 导入方式：使用import语句 python解释器如何找到所需的模块，第一项是空串，代表当前目录 12import sysprint(sys.path) from ... import *把一个模块的所有内容全部导入到当前的命名空间中，但是不建议过多的使用 每个模块都有一个__name__属性，当其值是__main__时，表明该模块自身在运行，否则是被引入的 dir()函数可以找到模块内定义的所有名称 包：管理python模块命名空间的形式，在包的目录中有一个__init__.py的文件，这个目录才会认为是包，__init__.py文件可以为空，也可以定义__all__ = [&#39;类名或者方法名&#39;,&#39;&#39;,&#39;&#39;]，这样使用from 包名 import * 就只会导入__all__中定义的模块名 1.实现类似进度条的方法12345678import sys, timefor i in range(20): sys.stdout.write('#') # 不换行的输出 sys.stdout.flush() # 刷新缓冲区 time.sleep(0.5) # 函数推迟调用线程的运行# 实现类似进度条的效果 2.输出python3文件的默认编码12345import sysprint(sys.getdefaultencoding# python3中字符的编码格式默认是Unicode，如果gbk编码的文件要在utf-8显示， 步骤，先decode('gbk').encode('utf-8') 即是gbk--&gt;Unicode--&gt;utf-8 3.输出utc时间12import datetimeprint(daetime.datetime.utcnow())]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python未解决问题&&问题合集]]></title>
    <url>%2Fpython%E6%9C%AA%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[python中文件读写，对于英文字符的文件内容，读意味着文件指针移动一个，也就是说文件指针的位置跟所读的字符个数相等，但是对于中文字符，文件指针的位置跟自己想象的不同解决：首先知道文件编码英文和汉字所占的字节个数英文字母：·字节数 : 1;编码：GB2312 字节数 : 1;编码：GBK 字节数 : 1;编码：GB18030 字节数 : 1;编码：ISO-8859-1 字节数 : 1;编码：UTF-8 字节数 : 4;编码：UTF-16 字节数 : 2;编码：UTF-16BE 字节数 : 2;编码：UTF-16LE 中文汉字：字节数 : 2;编码：GB2312 字节数 : 2;编码：GBK 字节数 : 2;编码：GB18030 字节数 : 1;编码：ISO-8859-1 字节数 : 3;编码：UTF-8 字节数 : 4;编码：UTF-16 字节数 : 2;编码：UTF-16BE 字节数 : 2;编码：UTF-16LE 12345678910111213141516171819f = open('test1.txt', 'r', encoding='utf-8')print("当前文件指针的位置：", f.tell())# 0data = f.read(10)print("读出的字符串的内容为：", data)print(type(data))print("读出字符串的长度：", len(data))print("当前文件指针的位置：", f.tell())f.close()# 当前文件指针的位置： 0# 读出的字符串的内容为： 我陈小坚哈哈哈陈小坚# &lt;class 'str'&gt;# 读出字符串的长度： 10# 当前文件指针的位置： 30# 请按任意键继续. . . 读取文件的10个汉字，然后文件指针移动到了30的位置，说明了read()函数是读取字符个数，而所读取的字符都是汉字，占3个字节，因为是utf-8的编码 总结：seek()移动的是字节数，read()读取的是字符的个数 读取csv文件首个元素出现\ufeff的字符，原因是由于在utf-8编码文件中BOM在文件头部，占用三个字节，用来标示该文件属于utf-8编码，打开文件的编码用utf-8-sig表示带标记的utf-8编码]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[python函数:返回值数为0时，返回None,大于1时，返回元组。 高阶函数 strip() 方法 用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。 注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。 12345str1 = "0000你好0000"print(str1.strip('0'))# 执行结果# 你好# 请按任意键继续. . enumerate()方法 enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 如果第二个参数不指定的话，默认下标从0开始，否则按照参数的值作为起始下标 12345678910111213list1 = ['哈哈','嗯嗯','嘿嘿','额鹅鹅鹅']for index, i in enumerate(list1, 6): print(index,i)list2 = list(enumerate(list1))print(list2)# 6 哈哈# 7 嗯嗯# 8 嘿嘿# 9 额鹅鹅鹅# [(0, '哈哈'), (1, '嗯嗯'), (2, '嘿嘿'), (3, '额鹅鹅鹅')]# 请按任意键继续. . . isinstance(obj,type) 判断一个对象是属于什么类型，返回值为bool值 1234567891011121314class animals(): def run(self): print("动物正在奔跑")class cat(animals): def run(self): print("小猫正在奔跑")cat1 = cat()cat1.run()# 小猫正在奔跑print(isinstance(cat1, animals))# True join()函数：可以将列表，元组，字符串中的元素用指定的元素连接起来 123output = '\t'.join(['name', 'age', 'gender'])print(output)# name age gender]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件操作]]></title>
    <url>%2Fpython%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件操作的三个步骤 打开文件 操作文件 关闭文件 文件打开模式 r：open()方法不指定的时候，默认是只读模式 w：打开一个文件进行写入，如果文件存在，则打开文件并从头编辑，如果文件不存在，则会创建新的文件 a：打开一个文件进行追加写，也就是说，这种模式不能进行读文件，且如果文件存在，文件指针就会指向文件的末尾，这样写文件时就会将字符串写在文件的末尾；若文件不存在，则会创造一个新文件 r+：读写模式，打开一个文件，并追加写 1.open()方法1234567f = open("test1.txt", encoding="utf-8").read()print(f)# &lt;_io.TextIOWrapper name='test1.txt' mode='r' encoding='cp936'&gt;# open()如果不指定打开模式，默认是以只读打开# 此外要注意文件的编码方式# 如果文件是用utf-8编码的，那么如果不指定以什么编码方式打开，可能就会默认以系统打开文件的方式打开，在windows系统上通常用GBK方式打开文本文件。但是GBK是不能解析utf-8. 2.read()方法​ 用于从文件读取指定的字符个数，如果未给定或为负则读取所有。 123456789f = open("test1.txt", encoding="utf-8")data1 = f.read()data2 = f.read()print(data1," ----", data2)# 程序执行结果：# 哈哈哈 啊啊啊 ----# 结果显示data2为空，说明第一次读文件的时候，读完之后文件指针指向了文件的末尾，所以第二次就没有读到任何东西 1234567f = open("test1.txt",encoding="utf-8")data1 = f.read(2)print(data1)# 程序执行结果# 哈哈# 说明了汉字在这里是算一个字符的 3.write()方法​ 将字符串写入文件，并且返回写入字符串的长度。在文件关闭前或者缓冲区刷新前，字符串的内容是存放在缓冲区中，这时在文件内是看不到字符串的。 1234f = open("test1.txt",'w',encoding="utf-8")print(f.write("我是陈小坚"))# 程序执行结果# 5 注意，如果是wb模式打开文件的话，即二进制写文件，那么字符串要转换为bytes形式（字节） 此外，以wb模式打开文件，不能指定encoding编码方式，如果指定则会报错 binary mode doesn&#39;t take an encoding argument 1234567f = open("test1.txt",'wb')print(f.write("我陈小坚".encode(encoding='utf-8')))print("我陈小坚".encode(encoding='utf-8'))# 测试结果# 12# b'\xe6\x88\x91\xe9\x99\x88\xe5\xb0\x8f\xe5\x9d\x9a' 123456789# 追加方式打开字符串f = open("test1.txt", 'a', encoding="utf-8")print(f.write("哈哈哈陈小坚是个白痴！！"))# 测试结果# 12"""文件内容我陈小坚哈哈哈陈小坚是个白痴！！""" 4.readlin()方法​ 读取文件的一行，包括换行符 12345678910111213141516f = open("test1.txt",'r',encoding='utf-8')for i in range(5): print(f.readline())# 程序执行结果# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈1坚哈哈哈陈小坚是个白痴！！# 我陈2坚哈哈哈陈小坚是个白痴！！# 我陈3坚哈哈哈陈小坚是个白痴！！# 我陈4坚哈哈哈陈小坚是个白痴！！# 请按任意键继续. . . 5.readlines()方法​ 返回一个列表，列表的每个元素是文件一行的数据，包括换行符 只是适用读小文件 123456789f = open("test1.txt",'r',encoding='utf-8')# data = f.readlines()# print(data)# # 执行结果""" ['我陈小坚哈哈哈陈小坚是个白痴！！\n', '我陈1坚哈哈哈陈小坚是个白痴！！\n', '我陈2坚哈哈哈陈小坚是个白痴！！\n', '我陈3 坚哈哈哈陈小坚是个白痴！！\n', '我陈4坚哈哈哈陈小坚是个白痴！！\n', '我陈5坚哈哈哈陈小坚是个白痴！！\n', '我陈6坚哈哈哈 陈小坚是个白痴！！\n', '我陈小坚哈哈哈陈小坚是个白痴！！\n', '我陈小坚哈哈哈陈小坚是个白痴！！\n', '我陈小坚哈哈哈陈小坚是个白痴！！'] """ 123456789101112131415161718192021222324252627282930313233343536# 效率低的循环f = open("test1.txt",'r',encoding='utf-8')for i in f.readlines(): print(i.strip())# 由于readlines返回一个列表，并且列表中的元素是字符串形式，所以调用str.strip(),用于去除头尾的空格或者换行符# 执行结果# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈1坚哈哈哈陈小坚是个白痴！！# 我陈2坚哈哈哈陈小坚是个白痴！！# 我陈3坚哈哈哈陈小坚是个白痴！！# 我陈4坚哈哈哈陈小坚是个白痴！！# 我陈5坚哈哈哈陈小坚是个白痴！！# 我陈6坚哈哈哈陈小坚是个白痴！！# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈小坚哈哈哈陈小坚是个白痴！！# --------------------------------------------#高效的循环方式，将文件对象作为迭代器使用f = open("test1.txt",'r',encoding='utf-8')for line in f: print(line.strip())# line对象是str类型# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈1坚哈哈哈陈小坚是个白痴！！# 我陈2坚哈哈哈陈小坚是个白痴！！# 我陈3坚哈哈哈陈小坚是个白痴！！# 我陈4坚哈哈哈陈小坚是个白痴！！# 我陈5坚哈哈哈陈小坚是个白痴！！# 我陈6坚哈哈哈陈小坚是个白痴！！# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈小坚哈哈哈陈小坚是个白痴！！# 我陈小坚哈哈哈陈小坚是个白痴！！ 6.tell()方法返回文件的当前位置，即是文件指针的位置，位置是按照字符算的 123456789101112131415161718f = open('test1.txt', 'r', encoding='utf-8')print("当前文件指针的位置：", f.tell())# 0data = f.read(10)print("读出的字符串的内容为：", data)print(type(data))print("读出字符串的长度：", len(data))print("当前文件指针的位置：", f.tell())f.close()# 当前文件指针的位置： 0# 读出的字符串的内容为： 我陈小坚哈哈哈陈小坚# &lt;class 'str'&gt;# 读出字符串的长度： 10# 当前文件指针的位置： 30# 请按任意键继续. . . 7.seek()方法用于移动文件读取指针到指定位置。 第一个参数–开始的偏移量，也就是代表需要移动偏移的字节数，如果是负数表示从倒数第几位开始 第二个参数–默认是0.0表示当前位置，1表示文件头，2表示文件尾 123456789101112131415f = open('test1.txt', 'r', encoding='utf-8')# f.seek(10) # 出现utf-8编码错误，首先文本文件的编码方式是utf-8，所以可能是文件指针移动到10个字节，前提条件是我们的文件是utf-8编码# 然后一个汉字占3个字节，但是你文件指针移动10个字节，导致指针移动后所在的位置加上后面一个字节的内容不是utf-8所# 编码的内容，从而编码错误# 只需seek()参数是3的倍数就不会出现问题f.seek(9)print("当前文件指针的位置：", f.tell())data = f.readline()print("读取的内容为：", data.strip())# 当前文件指针的位置： 9# 读取的内容为： 坚哈哈哈陈小坚是个白痴！！# 请按任意键继续. . . 8.encoding返回文件的编码方式 1234f = open('test1.txt', 'r', encoding='utf-8')print(f.encoding)# utf-8# 请按任意键继续. . . 9.name–返回文件的名字10.flush()方法flush() 方法是用来刷新缓冲区的，即将缓冲区中的数据立刻写入文件，同时清空缓冲区，不需要是被动的等待输出缓冲区写入。 一般情况下，文件关闭后会自动刷新缓冲区，但有时你需要在关闭前刷新它，这时就可以使用 flush() 方法。 11.truncate()方法参数可选，如果指定参数，就是从参数所在的位置开始截断，参数是按照字节的大小进行保留的 Windows下换行符占两个字节 1234567f = open('test1.txt', 'r+', encoding='utf-8')f.truncate(25)# 文件结果：你好啊啊啊啊啊12# 因为这个文件是utf-8编码的，7个汉字占了21个字节，然后Windows下换行符占两个字节，数字英文utf-8占一个字符，所以截断后文件保留的内容就是这个占了25个字节的内容# 此外还应当注意文件的打开模式，r+读写模式，如果w模式打开，则文件内容变成二进制的。。。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceshi]]></title>
    <url>%2Fceshi%2F</url>
    <content type="text"></content>
      <categories>
        <category>OJ</category>
        <category>leetcode</category>
        <category>算法</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>hh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷】p3952时间复杂度]]></title>
    <url>%2F%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P3952%20%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下： 123F i x y 循环体E 其中F i x y表示新建变量 iii（变量 iii 不可与未被销毁的变量重名）并初始化为 xxx， 然后判断 iii 和 yyy 的大小关系，若 iii 小于等于 yyy 则进入循环，否则不进入。每次循环结束后 iii 都会被修改成 i+1i +1i+1，一旦 iii 大于 yyy 终止循环。 xxx 和 yyy 可以是正整数（xxx 和 yyy 的大小关系不定）或变量 nnn。nnn 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100100100。 “E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。 输入格式输入文件第一行一个正整数 ttt，表示有 ttt（t≤10t \le 10t≤10）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构 允许嵌套。 接下来每个程序的第一行包含一个正整数 LLL 和一个字符串，LLL 代表程序行数，字符 串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为nwn^wnw，其 中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。 接下来 LLL 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 iii 是一个小写字母（保证不为nnn），表示新建的变量名，xxx 和 yyy 可能是正整数或 nnn ，已知若为正整数则一定小于 100。 程序行若以E开头，则表示循环体结束。 输出格式输出文件共 ttt 行，对应输入的 ttt 个程序，每行输出Yes或No或者ERR（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出Yes，不一致则输出No，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出ERR 。 注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 输入输出样例输入 #1 1234567891011121314151617181920212223242526272829303132333482 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE 输出 #1 12345678YesYesERRYesNoYesYesERR 思路： 1.采用在线处理的方法，将F x i j 和E定义成string类型，每次读入一行数据，就判断是什么类型的语句 如果是F x i j就进栈中 如果E，就判断一下栈是否为空，不为空说明有F x i j与它相互匹配，就可以将栈顶元素，也就是也E语句相互匹配的最近的F x i j弹出来 2.如何判断结果是Yes or No，因为结果只有O(1)和O(n^m)，所以我们可以求出循环嵌套次数的最大值，然后跟1or m比较，如果相等，输出Yes，否则输出No。 3.判断输入是否存在错误，错误情况： 如果全部语句的个数是奇数的话，那肯定是错误的 如果F和E语句的个数不相等的话，也是错误的。例如：FFFFEE 如果F x i j和E语句的个数相等的话，如果存在FFEEEF，那么这种情况就是错误，这种情况循环结束后栈是不为空的，可以根据这个条件进行判断 还有一种错误就是变量名重复，由于变量名是一个小写字母，所以我们可以全局定义数组，循环输入语句时，判断，如果是F x i j，就提取第三个字符即是string[2]，对其处理，index= string[2]-97，所以例如字符a，就存放在数组的0号位置。因此，初始化数组，全部置0，表示还没定义变量，遇到一个变量，判断是不是没有被定义过，即是0，如果没有，置为1，表示被定义了，如果输入的变量被定义过了，设置一个flag，就可以判断错误了。此外销毁变量即是在出栈的时候，就把变量在数组中的置为0. 4.特殊情况 FEFE FFFEEFFEEE 此外就是如果一个F是不能进行循环的，那么其内嵌套的循环也是不是使得嵌套次数增加的，具体处理看代码 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;iostream&gt;# include &lt;string&gt;# include &lt;cstring&gt;# include &lt;stack&gt;using namespace std;int x_tag[30] = &#123; 0 &#125;; //变量名标志string temp_a = "";string temp_b = "";string temp_c = "";int string_int1(string a)&#123; for (int i = 4; i &lt; a.size()-1; i++) &#123; temp_c += a[i]; &#125; int temp = stoi(temp_c); temp_c = ""; return temp;&#125;void string_int(string a)&#123; int index; for (int i = 4; i &lt; a.size(); i++) &#123; if (a[i] != ' ') temp_a += a[i]; else &#123; index = i; break; &#125; &#125; for (int i = index + 1; i &lt; a.size(); i++) &#123; temp_b += a[i]; &#125; return;&#125;int main()&#123; int f_times = 0; int e_times = 0; int n; int line_number; //行数 string time; //时间复杂度 int times = 0; //看看有多少层循环 int max_times = 0; //最大层数 int flag = 0; //判断变量是否重复 int flag1 = 0; //判断是否错误 int flag_time = 0; //提取复杂度的特殊情况 FFFEEFFEEE int flag2 = 0; //如果在线读入的F少于E，也就是说，FFEEEE 这种特殊情况 stack&lt;string&gt;s; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; line_number; cin &gt;&gt; time; cin.ignore(); //清空缓冲区 for (int j = 0; j &lt; line_number; j++) &#123; string a; getline(cin, a); //这样空格也能被读进string a中 if (a[0] == 'F') &#123; if (x_tag[a[2] - 97] == 0) &#123; x_tag[a[2] - 97] = 1; &#125; else flag = 1;//出现同名变量 f_times++; //出现循环F的次数 s.push(a); //进栈 string_int(a); //得到F x i j的i和j if (temp_b == "n" &amp;&amp; temp_a != "n") //第一个为数字，第二个为n &#123; if (flag_time == 0) times += 1; //n次循环 else flag_time++; &#125; /* times flag_time F 1 0 F 2 0 F 不会进入循环 1 F 2 F 3 E 2 F 3 F 4 E 3 E 2 E 1 E 0 F 3 F 4 E E E E 最后max_times为4，也就是结果为O(n^4) */ //不会进入循环的情况 else if (temp_a != "n" &amp;&amp; temp_b != "n" &amp;&amp; stoi(temp_a) &gt; stoi(temp_b)) //两个都是数字,并且第一个数字大于第二个数字 flag_time++; else if (temp_a == "n" &amp;&amp; temp_b != "n") //第一个为n,第二个为数字 flag_time++; //至于其他情况不会对times嵌套次数造成影响，不用处理 temp_a = temp_b = ""; //更新嵌套的最大层数 if (max_times &lt;= times) &#123; max_times = times; &#125; &#125; else &#123; e_times++; if (e_times &gt; f_times) //特殊情况： FFEEEF flag2 = 1; if (!s.empty()) &#123; string temp1 = s.top(); int len = temp1.size(); s.pop(); x_tag[temp1[2] - 97] = 0; if(times != 0) //FFFEEFFFEEEE times--; //FEFE 最大次数为1，先times++,更新最大值，然后出栈减一 if (flag_time != 0) flag_time--; &#125; &#125; &#125; if (line_number % 2 != 0 || f_times !=e_times || !s.empty() || flag2 == 1 || flag==1) &#123; cout &lt;&lt; "ERR" &lt;&lt; endl; flag = 0; flag1 = 0; flag2 = 0; times = 0; f_times = e_times = 0; max_times = 0; flag_time = 0; memset(x_tag, 0, sizeof(x_tag)); while (!s.empty()) s.pop(); continue; &#125; if (max_times == 0 &amp;&amp; time[2] == '1') &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; // cout &lt;&lt; endl; times = 0; max_times = 0; flag = 0; flag1 = 0; flag2 = 0; f_times = e_times = 0; flag_time = 0; memset(x_tag, 0, sizeof(x_tag)); while (!s.empty()) s.pop(); continue; &#125; else if (max_times != 0 &amp;&amp; string_int1(time)== max_times) &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; // cout &lt;&lt; endl; times = 0; max_times = 0; flag = 0; flag1 = 0; flag2 = 0; f_times = e_times = 0; flag_time = 0; memset(x_tag, 0, sizeof(x_tag)); while (!s.empty()) s.pop(); continue; &#125; else &#123; cout &lt;&lt; "No" &lt;&lt; endl; // cout &lt;&lt; endl; times = 0; max_times = 0; flag = 0; flag1 = 0; flag2 = 0; f_times = e_times = 0; flag_time = 0; memset(x_tag, 0, sizeof(x_tag)); while (!s.empty()) s.pop(); continue; &#125; &#125; return 0;&#125;/*int main()&#123; int b; cin &gt;&gt; b; cin.ignore(); //它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容， //消除上一次输入对下一次输入的影响 string a; getline(cin, a); cout &lt;&lt; a &lt;&lt; endl; return 0;&#125;int main()&#123; string a = "F i 1 2"; //string_int(a, temp_a,temp_b)如果全局变量做函数参数，还是一个基本问题，只有引用参数和指针参数才会改变实参的值 string_int(a); cout &lt;&lt; temp_a &lt;&lt; " " &lt;&lt; temp_b &lt;&lt; endl; return 0;&#125;*/ 总结 输入一开始的问题：getline()，如果前面有cin，就需要清空键盘缓存区的回车键，用cin.ignore() 此外，每次大循环一次过后，要将所有用到的临时变量，标志啥的置为初始值，由于stack没有函数清空，所以要注意。]]></content>
      <categories>
        <category>OJ</category>
        <category>洛谷</category>
        <category>算法</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>栈</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面向对象]]></title>
    <url>%2Fpython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类对象 1.类对象支持两种操作：属性引用和实例化。 2.类中一个特殊方法（构造方法)__ init__()，该方法在类实例化时会自动调用，构造方法可以传参数。 3.self代表类的实例，代表当前对象的地址，而非类 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 12345678910111213141516class stu: #定义构造方法 def __init__(self, name, sno): self.n = name self.s = sno print("我先执行--") print(self) #代表当前对象的地址 print(self.__class__) #指向类名student1 = stu("陈小坚", 1706200065)print("学生的名字为：&#123;&#125;,学号为：&#123;&#125;".format(student1.n, student1.s))# 我先执行--# &lt;__main__.stu object at 0x0000020AA2AC3748&gt;# &lt;class '__main__.stu'&gt;# 学生的名字为：陈小坚,学号为：1706200065# 请按任意键继续. . . 继承 继承：子类共享父类的数据（变量）和方法（函数） 如果子类中定义与父类同名的方法或属性，则会自动覆盖父类对应的方法和属性 1234567891011121314# 单继承class fun: def fun1(self): print("我是类fun的函数")class f(fun): def fun1(self): print("我是类f的函数")a = f() #类对象aa.fun1()# 我是类f的函数::::子类的方法覆盖了父类的方法 多继承 方法搜索顺序（类名.__mro______）,这个顺序是跟多继承的括号中父类的顺序有关的 在搜索方法时，是按照 mro 的输出结果 从左至右 的顺序查找的 如果在当前类中 找到方法，就直接执行，不再搜索 如果 没有找到，就查找下一个类 中是否有对应的方法，如果找到，就直接执行，不再搜索 如果找到最后一个类，还没有找到方法，程序报错 总结：子类从多个父类派生，而子类又没有自己的构造函数时， （1）按顺序继承，哪个父类在最前面且它又有自己的构造函数，就继承它的构造函数； （2）如果最前面第一个父类没有构造函数，则继承第2个的构造函数，第2个没有的话，再往后找，以此类推 123456789101112131415161718# 多继承class A: def fun(self): print("这是A的方法")class B: def fun(self): print("这是B的方法")class C(A, B): passc = C()c.fun()print(C.__mro__)# 这是A的方法#(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;) 多继承调用父类方法的方法： super()函数是用于调用父类(超类)的一个方法。 Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx 使用类名.方法名()的 多继承需要注意的问题1.继承关系混乱1234567891011121314151617181920212223242526class A: def __init__(self): print("进入A") print("退出A")class B(A): def __init__(self): print("进入B") A.__init__(self) #注意这里的self是B的实例 print("退出B")class C(A): def __init__(self): print("进入C") A.__init__(self) #注意这里的self是B的实例 print("退出C")class D(A, B): #error 继承关系混乱 def __init__(self): print("进入D") A.__init__(self) B.__init__(self) print("退出D")# 可以定义为 :class D(B, A)或者class(B) 2.多继承中使用类名.方法名()调用父类函数123456789101112131415161718192021222324252627282930313233343536class A: def __init__(self): print("进入A") print("退出A")class B(A): def __init__(self): print("进入B") A.__init__(self) #注意这里的self是B的实例 print("退出B")class C(A): def __init__(self): print("进入C") A.__init__(self) #注意这里的self是B的实例 print("退出C")class D(B, C): def __init__(self): print("进入D") A.__init__(self) B.__init__(self) print("退出D")d = D()# 结果可以发现:类A的函数被执行了两次# A.__init(self)中的self不能省略，跟super.__init__()有区别# 进入D# 进入A# 退出A# 进入B# 进入A# 退出A# 退出B# 退出D 3.多继承中使用super.方法名()调用父类函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# class A:# def __init__(self):# print("进入A")# print("退出A")# class B(A):# def __init__(self):# print("进入B")# A.__init__(self) #注意这里的self是B的实例# print("退出B")# class C(A):# def __init__(self):# print("进入C")# A.__init__(self) #注意这里的self是B的实例# print("退出C")# class D(A, B): #error 继承关系混乱# def __init__(self):# print("进入D")# A.__init__(self)# B.__init__(self)# print("退出D")# # 可以定义为 :class D(B, A)或者class(B)# """# ####################class A: def __init__(self): print("进入A") print("退出A")class B(A): def __init__(self): print("进入B") super().__init__() #注意这里的self是B的实例 print("退出B")class C(A): def __init__(self): print("进入C") super().__init__() #注意这里的self是B的实例 print("退出C")class D(B, C): def __init__(self): print("进入D") super().__init__() # super(D, self).__init__() #理解:可能是我们定义的父类A的init()只有一个默认参数self,而根据博主，多继承中super调用需要传全部的参数，而我们本身就没有参数，所以在这里不需要参数 # 错误的写法: 原因:函数只需要一个参数,但是却传入了两个.所以报错 # super(D, self).__init__(self) # super().__init__(self) print("退出D")d = D()# """ # 问题:super().__init__()函数参数问题# 进入B# 进入C# 进入A# 退出A# 退出C# 退出B # 退出D #请按任意键继续. . . 总结： super()会保证每个父类的函数只被执行一次。至于父类函数执行的顺序是子类的mro顺序来执行的 super函数调用父类函数传递参数的问题： 多继承时，使用super方法，对父类的传参数，应该是由于python中super的算法导致的原因，必须把参数全部传递，否则会报错- 单继承时，使用super方法，则不能全部传递，只能传父类方法所需的参数，否则会报错 多继承时，相对于使用类名.init方法，要把每个父类全部写一遍, 而使用super方法，只需写一句话便执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因 参考https://blog.csdn.net/qq_26442553/article/details/81775449 ———–我是分割线——————————- 类的私有变量和私有方法 类型的私有属性 __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs 类的方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。 类的私有方法 __private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。 类的专有方法 init : 构造函数，在生成对象时调用 del : 析构函数，释放对象时使用 repr : 打印，转换 setitem : 按照索引赋值 getitem: 按照索引获取值 len: 获得长度 cmp: 比较运算 call: 函数调用 add: 加运算 sub: 减运算 mul: 乘运算 truediv: 除运算 mod: 求余运算 pow: 乘方 可以对这些方法进行重载]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的格式化输出---str.format()]]></title>
    <url>%2Fpython%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[前言：python的字符串编码全部是unicode编码 按位置访问参数1234567print('&#123;&#125;, &#123;&#125;, &#123;&#125;'.format('a', 'b', 'c'))print('&#123;1&#125;, &#123;2&#125;, &#123;0&#125;'.format('a', 'b', 'c'))print('&#123;1&#125;&#123;0&#125;&#123;1&#125;'.format('ab', 'hj'))# a, b, c# b, c, a# hjabhj 按名称访问参数12345print('按名称访问参数1：&#123;chen1&#125;,&#123;chen2&#125;'.format(chen1="你好", chen2="你也好啊"))dict1 = &#123;'chen1': "你好", 'chen2': "你也好啊"&#125;print("按名称访问参数2: &#123;chen1&#125;&#123;chen2&#125;".format(**dict1))# 按名称访问参数1：你好,你也好啊# 按名称访问参数2: 你好你也好啊 访问参数的属性1234complex1 = 3-5jprint("这个复数&#123;0&#125;的实数是：&#123;0.real&#125;,虚数是&#123;0.imag&#125;".format(complex1))# 这个复数(3-5j)的实数是：3.0,虚数是-5.0 保留小数点后多少位12345import mathprint('常量pi的值近似为：&#123;0:.3f&#125;'.format(math.pi))print('常量pi的值近似为：&#123;:.3f&#125;'.format(math.pi))# 常量pi的值近似为：3.142# 常量pi的值近似为：3.142 访问参数的项1234567tuple1 = (3, 5)list1 = [3, 5]print("元组的元素为：&#123;0[0]&#125;, &#123;0[1]&#125;".format(tuple1))print("列表的元素为：&#123;0[0]&#125;, &#123;0[1]&#125;".format(list1))# 元组的元素为：3, 5# 列表的元素为：3, 5 替代%s和%r123print("repr()表示的数：&#123;!r&#125;, str()表示的数：&#123;!s&#125;".format('test1', 'test2'))# repr()表示的数：'test1', str()表示的数：test2 对齐文本以及指定宽度12345678910111213print("&#123;:&lt;30&#125;".format('左对齐'))print("&#123;:&gt;30&#125;".format('右对齐'))print("&#123;:^30&#125;".format('居中对齐'))print("&#123;:*^30&#125;".format('居中对齐'))print("&#123;:*&lt;30&#125;".format('左对齐'))print("&#123;:*&gt;30&#125;".format('右对齐'))# 左对齐# 右对齐# 居中对齐# *************居中对齐*************# 左对齐***************************# ***************************右对齐 替代 %+f, %-f 和 % f 以及指定正负号:12345678910111213# '+' 表示标志应该用于正数和负数。# '-' 表示标志应仅用于负数（这是默认行为）。# space 表示应在正数上使用前导空格，在负数上使用减号print("&#123;:+f&#125;; &#123;:+f&#125;".format(3.14, -3.14))print("&#123;: f&#125;; &#123;: f&#125;".format(3.14, -3.14))print("&#123;:-f&#125;; &#123;:-f&#125;".format(3.14, -3.14))# +3.140000; -3.140000# 3.140000; -3.140000# 3.140000; -3.140000 替代 %x 和 %o 以及转换基于不同进位制的值:1234567print("十进制：&#123;0:d&#125;; 十六进制：&#123;0:x&#125;; 八进制：&#123;0:o&#125;; 二进制：&#123;0:b&#125;".format(42))# 十进制：42; 十六进制：2a; 八进制：52; 二进制：101010print("十进制：&#123;0:d&#125;; 十六进制：&#123;0:#x&#125;; 八进制：&#123;0:#o&#125;; 二进制：&#123;0:#b&#125;".format(42))# 十进制：42; 十六进制：0x2a; 八进制：0o52; 二进制：0b101010# 注意&#123;&#125;中的0一定要加，因为format()里面此时只有一个参数，而前面的槽有4个# 在这里format里面的参数和前面的槽是一一对应的，因此当槽的个数大于参数时就会出现报错 使用逗号作为千位分隔符12print("&#123;1:,&#125;||||||&#123;0:,&#125;".format(1234567890, 9999999999999999))# 9,999,999,999,999,999||||||1,234,567,890 表示百分数12345678a = 1b = 3print("10除3等于：&#123;:.2%&#125;".format(a/b))print("10除3等于：&#123;:.3%&#125;".format(a/b))print("10除3等于：&#123;:.4%&#125;".format(a/b))# 10除3等于：33.33%# 10除3等于：33.333%# 10除3等于：33.3333% 使用特定类型的专属格式化1234567891011121314import datetimed = datetime.datetime(2019, 7, 17, 10, 53, 58)print(type(d))print(d)print(str(d))print(repr(d))# &lt;class 'datetime.datetime'&gt;# 2019-07-17 10:53:58# 2019-07-17 10:53:58# datetime.datetime(2019, 7, 17, 10, 53, 58)print('&#123;:%Y-%m-%d %H:%M:%S&#125;'.format(d))# 2019-07-17 10:53:58# 所以直接输出d就行..... 嵌套参数以及更复杂的示例:1234567891011121314151617181920212223242526ip = [192, 168, 0, 1]print("转换为16进制为：&#123;:02X&#125;|&#123;:02X&#125;|&#123;:02X&#125;|&#123;:02X&#125;".format(*ip))print("转换为16进制为：&#123;:2X&#125;|&#123;:2X&#125;|&#123;:2X&#125;|&#123;:2X&#125;".format(*ip))print("转换为16进制为：&#123;:3X&#125;|&#123;:3X&#125;|&#123;:3X&#125;|&#123;:3X&#125;".format(*ip))print("转换为16进制为：&#123;:03X&#125;|&#123;:03X&#125;|&#123;:03X&#125;|&#123;:03X&#125;".format(*ip))#总之注意“：”前面的数字要与format()内的参数个数对应，而十六进制的"X""x"是控制大于9的字母的大小写# 转换为16进制为：C0|A8|00|01# 转换为16进制为：C0|A8| 0| 1# 转换为16进制为： C0| A8| 0| 1# 转换为16进制为：0C0|0A8|000|001width = 5for num in range(5, 12): for base in "dXob": print('&#123;0:&#123;width&#125;&#123;base&#125;&#125;'.format(num, width=width, base=base), end=" ") print()# 5 5 5 101# 6 6 6 110# 7 7 7 111# 8 8 10 1000# 9 9 11 1001# 10 A 12 1010# 11 B 13 1011 补充：int():用于将一个字符串或数字转换为整型。int(x, base=10) x–字符串或数字； base–进制数，默认是十进制 123int('12',16) # 如果是带参数base的话，12要以字符串的形式进行输入，12 为 16进制#因此12是一个十六进制数，所以转化为二进制数为0001 0010，将二进制数转化成十进制数为：2+16 =18，输出为18]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中a += b和a = a + b的区别]]></title>
    <url>%2Fmyblog_2%2F</url>
    <content type="text"><![CDATA[变量和对象的理解 在python中，变量是没有类型的，当使用变量的时候，必须要给这个变量赋值，而没有赋值，那么python认为这个变量没有定义。对象赋值实际上是对象的引用。当创建一个对象，当创建一个对象，然后把它赋值给另一个变量的时候，python并没有拷贝这个对象，而是拷贝这个对象的引用。 在python中，对象分为可变和不可变的 可变的对象：list，set，dict 不可变的对象：int，float，long，str，tuple 变量无类型，对象有类型。 变量是指向内存中的对象的一个指针，都是值的引用 对象是内存中存储数据的实体，变量是指向对象的指针 在函数中参数是传引用的，如果一个变量进到函数中，被改变，那么这个变量所指的对象，如果是可变的对象，那么变量还是指向原先对象，如果是不可变对象，那么这个变量所指的对象就不是之前所指向的对象，旧的对象因为没被使用而被python的垃圾回收机制回收 12345678910a = [1, 2, 3]b = aprint(b)b += aprint(b)print(a)#运行结果：#[1, 2, 3]#[1, 2, 3, 1, 2, 3]#[1, 2, 3, 1, 2, 3] 123456789a = [1, 2, 3]b = aprint(b)b = b + aprint(b)print(a)# [1, 2, 3]# [1, 2, 3, 1, 2, 3]# [1, 2, 3] 123456789101112131415161718192021def fun_1(p): p += [1] print("函数中的p的id为：", id(p))def fun_2(p): p = p + [1] print("函数中的p的id为：", id(p))p1 = [2, 2]p2 = [2, 2]fun_1(p1)fun_2(p2)print("p1的id：", id(p1), "p1列表的值为", p1)print("p2的id: ", id(p2), "p2列表的值为", p2)# 操作结果：# 函数中的p的id为： 1381806107656# 函数中的p的id为： 1381810873096# p1的id： 1381806107656 p1列表的值为 [2, 2, 1]# p2的id: 1381806106504 p2列表的值为 [2, 2] 由此可以看出+= 操作的对象是可变的，例如list,那么对他进行操作就是对原来所指的对象进行操作，即是对原来存储地址中的内容进行操作，存储的地址不会改变（由p和p1的id可以知道，当然这是建立在这个对象是可变的）。而对与z = x + y这类来说，就是创建一个新的对象，然后z指向这个对象。 更新 变量是对数据的引用，也就是说用赋值语句对变量重新赋值时，python为其分配了新的内存单元，变量将指向新的地址。这种说法是针对一般情况的… 至于特殊情况，就是可变对象对于a = a + b和a += b之间的区别….记住这种特殊情况就好了=-= 函数参数传递的影响 实参的值传递给形参，实际上是将实参的所指向的对象的地址传递给形参，因此，如果传递对象是不可变对象（数值，字符，元组等），在函数体中形参值的变化不会影响到实参。如果传递的对象是可变对象（r列表，字典），在函数中形参值的变化会影响到实参。也就是说，变量名相当于指针，指向一个对象，例如数值5，因为数值5是不可变的，当变量重新赋值时，变量也就指向一个新的对象。 更新对于可哈希对象和不可变对象的理解 首先，可变对象（列表，集合，字典）是不可哈希的 然后，不可变对象（数字，字符串，元组）是可哈希的 但是有个特例，[{}],即是列表中嵌套字典是可哈希的 123456789101112portfplio = &#123; &#123;'name':'陈小坚1', 'prices':91.1&#125;, &#123;'name':'陈小坚2', 'prices':92.1&#125;, &#123;'name':'陈小坚3', 'prices':93.1&#125;, &#123;'name':'陈小坚4', 'prices':94.1&#125;, &#123;'name':'陈小坚5', 'prices':95.1&#125;, &#123;'name':'陈小坚6', 'prices':96.1&#125;,&#125;# 发生异常: TypeError# unhashable type: 'dict'print(heapq.nlargest(3, portfplio, key=lambda x:x['prices'])) 123456789101112portfplio = [ &#123;'name':'陈小坚1', 'prices':91.1&#125;, &#123;'name':'陈小坚2', 'prices':92.1&#125;, &#123;'name':'陈小坚3', 'prices':93.1&#125;, &#123;'name':'陈小坚4', 'prices':94.1&#125;, &#123;'name':'陈小坚5', 'prices':95.1&#125;, &#123;'name':'陈小坚6', 'prices':96.1&#125;,]print(heapq.nlargest(3, portfplio, key=lambda x:x['prices']))# [&#123;'name': '陈小坚6', 'prices': 96.1&#125;, &#123;'name': '陈小坚5', 'prices': 95.1&#125;, &#123;'name': '陈小坚4', 'prices': 94.1&#125;]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo博客系统]]></title>
    <url>%2Fmyblog_1%2F</url>
    <content type="text"><![CDATA[使用hexo 框架搭建个人博客准备工作： 注册Github账号 安装node.js 安装git 搭建过程 打开git bash,配置git 输入 git config –global user.name “你的用户名” 输入 git config –global user.email “你的邮箱” 登录你的github账号，创建一个仓库 仓库名是默认格式的 username.github.io (username是你的用户名) 配置ssh key 打开git bash输入ssh-keygen -t rsa -C “邮件地址”，连续回车键3次然后就会生成一个文件，路径在C盘目录下用户目录下有个.ssh文件，里面有两个文件，存放着ssh key 打开id_rsa.pub文件，复制，然后到你的github主页上打开settings,在ssh and GPG Keys下粘贴 打开git bash，下载hexo 命令：npm install -g hexo 设置存放的位置，在任意一个盘中，创建一个目录，这是你存放代码的位置，打开文件，鼠标右键，有Git bash here,然后就进入到这个目录在git bash环境 初始化 命令：hexo init,这时hexo就会自动生成一个文件 其中的sourse文件夹就存放你的md文件，用来写博客 public存放md文件对应的html文件 _config.yml文件就是配置文件，修改配置都是需要操作他 theme文件夹就存放你的博客框架的主题，对应的主题可以去网上hexo的官方网站下载，常用的yilia 然后在git bash输入命令 hexo g 生成静态页面到pubilc文件，输入hexo s,启动本地服务器，localhost::4000查看是否成功 然后现在要上传到github上，先在之前的_config.yml文件中配置一下，配置完后输入hexo d上传，打开”用户名.github.io”就可以看到啦！！！ &gt;deploy: &gt; type: git &gt; repository: 这里填写你之前配置ssh的两个url，随便一个都可以 例如：git@github.com:liuxianan/liuxianan.github.io.git &gt; branch: master]]></content>
      <categories>
        <category>博客框架</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
